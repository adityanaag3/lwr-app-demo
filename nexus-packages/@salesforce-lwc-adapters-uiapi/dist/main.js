import { createWireAdapterConstructor, bindWireRefresh } from '@luvio/lwc-luvio';
import { withDefaultLuvio } from '@salesforce/lds-default-luvio';

const { hasOwnProperty: ObjectPrototypeHasOwnProperty } = Object.prototype;
const { keys: ObjectKeys, freeze: ObjectFreeze, create: ObjectCreate } = Object;
const { stringify: JSONStringify } = JSON;
const { isArray: ArrayIsArray } = Array;
const { push: ArrayPrototypePush } = Array.prototype;
function isPromise(value) {
    return value.then !== undefined;
}
/**
 * Validates an adapter config is well-formed.
 * @param config The config to validate.
 * @param adapter The adapter validation configuration.
 * @param oneOf The keys the config must contain at least one of.
 * @throws A TypeError if config doesn't satisfy the adapter's config validation.
 */
function validateConfig(config, adapter, oneOf) {
    const { displayName } = adapter;
    const { required, optional, unsupported } = adapter.parameters;
    if (config === undefined ||
        required.every(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);
    }
    if (oneOf && oneOf.some(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);
    }
    if (unsupported !== undefined &&
        unsupported.some(req => ObjectPrototypeHasOwnProperty.call(config, req))) {
        throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);
    }
    const supported = required.concat(optional);
    if (ObjectKeys(config).some(key => !supported.includes(key))) {
        throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);
    }
}
function untrustedIsObject(untrusted) {
    return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray(untrusted) === false;
}
function areRequiredParametersPresent(config, configPropertyNames) {
    return configPropertyNames.parameters.required.every(req => req in config);
}
function refreshable(adapter, resolve) {
    return (config) => {
        const result = adapter(config);
        if (result === null) {
            return result;
        }
        if (isPromise(result)) {
            return result.then(snapshot => {
                snapshot.refresh = {
                    config,
                    resolve,
                };
                return snapshot;
            });
        }
        result.refresh = {
            config,
            resolve,
        };
        return result;
    };
}
const SNAPSHOT_STATE_UNFULFILLED = 'Unfulfilled';
const snapshotRefreshOptions = {
    headers: {
        'Cache-Control': 'no-cache',
    },
};
/**
 * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
 * This is needed because insertion order for JSON.stringify(object) affects output:
 * JSON.stringify({a: 1, b: 2})
 *      "{"a":1,"b":2}"
 * JSON.stringify({b: 2, a: 1})
 *      "{"b":2,"a":1}"
 * @param data Data to be JSON-stringified.
 * @returns JSON.stringified value with consistent ordering of keys.
 */
function stableJSONStringify(node) {
    // This is for Date values.
    if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
    }
    if (node === undefined) {
        return;
    }
    if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
    }
    if (typeof node !== 'object') {
        return JSONStringify(node);
    }
    let i;
    let out;
    if (ArrayIsArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
            if (i) {
                out += ',';
            }
            out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
    }
    if (node === null) {
        return 'null';
    }
    const keys = ObjectKeys(node).sort();
    out = '';
    for (i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
            continue;
        }
        if (out) {
            out += ',';
        }
        out += JSONStringify(key) + ':' + value;
    }
    return '{' + out + '}';
}
function getFetchResponseStatusText(status) {
    switch (status) {
        case 200:
            return 'OK';
        case 304:
            return 'Not Modified';
        case 404:
            return 'Not Found';
        case 400:
            return 'Bad Request';
        case 500:
            return 'Server Error';
        default:
            return `Unexpected HTTP Status Code: ${status}`;
    }
}
const keyPrefix = 'UiApi::';

const { freeze: ObjectFreeze$1, keys: ObjectKeys$1 } = Object;
const { isArray: ArrayIsArray$1 } = Array;
const { stringify: JSONStringify$1 } = JSON;
function equalsArray(a, b, equalsItem) {
    const aLength = a.length;
    const bLength = b.length;
    if (aLength !== bLength) {
        return false;
    }
    for (let i = 0; i < aLength; i++) {
        if (equalsItem(a[i], b[i]) === false) {
            return false;
        }
    }
    return true;
}
function equalsObject(a, b, equalsProp) {
    const aKeys = ObjectKeys$1(a).sort();
    const bKeys = ObjectKeys$1(b).sort();
    const aKeysLength = aKeys.length;
    const bKeysLength = bKeys.length;
    if (aKeysLength !== bKeysLength) {
        return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
        const key = aKeys[i];
        if (key !== bKeys[i]) {
            return false;
        }
        if (equalsProp(a[key], b[key]) === false) {
            return false;
        }
    }
    return true;
}
function deepFreeze(value) {
    // No need to freeze primitives
    if (typeof value !== 'object' || value === null) {
        return;
    }
    if (ArrayIsArray$1(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
            deepFreeze(value[i]);
        }
    }
    else {
        const keys = ObjectKeys$1(value);
        for (let i = 0, len = keys.length; i < len; i += 1) {
            deepFreeze(value[keys[i]]);
        }
    }
    ObjectFreeze$1(value);
}
function createLink(ref) {
    return {
        __ref: ref,
    };
}

function validate(obj, path = 'ListColumnRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select = function ListColumnRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'fieldApiName',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'sortable',
                kind: 'Scalar'
            }
        ]
    };
};

function validate$1(obj, path = 'ListFilterByInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_operandLabels = obj.operandLabels;
        const path_operandLabels = path + '.operandLabels';
        if (!ArrayIsArray$1(obj_operandLabels)) {
            return new TypeError('Expected "array" but received "' + typeof obj_operandLabels + '" (at "' + path_operandLabels + '")');
        }
        for (let i = 0; i < obj_operandLabels.length; i++) {
            const obj_operandLabels_item = obj_operandLabels[i];
            const path_operandLabels_item = path_operandLabels + '[' + i + ']';
            if (typeof obj_operandLabels_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_operandLabels_item + '" (at "' + path_operandLabels_item + '")');
            }
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$1 = function ListFilterByInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'fieldApiName',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'operandLabels',
                kind: 'Scalar',
                plural: true
            },
            {
                name: 'operator',
                kind: 'Scalar'
            }
        ]
    };
};
function deepFreeze$1(input) {
    const input_operandLabels = input.operandLabels;
    ObjectFreeze$1(input_operandLabels);
    ObjectFreeze$1(input);
}

function validate$2(obj, path = 'ListOrderByInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_isAscending = obj.isAscending;
        const path_isAscending = path + '.isAscending';
        if (typeof obj_isAscending !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isAscending + '" (at "' + path_isAscending + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$2 = function ListOrderByInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'fieldApiName',
                kind: 'Scalar'
            },
            {
                name: 'isAscending',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            }
        ]
    };
};
function deepFreeze$2(input) {
    ObjectFreeze$1(input);
}

function validate$3(obj, path = 'ListUserPreferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_columnWidths = obj.columnWidths;
        const path_columnWidths = path + '.columnWidths';
        if (typeof obj_columnWidths !== 'object' || ArrayIsArray$1(obj_columnWidths) || obj_columnWidths === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_columnWidths + '" (at "' + path_columnWidths + '")');
        }
        const obj_columnWidths_keys = ObjectKeys$1(obj_columnWidths);
        for (let i = 0; i < obj_columnWidths_keys.length; i++) {
            const key = obj_columnWidths_keys[i];
            const obj_columnWidths_prop = obj_columnWidths[key];
            const path_columnWidths_prop = path_columnWidths + '["' + key + '"]';
            if (typeof obj_columnWidths_prop !== 'number' || (typeof obj_columnWidths_prop === 'number' && Math.floor(obj_columnWidths_prop) !== obj_columnWidths_prop)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_columnWidths_prop + '" (at "' + path_columnWidths_prop + '")');
            }
        }
        const obj_columnWrap = obj.columnWrap;
        const path_columnWrap = path + '.columnWrap';
        if (typeof obj_columnWrap !== 'object' || ArrayIsArray$1(obj_columnWrap) || obj_columnWrap === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_columnWrap + '" (at "' + path_columnWrap + '")');
        }
        const obj_columnWrap_keys = ObjectKeys$1(obj_columnWrap);
        for (let i = 0; i < obj_columnWrap_keys.length; i++) {
            const key = obj_columnWrap_keys[i];
            const obj_columnWrap_prop = obj_columnWrap[key];
            const path_columnWrap_prop = path_columnWrap + '["' + key + '"]';
            if (typeof obj_columnWrap_prop !== 'boolean') {
                return new TypeError('Expected "boolean" but received "' + typeof obj_columnWrap_prop + '" (at "' + path_columnWrap_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$3 = function ListUserPreferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'columnWidths',
                kind: 'Scalar',
                map: true
            },
            {
                name: 'columnWrap',
                kind: 'Scalar',
                map: true
            }
        ]
    };
};
function deepFreeze$3(input) {
    const input_columnWidths = input.columnWidths;
    const input_columnWidths_keys = Object.keys(input_columnWidths);
    const input_columnWidths_length = input_columnWidths_keys.length;
    for (let i = 0; i < input_columnWidths_length; i++) {
        const key = input_columnWidths_keys[i];
    }
    ObjectFreeze$1(input_columnWidths);
    const input_columnWrap = input.columnWrap;
    const input_columnWrap_keys = Object.keys(input_columnWrap);
    const input_columnWrap_length = input_columnWrap_keys.length;
    for (let i = 0; i < input_columnWrap_length; i++) {
        const key = input_columnWrap_keys[i];
    }
    ObjectFreeze$1(input_columnWrap);
    ObjectFreeze$1(input);
}

function validate$4(obj, path = 'ListReferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listViewApiName = obj.listViewApiName;
        const path_listViewApiName = path + '.listViewApiName';
        let obj_listViewApiName_union0 = null;
        const obj_listViewApiName_union0_error = (() => {
            if (typeof obj_listViewApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union0_error != null) {
            obj_listViewApiName_union0 = obj_listViewApiName_union0_error.message;
        }
        let obj_listViewApiName_union1 = null;
        const obj_listViewApiName_union1_error = (() => {
            if (obj_listViewApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union1_error != null) {
            obj_listViewApiName_union1 = obj_listViewApiName_union1_error.message;
        }
        if (obj_listViewApiName_union0 && obj_listViewApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_listViewApiName + '")';
            message += '\n' + obj_listViewApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_listViewApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder(config) {
    return keyPrefix + 'ListReferenceRepresentation:' + (config.id === null ? '' : config.id);
}
function keyBuilderFromType(object) {
    const keyParams = {
        id: object.id
    };
    return keyBuilder(keyParams);
}
function normalize(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$4 = function ListReferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'listViewApiName',
                kind: 'Scalar'
            },
            {
                name: 'objectApiName',
                kind: 'Scalar'
            },
            {
                name: 'type',
                kind: 'Scalar'
            }
        ]
    };
};
function equals(existing, incoming) {
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_listViewApiName = existing.listViewApiName;
    const incoming_listViewApiName = incoming.listViewApiName;
    if (!(existing_listViewApiName === incoming_listViewApiName)) {
        return false;
    }
    return true;
}
const ingest = function ListReferenceRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$4(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType(input);
    let incomingRecord = normalize(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

const TTL = 900000;
function validate$5(obj, path = 'ListInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_cloneable = obj.cloneable;
        const path_cloneable = path + '.cloneable';
        if (typeof obj_cloneable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_cloneable + '" (at "' + path_cloneable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_displayColumns = obj.displayColumns;
        const path_displayColumns = path + '.displayColumns';
        if (!ArrayIsArray$1(obj_displayColumns)) {
            return new TypeError('Expected "array" but received "' + typeof obj_displayColumns + '" (at "' + path_displayColumns + '")');
        }
        for (let i = 0; i < obj_displayColumns.length; i++) {
            const obj_displayColumns_item = obj_displayColumns[i];
            const path_displayColumns_item = path_displayColumns + '[' + i + ']';
            const referencepath_displayColumns_itemValidationError = validate(obj_displayColumns_item, path_displayColumns_item);
            if (referencepath_displayColumns_itemValidationError !== null) {
                let message = 'Object doesn\'t match ListColumnRepresentation (at "' + path_displayColumns_item + '")\n';
                message += referencepath_displayColumns_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterLogicString = obj.filterLogicString;
        const path_filterLogicString = path + '.filterLogicString';
        let obj_filterLogicString_union0 = null;
        const obj_filterLogicString_union0_error = (() => {
            if (typeof obj_filterLogicString !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
            }
        })();
        if (obj_filterLogicString_union0_error != null) {
            obj_filterLogicString_union0 = obj_filterLogicString_union0_error.message;
        }
        let obj_filterLogicString_union1 = null;
        const obj_filterLogicString_union1_error = (() => {
            if (obj_filterLogicString !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
            }
        })();
        if (obj_filterLogicString_union1_error != null) {
            obj_filterLogicString_union1 = obj_filterLogicString_union1_error.message;
        }
        if (obj_filterLogicString_union0 && obj_filterLogicString_union1) {
            let message = 'Object doesn\'t match union (at "' + path_filterLogicString + '")';
            message += '\n' + obj_filterLogicString_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_filterLogicString_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_filteredByInfo = obj.filteredByInfo;
        const path_filteredByInfo = path + '.filteredByInfo';
        if (!ArrayIsArray$1(obj_filteredByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_filteredByInfo + '" (at "' + path_filteredByInfo + '")');
        }
        for (let i = 0; i < obj_filteredByInfo.length; i++) {
            const obj_filteredByInfo_item = obj_filteredByInfo[i];
            const path_filteredByInfo_item = path_filteredByInfo + '[' + i + ']';
            const referencepath_filteredByInfo_itemValidationError = validate$1(obj_filteredByInfo_item, path_filteredByInfo_item);
            if (referencepath_filteredByInfo_itemValidationError !== null) {
                let message = 'Object doesn\'t match ListFilterByInfoRepresentation (at "' + path_filteredByInfo_item + '")\n';
                message += referencepath_filteredByInfo_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        let obj_label_union0 = null;
        const obj_label_union0_error = (() => {
            if (typeof obj_label !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
            }
        })();
        if (obj_label_union0_error != null) {
            obj_label_union0 = obj_label_union0_error.message;
        }
        let obj_label_union1 = null;
        const obj_label_union1_error = (() => {
            if (obj_label !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_label + '" (at "' + path_label + '")');
            }
        })();
        if (obj_label_union1_error != null) {
            obj_label_union1 = obj_label_union1_error.message;
        }
        if (obj_label_union0 && obj_label_union1) {
            let message = 'Object doesn\'t match union (at "' + path_label + '")';
            message += '\n' + obj_label_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_label_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        if (typeof obj_listReference !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_listReference + '" (at "' + path_listReference + '")');
        }
        const obj_orderedByInfo = obj.orderedByInfo;
        const path_orderedByInfo = path + '.orderedByInfo';
        if (!ArrayIsArray$1(obj_orderedByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_orderedByInfo + '" (at "' + path_orderedByInfo + '")');
        }
        for (let i = 0; i < obj_orderedByInfo.length; i++) {
            const obj_orderedByInfo_item = obj_orderedByInfo[i];
            const path_orderedByInfo_item = path_orderedByInfo + '[' + i + ']';
            const referencepath_orderedByInfo_itemValidationError = validate$2(obj_orderedByInfo_item, path_orderedByInfo_item);
            if (referencepath_orderedByInfo_itemValidationError !== null) {
                let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedByInfo_item + '")\n';
                message += referencepath_orderedByInfo_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
        const obj_userPreferences = obj.userPreferences;
        const path_userPreferences = path + '.userPreferences';
        const referencepath_userPreferencesValidationError = validate$3(obj_userPreferences, path_userPreferences);
        if (referencepath_userPreferencesValidationError !== null) {
            let message = 'Object doesn\'t match ListUserPreferenceRepresentation (at "' + path_userPreferences + '")\n';
            message += referencepath_userPreferencesValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_visibility = obj.visibility;
        const path_visibility = path + '.visibility';
        if (typeof obj_visibility !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_visibility + '" (at "' + path_visibility + '")');
        }
        const obj_visibilityEditable = obj.visibilityEditable;
        const path_visibilityEditable = path + '.visibilityEditable';
        if (typeof obj_visibilityEditable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_visibilityEditable + '" (at "' + path_visibilityEditable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1(config) {
    return keyPrefix + 'ListInfoRepresentation:' + (config.listViewApiName === null ? '' : config.listViewApiName) + ':' + config.objectApiName + ':' + config.type;
}
function keyBuilderFromType$1(object) {
    const keyParams = {
        listViewApiName: object.listReference.listViewApiName,
        objectApiName: object.listReference.objectApiName,
        type: object.listReference.type
    };
    return keyBuilder$1(keyParams);
}
function normalize$1(input, existing, path, luvio, store, timestamp) {
    const input_listReference = input.listReference;
    const input_listReference_id = path.fullPath + '__listReference';
    input.listReference = ingest(input_listReference, {
        fullPath: input_listReference_id,
        propertyName: 'listReference',
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, luvio, store);
    return input;
}
const select$5 = function ListInfoRepresentationSelect() {
    const { selections: ListColumnRepresentation__selections, opaque: ListColumnRepresentation__opaque, } = select();
    const { selections: ListFilterByInfoRepresentation__selections, opaque: ListFilterByInfoRepresentation__opaque, } = select$1();
    const { selections: ListOrderByInfoRepresentation__selections, opaque: ListOrderByInfoRepresentation__opaque, } = select$2();
    const { selections: ListUserPreferenceRepresentation__selections, opaque: ListUserPreferenceRepresentation__opaque, } = select$3();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'cloneable',
                kind: 'Scalar'
            },
            {
                name: 'createable',
                kind: 'Scalar'
            },
            {
                name: 'deletable',
                kind: 'Scalar'
            },
            {
                name: 'displayColumns',
                kind: 'Object',
                plural: true,
                selections: ListColumnRepresentation__selections
            },
            {
                name: 'filterLogicString',
                kind: 'Scalar'
            },
            {
                name: 'filteredByInfo',
                kind: 'Object',
                plural: true,
                selections: ListFilterByInfoRepresentation__selections
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'listReference',
                kind: 'Link',
                fragment: select$4()
            },
            {
                name: 'orderedByInfo',
                kind: 'Object',
                plural: true,
                selections: ListOrderByInfoRepresentation__selections
            },
            {
                name: 'updateable',
                kind: 'Scalar'
            },
            {
                name: 'userPreferences',
                kind: 'Object',
                selections: ListUserPreferenceRepresentation__selections
            },
            {
                name: 'visibility',
                kind: 'Scalar'
            },
            {
                name: 'visibilityEditable',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$1(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
const ingest$1 = function ListInfoRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$5(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$1(input);
    let incomingRecord = normalize$1(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$1(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function validate$6(obj, path = 'RecordTypeInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_available = obj.available;
        const path_available = path + '.available';
        if (typeof obj_available !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_available + '" (at "' + path_available + '")');
        }
        const obj_defaultRecordTypeMapping = obj.defaultRecordTypeMapping;
        const path_defaultRecordTypeMapping = path + '.defaultRecordTypeMapping';
        if (typeof obj_defaultRecordTypeMapping !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_defaultRecordTypeMapping + '" (at "' + path_defaultRecordTypeMapping + '")');
        }
        const obj_master = obj.master;
        const path_master = path + '.master';
        if (typeof obj_master !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_master + '" (at "' + path_master + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$6 = function RecordTypeInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'available',
                kind: 'Scalar'
            },
            {
                name: 'defaultRecordTypeMapping',
                kind: 'Scalar'
            },
            {
                name: 'master',
                kind: 'Scalar'
            },
            {
                name: 'name',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$2(existing, incoming) {
    const existing_available = existing.available;
    const incoming_available = incoming.available;
    if (!(existing_available === incoming_available)) {
        return false;
    }
    const existing_defaultRecordTypeMapping = existing.defaultRecordTypeMapping;
    const incoming_defaultRecordTypeMapping = incoming.defaultRecordTypeMapping;
    if (!(existing_defaultRecordTypeMapping === incoming_defaultRecordTypeMapping)) {
        return false;
    }
    const existing_master = existing.master;
    const incoming_master = incoming.master;
    if (!(existing_master === incoming_master)) {
        return false;
    }
    const existing_name = existing.name;
    const incoming_name = incoming.name;
    if (!(existing_name === incoming_name)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
function deepFreeze$4(input) {
    ObjectFreeze$1(input);
}

function validate$7(obj, path = 'RecordCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        let obj_currentPageToken_union0 = null;
        const obj_currentPageToken_union0_error = (() => {
            if (typeof obj_currentPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
            }
        })();
        if (obj_currentPageToken_union0_error != null) {
            obj_currentPageToken_union0 = obj_currentPageToken_union0_error.message;
        }
        let obj_currentPageToken_union1 = null;
        const obj_currentPageToken_union1_error = (() => {
            if (obj_currentPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
            }
        })();
        if (obj_currentPageToken_union1_error != null) {
            obj_currentPageToken_union1 = obj_currentPageToken_union1_error.message;
        }
        if (obj_currentPageToken_union0 && obj_currentPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_currentPageToken + '")';
            message += '\n' + obj_currentPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_currentPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray$1(obj_records)) {
            return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
            const obj_records_item = obj_records[i];
            const path_records_item = path_records + '[' + i + ']';
            if (typeof obj_records_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$2(input, existing, path, luvio, store, timestamp) {
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$4(input_records_item, {
            fullPath: input_records_item_id,
            propertyName: i,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
const select$7 = function RecordCollectionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'count',
                kind: 'Scalar'
            },
            {
                name: 'currentPageToken',
                kind: 'Scalar'
            },
            {
                name: 'currentPageUrl',
                kind: 'Scalar'
            },
            {
                name: 'nextPageToken',
                kind: 'Scalar'
            },
            {
                name: 'nextPageUrl',
                kind: 'Scalar'
            },
            {
                name: 'previousPageToken',
                kind: 'Scalar'
            },
            {
                name: 'previousPageUrl',
                kind: 'Scalar'
            },
            {
                name: 'records',
                kind: 'Link',
                plural: true,
                fragment: select$9()
            }
        ]
    };
};
function equals$3(existing, incoming) {
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
            return false;
        }
    });
    if (equals_records_items === false) {
        return false;
    }
    return true;
}
const ingest$2 = function RecordCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$7(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$2(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$3(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 120000);
    return createLink(key);
};

function validate$8(obj, path = 'FieldValueRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayValue = obj.displayValue;
        const path_displayValue = path + '.displayValue';
        let obj_displayValue_union0 = null;
        const obj_displayValue_union0_error = (() => {
            if (typeof obj_displayValue !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_displayValue + '" (at "' + path_displayValue + '")');
            }
        })();
        if (obj_displayValue_union0_error != null) {
            obj_displayValue_union0 = obj_displayValue_union0_error.message;
        }
        let obj_displayValue_union1 = null;
        const obj_displayValue_union1_error = (() => {
            if (obj_displayValue !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_displayValue + '" (at "' + path_displayValue + '")');
            }
        })();
        if (obj_displayValue_union1_error != null) {
            obj_displayValue_union1 = obj_displayValue_union1_error.message;
        }
        if (obj_displayValue_union0 && obj_displayValue_union1) {
            let message = 'Object doesn\'t match union (at "' + path_displayValue + '")';
            message += '\n' + obj_displayValue_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_displayValue_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        let obj_value_union0 = null;
        const obj_value_union0_error = (() => {
            if (typeof obj_value !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union0_error != null) {
            obj_value_union0 = obj_value_union0_error.message;
        }
        let obj_value_union1 = null;
        const obj_value_union1_error = (() => {
            if (typeof obj_value !== 'boolean') {
                return new TypeError('Expected "boolean" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union1_error != null) {
            obj_value_union1 = obj_value_union1_error.message;
        }
        let obj_value_union2 = null;
        const obj_value_union2_error = (() => {
            if (typeof obj_value !== 'number') {
                return new TypeError('Expected "number" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union2_error != null) {
            obj_value_union2 = obj_value_union2_error.message;
        }
        let obj_value_union3 = null;
        const obj_value_union3_error = (() => {
            if (typeof obj_value !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union3_error != null) {
            obj_value_union3 = obj_value_union3_error.message;
        }
        let obj_value_union4 = null;
        const obj_value_union4_error = (() => {
            if (obj_value !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union4_error != null) {
            obj_value_union4 = obj_value_union4_error.message;
        }
        if (obj_value_union0 && obj_value_union1 && obj_value_union2 && obj_value_union3 && obj_value_union4) {
            let message = 'Object doesn\'t match union (at "' + path_value + '")';
            message += '\n' + obj_value_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union1.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union2.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union3.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union4.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$3(input, existing, path, luvio, store, timestamp) {
    const input_value = input.value;
    const input_value_id = path.fullPath + '__value';
    if (input_value !== null && typeof input_value === 'object') {
        input.value = ingest$4(input_value, {
            fullPath: input_value_id,
            propertyName: 'value',
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
const select$8 = function FieldValueRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'displayValue',
                kind: 'Scalar'
            },
            {
                name: 'value',
                kind: 'Link',
                nullable: true,
                fragment: select$9()
            }
        ]
    };
};
function equals$4(existing, incoming) {
    const existing_displayValue = existing.displayValue;
    const incoming_displayValue = incoming.displayValue;
    if (!(existing_displayValue === incoming_displayValue)) {
        return false;
    }
    const existing_value = existing.value;
    const incoming_value = incoming.value;
    if (!(existing_value === incoming_value
        || (existing_value != null &&
            incoming_value != null &&
            existing_value.__ref != null &&
            incoming_value.__ref != null &&
            existing_value.__ref === incoming_value.__ref))) {
        return false;
    }
    return true;
}
const ingest$3 = function FieldValueRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$8(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$3(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$4(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

const VIEW_ENTITY_API_NAME = 'Name';
const VIEW_ENTITY_KEY_PREFIX = `${keyPrefix}RecordViewEntityRepresentation:${VIEW_ENTITY_API_NAME}:`;
const keyBuilderFromType$2 = function RecordRepresentationKeyBuilderFromType(object) {
    const { apiName, id } = object;
    if (apiName === VIEW_ENTITY_API_NAME) {
        return VIEW_ENTITY_KEY_PREFIX + id;
    }
    return keyBuilderFromType$3(object);
};

const TTL$1 = 30000;
function validate$9(obj, path = 'RecordRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (typeof obj_childRelationships !== 'object' || ArrayIsArray$1(obj_childRelationships) || obj_childRelationships === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        const obj_childRelationships_keys = ObjectKeys$1(obj_childRelationships);
        for (let i = 0; i < obj_childRelationships_keys.length; i++) {
            const key = obj_childRelationships_keys[i];
            const obj_childRelationships_prop = obj_childRelationships[key];
            const path_childRelationships_prop = path_childRelationships + '["' + key + '"]';
            if (typeof obj_childRelationships_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_childRelationships_prop + '" (at "' + path_childRelationships_prop + '")');
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedById = obj.lastModifiedById;
        const path_lastModifiedById = path + '.lastModifiedById';
        let obj_lastModifiedById_union0 = null;
        const obj_lastModifiedById_union0_error = (() => {
            if (typeof obj_lastModifiedById !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union0_error != null) {
            obj_lastModifiedById_union0 = obj_lastModifiedById_union0_error.message;
        }
        let obj_lastModifiedById_union1 = null;
        const obj_lastModifiedById_union1_error = (() => {
            if (obj_lastModifiedById !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union1_error != null) {
            obj_lastModifiedById_union1 = obj_lastModifiedById_union1_error.message;
        }
        if (obj_lastModifiedById_union0 && obj_lastModifiedById_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedById + '")';
            message += '\n' + obj_lastModifiedById_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedById_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
            if (typeof obj_lastModifiedDate !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
            obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
            if (obj_lastModifiedDate !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
            obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
            message += '\n' + obj_lastModifiedDate_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedDate_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeInfo = obj.recordTypeInfo;
        const path_recordTypeInfo = path + '.recordTypeInfo';
        let obj_recordTypeInfo_union0 = null;
        const obj_recordTypeInfo_union0_error = (() => {
            const referencepath_recordTypeInfoValidationError = validate$6(obj_recordTypeInfo, path_recordTypeInfo);
            if (referencepath_recordTypeInfoValidationError !== null) {
                let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfo + '")\n';
                message += referencepath_recordTypeInfoValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_recordTypeInfo_union0_error != null) {
            obj_recordTypeInfo_union0 = obj_recordTypeInfo_union0_error.message;
        }
        let obj_recordTypeInfo_union1 = null;
        const obj_recordTypeInfo_union1_error = (() => {
            if (obj_recordTypeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeInfo + '" (at "' + path_recordTypeInfo + '")');
            }
        })();
        if (obj_recordTypeInfo_union1_error != null) {
            obj_recordTypeInfo_union1 = obj_recordTypeInfo_union1_error.message;
        }
        if (obj_recordTypeInfo_union0 && obj_recordTypeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeInfo + '")';
            message += '\n' + obj_recordTypeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_systemModstamp = obj.systemModstamp;
        const path_systemModstamp = path + '.systemModstamp';
        let obj_systemModstamp_union0 = null;
        const obj_systemModstamp_union0_error = (() => {
            if (typeof obj_systemModstamp !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union0_error != null) {
            obj_systemModstamp_union0 = obj_systemModstamp_union0_error.message;
        }
        let obj_systemModstamp_union1 = null;
        const obj_systemModstamp_union1_error = (() => {
            if (obj_systemModstamp !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union1_error != null) {
            obj_systemModstamp_union1 = obj_systemModstamp_union1_error.message;
        }
        if (obj_systemModstamp_union0 && obj_systemModstamp_union1) {
            let message = 'Object doesn\'t match union (at "' + path_systemModstamp + '")';
            message += '\n' + obj_systemModstamp_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_systemModstamp_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_weakEtag = obj.weakEtag;
        const path_weakEtag = path + '.weakEtag';
        if (typeof obj_weakEtag !== 'number' || (typeof obj_weakEtag === 'number' && Math.floor(obj_weakEtag) !== obj_weakEtag)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_weakEtag + '" (at "' + path_weakEtag + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$2(config) {
    return keyPrefix + 'RecordRepresentation:' + config.recordId;
}
function keyBuilderFromType$3(object) {
    const keyParams = {
        recordId: object.id
    };
    return keyBuilder$2(keyParams);
}
function dynamicNormalize(ingestParams) {
    return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_childRelationships = input.childRelationships;
        const input_childRelationships_id = path.fullPath + '__childRelationships';
        const input_childRelationships_keys = Object.keys(input_childRelationships);
        const input_childRelationships_length = input_childRelationships_keys.length;
        for (let i = 0; i < input_childRelationships_length; i++) {
            const key = input_childRelationships_keys[i];
            const input_childRelationships_prop = input_childRelationships[key];
            const input_childRelationships_prop_id = input_childRelationships_id + '__' + key;
            input_childRelationships[key] = ingestParams.childRelationships(input_childRelationships_prop, {
                fullPath: input_childRelationships_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
            const key = input_fields_keys[i];
            const input_fields_prop = input_fields[key];
            const input_fields_prop_id = input_fields_id + '__' + key;
            input_fields[key] = ingestParams.fields(input_fields_prop, {
                fullPath: input_fields_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        return input;
    };
}
const select$9 = function RecordRepresentationSelect() {
    const { selections: RecordTypeInfoRepresentation__selections, opaque: RecordTypeInfoRepresentation__opaque, } = select$6();
    return {
        kind: 'Fragment',
        private: [
            'eTag',
            'weakEtag'
        ],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'childRelationships',
                kind: 'Link',
                map: true,
                fragment: select$7()
            },
            {
                name: 'fields',
                kind: 'Link',
                map: true,
                fragment: select$8()
            },
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'lastModifiedById',
                kind: 'Scalar'
            },
            {
                name: 'lastModifiedDate',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeInfo',
                kind: 'Object',
                nullable: true,
                selections: RecordTypeInfoRepresentation__selections
            },
            {
                name: 'systemModstamp',
                kind: 'Scalar'
            }
        ]
    };
};
const dynamicSelect = function dynamicRecordRepresentationSelect(params) {
    const childRelationshipsPathSelection = params.childRelationships === undefined ? {
        name: 'childRelationships',
        kind: 'Link',
        map: true,
        fragment: select$7()
    } : params.childRelationships;
    const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$8()
    } : params.fields;
    const { selections: RecordTypeInfoRepresentation__selections, opaque: RecordTypeInfoRepresentation__opaque, } = select$6();
    return {
        kind: 'Fragment',
        private: [
            'eTag',
            'weakEtag'
        ],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            childRelationshipsPathSelection,
            fieldsPathSelection,
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'lastModifiedById',
                kind: 'Scalar'
            },
            {
                name: 'lastModifiedDate',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeInfo',
                kind: 'Object',
                nullable: true,
                selections: RecordTypeInfoRepresentation__selections
            },
            {
                name: 'systemModstamp',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$5(existing, incoming) {
    const existing_weakEtag = existing.weakEtag;
    const incoming_weakEtag = incoming.weakEtag;
    if (!(existing_weakEtag === incoming_weakEtag)) {
        return false;
    }
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_childRelationships = existing.childRelationships;
    const incoming_childRelationships = incoming.childRelationships;
    const equals_childRelationships_props = equalsObject(existing_childRelationships, incoming_childRelationships, (existing_childRelationships_prop, incoming_childRelationships_prop) => {
        if (!(existing_childRelationships_prop.__ref === incoming_childRelationships_prop.__ref)) {
            return false;
        }
    });
    if (equals_childRelationships_props === false) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_lastModifiedById = existing.lastModifiedById;
    const incoming_lastModifiedById = incoming.lastModifiedById;
    if (!(existing_lastModifiedById === incoming_lastModifiedById)) {
        return false;
    }
    const existing_lastModifiedDate = existing.lastModifiedDate;
    const incoming_lastModifiedDate = incoming.lastModifiedDate;
    if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    const existing_recordTypeInfo = existing.recordTypeInfo;
    const incoming_recordTypeInfo = incoming.recordTypeInfo;
    if (!(existing_recordTypeInfo === incoming_recordTypeInfo
        || (existing_recordTypeInfo != null &&
            incoming_recordTypeInfo != null &&
            equals$2(existing_recordTypeInfo, incoming_recordTypeInfo)))) {
        return false;
    }
    const existing_systemModstamp = existing.systemModstamp;
    const incoming_systemModstamp = incoming.systemModstamp;
    if (!(existing_systemModstamp === incoming_systemModstamp)) {
        return false;
    }
    return true;
}

const { assign, create, freeze, keys } = Object;
const { hasOwnProperty } = Object.prototype;
const { split, endsWith } = String.prototype;
const { isArray } = Array;
const { concat, filter, includes, push, reduce } = Array.prototype;

function isString(value) {
    return typeof value === 'string';
}
/**
 * @param value The array to inspect.
 * @returns True if the array is non-empty and contains only non-empty strings.
 */
function isArrayOfNonEmptyStrings(value) {
    if (value.length === 0) {
        return false;
    }
    return value.every((v) => isString(v) && v.trim().length > 0);
}
/**
 * @param value The array to dedupe
 * @returns An array without duplicates.
 */
function dedupe(value) {
    const result = {};
    for (let i = 0, len = value.length; i < len; i += 1) {
        result[value[i]] = true;
    }
    return keys(result);
}
/**
 * @param source The array of string to filter
 * @param compare The array to filter against
 * @returns An array with values from source that do not exist in compare
 * If the "compare" array is empty, "source" array itself is returned, not a shallow copy
 */
function difference(source, compare) {
    const { length: sourceLength } = source;
    const { length: compareLength } = compare;
    if (sourceLength === 0 || source === compare) {
        return [];
    }
    if (compareLength === 0) {
        return source;
    }
    // Put all the values from "compare" into a map
    // This should be faster than doing an indexOf for every string in source
    const map = {};
    for (let i = 0; i < compareLength; i += 1) {
        map[compare[i]] = true;
    }
    const strings = [];
    for (let i = 0; i < sourceLength; i += 1) {
        const string = source[i];
        if (map[string] === undefined) {
            strings.push(string);
        }
    }
    return strings;
}

function isFieldId(unknown) {
    if (typeof unknown !== 'object' || unknown === null) {
        return false;
    }
    const value = unknown;
    return isString(value.objectApiName) && isString(value.fieldApiName);
}
function stringToFieldId(fieldApiName) {
    const split = fieldApiName.split('.');
    if (process.env.NODE_ENV !== 'production') {
        if (split.length === 1) {
            // object api name must non-empty
            throw new TypeError('Value does not include an object API name.');
        }
    }
    return {
        objectApiName: split[0],
        fieldApiName: split[1],
    };
}
function getFieldId(value) {
    if (isFieldId(value)) {
        return value;
    }
    return stringToFieldId(value);
}
/**
 * Split the object API name and field API name from a qualified field name.
 * Eg: Opportunity.Title returns ['Opportunity', 'Title']
 * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
 * @param fieldApiName The qualified field name.
 * @return The object and field API names.
 */
function splitQualifiedFieldApiName(fieldApiName) {
    const idx = fieldApiName.indexOf('.');
    if (idx < 1) {
        // object api name must non-empty
        throw new TypeError('Value does not include an object API name.');
    }
    return [fieldApiName.substring(0, idx), fieldApiName.substring(idx + 1)];
}

/**
 * Returns the field API name, qualified with an object name if possible.
 * @param value The value from which to get the qualified field API name.
 * @return The qualified field API name.
 */
function getFieldApiName(value) {
    // Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if (isString(value)) {
        const trimmed = value.trim();
        if (trimmed.length > 0) {
            return trimmed;
        }
    }
    else if (isFieldId(value)) {
        return value.objectApiName + '.' + value.fieldApiName;
    }
    return undefined;
}

/**
 * The master record type id.
 */
const MASTER_RECORD_TYPE_ID = '012000000000000AAA';

/**
 * A set of the string names of known ui-api supported entities.
 *
 * Generated
 *     from: //app/main/core/ui-services-private/resources/module-config/ui-services-private-object-allow-list.yaml#99 (changelist 31715168)
 *     API version: 53
 *     at: Wed, 07 Apr 2021 17:26:54 GMT
 */
const UIAPI_SUPPORTED_ENTITY_API_NAMES = {
    Account: true,
    AccountBrand: true,
    AccountContactRelation: true,
    AccountForecast: true,
    AccountForecastAdjustment: true,
    AccountForecastPeriodMetric: true,
    AccountParticipant: true,
    AccountPartner: true,
    AccountProductForecast: true,
    AccountProductPeriodForecast: true,
    AccountRelationship: true,
    AccountTeamMember: true,
    Accreditation: true,
    AcctMgrPeriodicTargetDstr: true,
    AcctMgrTarget: true,
    AcctMgrTargetDstr: true,
    ActionCadence: true,
    ActionPlan: true,
    ActionPlanItem: true,
    ActionPlanItemDependency: true,
    ActionPlanTemplate: true,
    ActionPlanTemplateItem: true,
    ActionPlanTemplateItemValue: true,
    ActionPlanTemplateVersion: true,
    ActionPlanTmplItmAssessmentInd: true,
    ActionPlnTmplItmDependency: true,
    ActivationTarget: true,
    ActiveScratchOrg: true,
    AddOnDefinition: true,
    Address: true,
    AiDataset: true,
    AiImageDetectedObject: true,
    AiImageTrainingObject: true,
    AiVisionModel: true,
    AiVisionModelMetric: true,
    AiVisionModelObjectMetric: true,
    AiVisitRecommendRequest: true,
    AiVisitRecommendation: true,
    AiVisitTaskRcmd: true,
    AiVisitTaskRcmdRequest: true,
    AllergyIntolerance: true,
    AlternativePaymentMethod: true,
    ApiAnomalyEventStore: true,
    AppAnalyticsQueryRequest: true,
    AppExtension: true,
    AppMenuItem: true,
    AppUsageAssignment: true,
    ApplicationCase: true,
    AppointmentTopicTimeSlot: true,
    ApptBundleAggrDurDnscale: true,
    ApptBundleAggrPolicy: true,
    ApptBundleConfig: true,
    ApptBundlePolicy: true,
    ApptBundlePolicySvcTerr: true,
    ApptBundlePropagatePolicy: true,
    ApptBundleRestrictPolicy: true,
    ApptBundleSortPolicy: true,
    Assessment: true,
    AssessmentIndDefinedValue: true,
    AssessmentIndValue: true,
    AssessmentIndicatorDefinition: true,
    AssessmentQuestion: true,
    AssessmentQuestionResponse: true,
    AssessmentQuestionSet: true,
    AssessmentQuestionVersion: true,
    AssessmentTask: true,
    AssessmentTaskContentDocument: true,
    AssessmentTaskDefinition: true,
    AssessmentTaskIndDefinition: true,
    AssessmentTaskOrder: true,
    Asset: true,
    AssetAction: true,
    AssetActionSource: true,
    AssetDowntimePeriod: true,
    AssetRelationship: true,
    AssetStatePeriod: true,
    AssetWarranty: true,
    AssignedResource: true,
    AssociatedLocation: true,
    Assortment: true,
    AssortmentProduct: true,
    AttachedContentNote: true,
    AuthApplicationAsset: true,
    AuthApplicationPlace: true,
    AuthLocationAccessSchedule: true,
    AuthorizationForm: true,
    AuthorizationFormConsent: true,
    AuthorizationFormDataUse: true,
    AuthorizationFormText: true,
    AuthorizedInsuranceLine: true,
    Award: true,
    BCEntityPermission: true,
    BCEntityPermissionSet: true,
    BCFieldPermission: true,
    BCParticipant: true,
    BCParticipantAccess: true,
    BCPermissionSet: true,
    BCRecordAccess: true,
    BCRecordAccessApproval: true,
    BCRelatedParticipant: true,
    Banker: true,
    BatchJob: true,
    BatchJobPartFailedRecord: true,
    Benefit: true,
    BenefitParameterValue: true,
    BenefitType: true,
    BillingPolicy: true,
    BillingSchedule: true,
    BillingScheduleCreationStatus: true,
    BillingTreatment: true,
    BillingTreatmentItem: true,
    BlockchainAppMember: true,
    BlockchainApplication: true,
    BlockchainEntity: true,
    BlockchainField: true,
    BlockchainMember: true,
    BoardCertification: true,
    BranchUnit: true,
    BranchUnitBusinessMember: true,
    BranchUnitCustomer: true,
    BranchUnitRelatedRecord: true,
    BusRegAuthTypeDependency: true,
    BusRegAuthorizationType: true,
    BusinessHours: true,
    BusinessLicense: true,
    BusinessLicenseApplication: true,
    BusinessMilestone: true,
    BusinessProfile: true,
    BusinessType: true,
    BuyerAccount: true,
    CalculationMatrix: true,
    CalculationMatrixColumn: true,
    CalculationMatrixRow: true,
    CalculationMatrixVersion: true,
    CalculationProcedure: true,
    CalculationProcedureStep: true,
    CalculationProcedureVariable: true,
    CalculationProcedureVersion: true,
    Campaign: true,
    CampaignInsight: true,
    CampaignMember: true,
    CampaignMemberStatus: true,
    CardPaymentMethod: true,
    CareBarrier: true,
    CareBarrierDeterminant: true,
    CareBarrierType: true,
    CareDeterminant: true,
    CareDeterminantType: true,
    CareDiagnosis: true,
    CareInterventionType: true,
    CareMetricTarget: true,
    CareObservation: true,
    CareObservationComponent: true,
    CarePerformer: true,
    CarePgmProvHealthcareProvider: true,
    CarePractnFacilityAppt: true,
    CarePreauth: true,
    CarePreauthItem: true,
    CareProgram: true,
    CareProgramCampaign: true,
    CareProgramEligibilityRule: true,
    CareProgramEnrollee: true,
    CareProgramEnrolleeProduct: true,
    CareProgramEnrollmentCard: true,
    CareProgramGoal: true,
    CareProgramProduct: true,
    CareProgramProvider: true,
    CareProgramTeamMember: true,
    CareProviderAdverseAction: true,
    CareProviderFacilitySpecialty: true,
    CareProviderSearchableField: true,
    CareRegisteredDevice: true,
    CareRequest: true,
    CareRequestDrug: true,
    CareRequestExtension: true,
    CareRequestItem: true,
    CareRequestReviewer: true,
    CareSpecialty: true,
    CareSpecialtyTaxonomy: true,
    CareTaxonomy: true,
    CartItem: true,
    Case: true,
    CaseContactRole: true,
    CaseMilestone: true,
    ChannelObjectLinkingRule: true,
    ChannelProgram: true,
    ChannelProgramLevel: true,
    ChannelProgramMember: true,
    Claim: true,
    ClaimCase: true,
    ClaimCovPaymentAdjustment: true,
    ClaimCovReserveAdjustment: true,
    ClaimCoverage: true,
    ClaimCoveragePaymentDetail: true,
    ClaimCoverageReserveDetail: true,
    ClaimItem: true,
    ClaimParticipant: true,
    ClaimPaymentSummary: true,
    ClinicalAlert: true,
    ClinicalEncounter: true,
    ClinicalEncounterDiagnosis: true,
    ClinicalEncounterFacility: true,
    ClinicalEncounterIdentifier: true,
    ClinicalEncounterProvider: true,
    ClinicalEncounterReason: true,
    ClinicalEncounterSvcRequest: true,
    ClinicalServiceRequest: true,
    ClinicalServiceRequestDetail: true,
    CloudServiceProvider: true,
    CodeSet: true,
    CodeSetBundle: true,
    CommSubscription: true,
    CommSubscriptionChannelType: true,
    CommSubscriptionConsent: true,
    CommSubscriptionTiming: true,
    CommissionSchedule: true,
    CommissionScheduleAssignment: true,
    ComplaintCase: true,
    ConsentMetric: true,
    ConsentUsageMetric: true,
    ConsumptionRate: true,
    ConsumptionSchedule: true,
    Contact: true,
    ContactEncounter: true,
    ContactEncounterParticipant: true,
    ContactPointAddress: true,
    ContactPointConsent: true,
    ContactPointEmail: true,
    ContactPointPhone: true,
    ContactPointTypeConsent: true,
    ContactRequest: true,
    ContentDocument: true,
    ContentDocumentLink: true,
    ContentDocumentListViewMapping: true,
    ContentNote: true,
    ContentVersion: true,
    ContentWorkspace: true,
    Contract: true,
    ContractContactRole: true,
    ContractLineItem: true,
    ConversationBroadcast: true,
    ConversationBroadcastEntry: true,
    Coupon: true,
    CourseOffering: true,
    CoverageBenefit: true,
    CoverageBenefitItem: true,
    CoverageType: true,
    CredentialStuffingEventStore: true,
    CreditMemo: true,
    CreditMemoInvApplication: true,
    CreditMemoLine: true,
    Crisis: true,
    CustomerProperty: true,
    DandBCompany: true,
    DataConnectorS3: true,
    DataStream: true,
    DataUseLegalBasis: true,
    DataUsePurpose: true,
    DelegatedAccount: true,
    DeleteEvent: true,
    DeliveryTask: true,
    DiagnosticSummary: true,
    DigitalSignature: true,
    DigitalWallet: true,
    DistributorAuthorization: true,
    DocTemplateSectionCondition: true,
    DocumentChecklistItem: true,
    DocumentGenerationSetting: true,
    DocumentTemplate: true,
    DocumentTemplateClause: true,
    DocumentTemplateContentDoc: true,
    DocumentTemplateSection: true,
    DocumentTemplateToken: true,
    DsarPolicyLog: true,
    DuplicateRecordItem: true,
    DuplicateRecordSet: true,
    EditionDefinition: true,
    ElectronicMediaGroup: true,
    Employee: true,
    EmployeeAsset: true,
    EmployeeContact: true,
    EmployeeCrisisAssessment: true,
    EmployeeJob: true,
    EmployeeJobPosition: true,
    EmployeeOrganization: true,
    EngagementChannelType: true,
    EnhancedLetterhead: true,
    EnrolleeBenefit: true,
    EnrollmentEligibilityCriteria: true,
    Entitlement: true,
    EntityArchivingException: true,
    EntityArchivingJob: true,
    EntityArchivingSetup: true,
    EntityMilestone: true,
    EnvironmentHubMember: true,
    Examination: true,
    Expense: true,
    ExpenseReport: true,
    ExpenseReportEntry: true,
    ExternalAccountHierarchy: true,
    FieldServiceMobileExtension: true,
    FieldServiceMobileSettings: true,
    FieldServiceOrgSettings: true,
    FinanceBalanceSnapshot: true,
    FinanceBook: true,
    FinancePeriod: true,
    FinanceTransaction: true,
    FinancialDeal: true,
    FinancialDealParticipant: true,
    FinancialDealParty: true,
    FinancialDealProduct: true,
    FlowInterview: true,
    ForecastingOwnerAdjustment: true,
    FtestBigObjectLookup: true,
    FtestConcrete: true,
    FtestConcrete6: true,
    FtestConcrete7: true,
    FtestConcrete8: true,
    FtestZosUiPrototypeChild1: true,
    FtestZosUiPrototypeChild2: true,
    FtestZosUiPrototypeParent: true,
    GeneratedDocument: true,
    GeneratedDocumentSection: true,
    GoalLink: true,
    GuestBuyerProfile: true,
    HealthCareDiagnosis: true,
    HealthCareProcedure: true,
    HealthCondition: true,
    HealthcareFacility: true,
    HealthcareFacilityNetwork: true,
    HealthcarePayerNetwork: true,
    HealthcarePractitionerFacility: true,
    HealthcareProvider: true,
    HealthcareProviderNpi: true,
    HealthcareProviderSpecialty: true,
    HealthcareProviderTaxonomy: true,
    Holiday: true,
    IPAddressRange: true,
    Identifier: true,
    IdentityDocument: true,
    Image: true,
    InStoreLocation: true,
    IncludedLicenseDefinition: true,
    Individual: true,
    IndividualApplication: true,
    IndividualCrisisAssessment: true,
    InsightsExternalData: true,
    InsightsExternalDataPart: true,
    InspectionAssessmentInd: true,
    InspectionType: true,
    InsuranceClaimAsset: true,
    InsurancePolicy: true,
    InsurancePolicyAsset: true,
    InsurancePolicyCoverage: true,
    InsurancePolicyMemberAsset: true,
    InsurancePolicyParticipant: true,
    InsurancePolicySurcharge: true,
    InsurancePolicyTransaction: true,
    InsuranceProfile: true,
    Interaction: true,
    InteractionAttendee: true,
    InteractionParticipant: true,
    InteractionSummary: true,
    InteractionSummaryParticipant: true,
    InternalOrganizationUnit: true,
    Invoice: true,
    InvoiceAddressGroup: true,
    InvoiceLine: true,
    JobFamily: true,
    JobPosition: true,
    JobProfile: true,
    JournalSubType: true,
    JournalType: true,
    KnowledgeArticleVersion: true,
    Lead: true,
    LegalEntity: true,
    LicensingError: true,
    LicensingRequest: true,
    LicensingRequestOrderItem: true,
    ListEmail: true,
    LiveAgentSession: true,
    LiveChatSensitiveDataRule: true,
    LiveChatTranscript: true,
    LiveChatVisitor: true,
    LoanApplicant: true,
    LoanApplicantAddress: true,
    LoanApplicantAsset: true,
    LoanApplicantDeclaration: true,
    LoanApplicantEmployment: true,
    LoanApplicantIncome: true,
    LoanApplicantLiability: true,
    LoanApplicationAsset: true,
    LoanApplicationFinancial: true,
    LoanApplicationLiability: true,
    LoanApplicationProperty: true,
    LoanApplicationTitleHolder: true,
    LocWaitlistMsgTemplate: true,
    Location: true,
    LocationTrustMeasure: true,
    LocationWaitlist: true,
    LocationWaitlistedParty: true,
    LoyaltyLedger: true,
    LoyaltyPartnerProduct: true,
    LoyaltyProgram: true,
    LoyaltyProgramCurrency: true,
    LoyaltyProgramMbrPromotion: true,
    LoyaltyProgramMember: true,
    LoyaltyProgramMemberCase: true,
    LoyaltyProgramPartner: true,
    LoyaltyTier: true,
    LoyaltyTierBenefit: true,
    LoyaltyTierGroup: true,
    Macro: true,
    MaintenanceAsset: true,
    MaintenancePlan: true,
    MaintenanceWorkRule: true,
    MarketSegmentActivation: true,
    MarketingAction: true,
    MarketingResource: true,
    Medication: true,
    MedicationRequest: true,
    MedicationStatement: true,
    MemberBenefit: true,
    MemberPlan: true,
    MessagingChannel: true,
    MessagingDeliveryError: true,
    MessagingEndUser: true,
    MessagingSession: true,
    Metric: true,
    MktCalculatedInsight: true,
    MobileSettingsAssignment: true,
    MsgChannelLanguageKeyword: true,
    NamespaceRegistry: true,
    NetworkReferencedObject: true,
    Note: true,
    OcrDocumentScanResult: true,
    OmniDataPack: true,
    OmniDataTransform: true,
    OmniDataTransformItem: true,
    OmniESignatureTemplate: true,
    OmniProcess: true,
    OmniProcessCompilation: true,
    OmniProcessElement: true,
    OmniScriptSavedSession: true,
    OmniUiCard: true,
    OperatingHours: true,
    OperatingHoursHoliday: true,
    Opportunity: true,
    OpportunityContactRole: true,
    OpportunityHistory: true,
    OpportunityLineItem: true,
    OpportunityLineItemSchedule: true,
    OpportunityParticipant: true,
    OpportunityPartner: true,
    OpportunityTeamMember: true,
    Order: true,
    OrderAdjustmentGroup: true,
    OrderDeliveryGroup: true,
    OrderDeliveryMethod: true,
    OrderItem: true,
    OrderItemAdjustmentLineItem: true,
    OrderItemSummaryChange: true,
    OrderItemTaxLineItem: true,
    OrderSummary: true,
    OrgMetric: true,
    OrgMetricScanResult: true,
    OrgMetricScanSummary: true,
    OtherComponentTask: true,
    Partner: true,
    PartnerFundAllocation: true,
    PartnerFundClaim: true,
    PartnerFundRequest: true,
    PartnerMarketingBudget: true,
    PartyConsent: true,
    PartyIncome: true,
    PatientHealthReaction: true,
    PatientImmunization: true,
    PatientMedicalProcedure: true,
    PatientMedicalProcedureDetail: true,
    PatientMedicationDosage: true,
    PaymentApplicationMethod: true,
    PaymentAuthAdjustment: true,
    PaymentBatchRun: true,
    PaymentGateway: true,
    PaymentGatewayLog: true,
    PaymentLineInvoice: true,
    PaymentPolicy: true,
    PaymentSchedule: true,
    PaymentScheduleItem: true,
    PaymentTreatment: true,
    PersonAccount: true,
    PersonEducation: true,
    PersonEmployment: true,
    PersonExamination: true,
    PersonLanguage: true,
    PersonLifeEvent: true,
    PersonName: true,
    PgmRebateTypBnftMapping: true,
    PlanBenefit: true,
    PlanBenefitItem: true,
    PlatformLicenseDefinition: true,
    Polygon: true,
    PreliminaryApplicationRef: true,
    PriceAdjustmentSchedule: true,
    Pricebook2: true,
    PricebookEntry: true,
    ProcessDefinition: true,
    ProcessInstance: true,
    Producer: true,
    ProducerCommission: true,
    ProducerPolicyAssignment: true,
    Product2: true,
    Product2DataTranslation: true,
    ProductAttribute: true,
    ProductAttributeSet: true,
    ProductAttributeSetItem: true,
    ProductAttributeSetProduct: true,
    ProductAvailabilityProjection: true,
    ProductCatalog: true,
    ProductCategory: true,
    ProductCategoryDataTranslation: true,
    ProductCategoryMedia: true,
    ProductCategoryProduct: true,
    ProductConsumed: true,
    ProductConsumptionSchedule: true,
    ProductCoverage: true,
    ProductFulfillmentLocation: true,
    ProductItem: true,
    ProductItemTransaction: true,
    ProductLicenseMap: true,
    ProductMedia: true,
    ProductQuantityRule: true,
    ProductRequest: true,
    ProductRequestLineItem: true,
    ProductRequired: true,
    ProductSellingModel: true,
    ProductSellingModelOption: true,
    ProductServiceCampaign: true,
    ProductServiceCampaignItem: true,
    ProductTransfer: true,
    ProductWarrantyTerm: true,
    ProfileSkill: true,
    ProfileSkillEndorsement: true,
    ProfileSkillUser: true,
    ProgramRebateTypPayoutSrc: true,
    ProgramRebateType: true,
    ProgramRebateTypeBenefit: true,
    ProgramRebateTypeFilter: true,
    ProgramRebateTypePayout: true,
    Promotion: true,
    PromotionChannel: true,
    PromotionLoyaltyPtnrProdt: true,
    PromotionMarketSegment: true,
    PromotionProduct: true,
    PromotionProductCategory: true,
    PromotionQualifier: true,
    PromotionSegment: true,
    PromotionSegmentBuyerGroup: true,
    PromotionSegmentSalesStore: true,
    PromotionTarget: true,
    ProviderSearchSyncLog: true,
    ProvisioningRun: true,
    ProvisioningRunEvent: true,
    PublicComplaint: true,
    PublicProgram: true,
    PurchaseQuantityRule: true,
    PurchaserPlan: true,
    PurchaserPlanAssn: true,
    QuickText: true,
    Quote: true,
    QuoteDocument: true,
    QuoteLineItem: true,
    RebateMemberProductAggregate: true,
    RebatePayment: true,
    RebatePayoutAdjustment: true,
    RebateProgram: true,
    RebateProgramMember: true,
    RebateProgramMemberPayout: true,
    RebateProgramPayoutPeriod: true,
    ReceivedDocument: true,
    Recommendation: true,
    RecordAction: true,
    RecordType: true,
    RecordsetFilterCriteria: true,
    RecordsetFilterCriteriaRule: true,
    RefundLinePayment: true,
    RegAuthorizationTypeProduct: true,
    RegulatoryAuthority: true,
    RegulatoryAuthorizationType: true,
    RegulatoryCode: true,
    RegulatoryCodeAssessmentInd: true,
    RegulatoryCodeViolation: true,
    RegulatoryTrxnFee: true,
    RegulatoryTrxnFeeItem: true,
    ReplyText: true,
    ReportAnomalyEventStore: true,
    ResidentialLoanApplication: true,
    ResourceAbsence: true,
    ResourcePreference: true,
    RetailLocationGroup: true,
    RetailStore: true,
    RetailStoreGroupAssignment: true,
    RetailStoreKpi: true,
    RetailVisitKpi: true,
    ReturnOrder: true,
    ReturnOrderLineItem: true,
    RevRecogTreatmentItemGroup: true,
    RevenueDistributionMethod: true,
    RevenueElement: true,
    RevenueElementDistribution: true,
    RevenueRecogTreatmentItem: true,
    RevenueRecognitionPolicy: true,
    RevenueRecognitionTreatment: true,
    SalesAgreement: true,
    SalesAgreementProduct: true,
    SalesAgreementProductSchedule: true,
    SearchPromotionRule: true,
    SecuritiesHolding: true,
    SerializedProduct: true,
    ServiceAppointment: true,
    ServiceContract: true,
    ServiceCrew: true,
    ServiceCrewMember: true,
    ServiceReport: true,
    ServiceReportLayout: true,
    ServiceResource: true,
    ServiceResourceCapacity: true,
    ServiceResourceSkill: true,
    ServiceTerritory: true,
    ServiceTerritoryLocation: true,
    ServiceTerritoryMember: true,
    ServiceTerritoryWorkType: true,
    SessionHijackingEventStore: true,
    SettingUsageDefinition: true,
    SettingUsageMap: true,
    SetupAssistantStep: true,
    SharingRecordCollection: true,
    SharingRecordCollectionItem: true,
    Shift: true,
    ShiftPattern: true,
    ShiftPatternEntry: true,
    ShiftTemplate: true,
    Shipment: true,
    SignatureTask: true,
    SignatureTaskLineItem: true,
    SkillLevelDefinition: true,
    SkillRequirement: true,
    Snippet: true,
    SocialPersona: true,
    SocialPost: true,
    StandardPermissionSet: true,
    StaticResource: true,
    StoreActionPlanTemplate: true,
    StoreAssortment: true,
    StoreProduct: true,
    StreamingChannel: true,
    Survey: true,
    SurveyInvitation: true,
    SurveyQuestionResponse: true,
    SurveyResponse: true,
    SurveySubject: true,
    Swarm: true,
    SwarmMember: true,
    TaxCertificate: true,
    TaxEngine: true,
    TaxPolicy: true,
    TaxTreatment: true,
    Tenant: true,
    TenantParameterMap: true,
    ThreatDetectionFeedback: true,
    TimeSheet: true,
    TimeSheetEntry: true,
    TimeSlot: true,
    Topic: true,
    TrainingCourseParticipant: true,
    TransactionJournal: true,
    TravelMode: true,
    TrialEnvironmentSignup: true,
    TrnCourse: true,
    UnitOfMeasure: true,
    UnitOfMeasureConversion: true,
    UsageEntitlement: true,
    UsageEntitlementPeriod: true,
    UsageEntitlementUsage: true,
    UsageFactor: true,
    User: true,
    UserLicenseDefinition: true,
    VehicleUserAssignment: true,
    VideoCall: true,
    ViolationEnforcementAction: true,
    ViolationType: true,
    ViolationTypeAssessmentInd: true,
    Visit: true,
    VisitedParty: true,
    Visitor: true,
    VoiceCall: true,
    Voucher: true,
    VoucherDefinition: true,
    WarrantyTerm: true,
    WaveAutoInstallRequest: true,
    WebCart: true,
    WebStore: true,
    WebStoreBuyerGroup: true,
    WebStoreCatalog: true,
    WebStoreSearchProdSettings: true,
    WorkCoaching: true,
    WorkContract: true,
    WorkOrder: true,
    WorkOrderLineItem: true,
    WorkPlan: true,
    WorkPlanSelectionRule: true,
    WorkPlanTemplate: true,
    WorkPlanTemplateEntry: true,
    WorkRewardFund: true,
    WorkRewardFundType: true,
    WorkStep: true,
    WorkStepTemplate: true,
    WorkType: true,
    WorkTypeCodeSetBundle: true,
    WorkTypeGroup: true,
    WorkTypeGroupMember: true,
    WorkerCompCoverageClass: true,
};

const MAX_RECORD_DEPTH = 5;
const FIELD_SEPARATOR = '.';
const SCALAR_VALUE_SELECTION = {
    kind: 'Scalar',
    name: 'value',
};
const DISPLAY_VALUE_SELECTION = {
    kind: 'Scalar',
    name: 'displayValue',
};
const FIELDS_SELECTION = {
    kind: 'Object',
    name: 'fields',
};
function convertRecordFieldsArrayToTrie(fields, optionalFields = []) {
    const root = {
        name: '<root>',
        optional: false,
        scalar: false,
        children: {},
    };
    insertFieldsIntoTrie(root, fields, false);
    insertFieldsIntoTrie(root, optionalFields, true);
    return root;
}
function createPathSelection(propertyName, fieldDefinition) {
    const fieldsSelection = [];
    const { children } = fieldDefinition;
    const childrenKeys = keys(children);
    for (let i = 0, len = childrenKeys.length; i < len; i += 1) {
        const childKey = childrenKeys[i];
        const childFieldDefinition = children[childKey];
        let fieldValueSelection;
        if (childFieldDefinition.scalar === true) {
            fieldValueSelection = SCALAR_VALUE_SELECTION;
        }
        else {
            fieldValueSelection = {
                kind: 'Link',
                name: 'value',
                nullable: true,
                fragment: {
                    kind: 'Fragment',
                    private: ['eTag', 'weakEtag'],
                    selections: createRecordSelection(childFieldDefinition),
                },
            };
        }
        const fieldSelection = {
            kind: 'Link',
            name: childFieldDefinition.name,
            required: childFieldDefinition.optional === true ? false : undefined,
            fragment: {
                kind: 'Fragment',
                private: [],
                selections: [DISPLAY_VALUE_SELECTION, fieldValueSelection],
            },
        };
        push.call(fieldsSelection, fieldSelection);
    }
    return {
        kind: 'Object',
        name: propertyName,
        selections: fieldsSelection,
    };
}
/**
 * Convert a RecordRepresentationLike into its equivalent selection.
 */
function createPathSelectionFromValue(fields) {
    const fieldsSelection = [];
    const fieldNames = keys(fields);
    for (let i = 0, len = fieldNames.length; i < len; i++) {
        const fieldName = fieldNames[i];
        const { value: fieldValue } = fields[fieldName];
        let fieldValueSelection = SCALAR_VALUE_SELECTION;
        if (isSpanningRecord(fieldValue)) {
            fieldValueSelection = {
                kind: 'Link',
                name: 'value',
                nullable: true,
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: buildSelectionFromRecord(fieldValue),
                },
            };
        }
        const fieldSelection = {
            kind: 'Link',
            name: fieldName,
            required: undefined,
            fragment: {
                kind: 'Fragment',
                private: [],
                selections: [DISPLAY_VALUE_SELECTION, fieldValueSelection],
            },
        };
        push.call(fieldsSelection, fieldSelection);
    }
    return {
        kind: 'Object',
        name: FIELDS_SELECTION.name,
        selections: fieldsSelection,
    };
}
function extractRecordFieldsRecursively(record) {
    const fields = [];
    const fieldNames = keys(record.fields);
    for (let i = 0, len = fieldNames.length; i < len; i++) {
        const fieldName = fieldNames[i];
        const { value: fieldValue } = record.fields[fieldName];
        if (isSpanningRecord(fieldValue)) {
            const spanningRecordFields = extractRecordFieldsRecursively(fieldValue);
            for (let j = 0, len = spanningRecordFields.length; j < len; j++) {
                spanningRecordFields[j] = `${fieldName}.${spanningRecordFields[j]}`;
            }
            push.apply(fields, spanningRecordFields);
        }
        else {
            push.call(fields, fieldName);
        }
    }
    return fields;
}
/**
 * Returns a list of fields for a RecordRepresentationLike.
 *
 * TODO W-6900271 - Remove this function once getRelatedList don't depend on it anymore. Always prefer
 * generating a selection out of a record, than convert a record to a field list and back to a
 * selection.
 */
function extractFields(value) {
    const { apiName } = value;
    const fields = extractRecordFieldsRecursively(value);
    for (let i = 0, len = fields.length; i < len; i++) {
        fields[i] = `${apiName}.${fields[i]}`;
    }
    return fields;
}
function insertFieldsIntoTrie(root, fields, optional) {
    for (let i = 0, len = fields.length; i < len; i++) {
        const field = fields[i].split(FIELD_SEPARATOR);
        let current = root;
        for (let j = 1, len = field.length; j < len && j <= MAX_RECORD_DEPTH + 1; j++) {
            const fieldName = field[j];
            let next = current.children[fieldName];
            if (next === undefined) {
                // A field is scalar only if it is the last field name in the field.
                const scalar = j === len - 1;
                // LDS restricts the numbers of fields that can be traversed to MAX_RECORD_DEPTH,
                // however we still denormalize fields at MAX_RECORD_DEPTH + 1, only if they are
                // scalar fields.
                if (j <= MAX_RECORD_DEPTH || scalar === true) {
                    // We now know that there are children fields, so we can mark the parent
                    // as not a scalar
                    current.scalar = false;
                    next = {
                        name: fieldName,
                        scalar,
                        optional,
                        children: {},
                    };
                    current.children[fieldName] = next;
                }
            }
            current = next;
        }
    }
}

const CHILD_RELATIONSHIP_SELECTION = {
    // We don't support RecordRep.childRelationships because it has a nasty
    // degenerate case of multiple pages of child records
    kind: 'Object',
    name: 'childRelationships',
};
// This selection is a client-side only selection and will only
// be applied to a RecordRepresentation in environments configured with
// drafts when the record has draft changes applied to it
// TODO W-8237087 - explore if this selection can only be added in environments where drafts are enabled
const DRAFTS_SELECTION = {
    kind: 'Object',
    opaque: true,
    name: 'drafts',
    required: false,
};
function isSpanningRecord(fieldValue) {
    return fieldValue !== null && typeof fieldValue === 'object';
}
function createRecordSelection(fieldDefinition) {
    const sel = dynamicSelect({
        childRelationships: CHILD_RELATIONSHIP_SELECTION,
        fields: createPathSelection('fields', fieldDefinition),
    });
    return [...sel.selections, DRAFTS_SELECTION];
}
/**
 * Convert a list of fields and optional fields into RecordRepresentation its equivalent
 * selection.
 */
function buildSelectionFromFields(fields, optionalFields = []) {
    return createRecordSelection(convertRecordFieldsArrayToTrie(fields, optionalFields));
}
/**
 * Convert a RecordRepresentationLike into its equivalent selection.
 */
function buildSelectionFromRecord(record) {
    const sel = dynamicSelect({
        childRelationships: CHILD_RELATIONSHIP_SELECTION,
        fields: createPathSelectionFromValue(record.fields),
    });
    return [...sel.selections, DRAFTS_SELECTION];
}

const CUSTOM_API_NAME_SUFFIX = '__c';
const CUSTOM_EXTERNAL_OBJECT_FIELD_SUFFIX = '__x';
function isGraphNode(node) {
    return node !== null && node.type === 'Node';
}
function extractTrackedFieldsToTrie(recordId, node, root, visitedRecordIds = {}, depth = 0) {
    // Filter Error and null nodes
    if (!isGraphNode(node)) {
        return;
    }
    // Stop the traversal if the key has already been visited, since the fields for this record
    // have already been gathered at this point.
    if (hasOwnProperty.call(visitedRecordIds, recordId)) {
        return;
    }
    // The visitedRecordIds object passed to the spanning record is a copy of the original
    // visitedRecordIds + the current record id, since we want to detect circular references within
    // a given path.
    let spanningVisitedRecordIds = {
        ...visitedRecordIds,
        [recordId]: true,
    };
    const fields = node.object('fields');
    const keys$1 = fields.keys();
    let current = root;
    for (let i = 0, len = keys$1.length; i < len; i += 1) {
        const key = keys$1[i];
        const fieldValueRep = fields.link(key);
        let next = current.children[key];
        if (next === undefined) {
            next = {
                name: key,
                children: {},
            };
            if (fieldValueRep.isMissing()) {
                current.children[key] = next;
                continue;
            }
            const field = fieldValueRep.follow();
            // Filter Error and null nodes
            if (!isGraphNode(field)) {
                continue;
            }
            if (field.isScalar('value') === false) {
                if (depth + 1 > MAX_RECORD_DEPTH) {
                    continue;
                }
                const spanningLink = field.link('value');
                const spanning = spanningLink.follow();
                // W-8058425, do not include external lookups added by getTrackedFields
                if (isExternalLookupFieldKey(spanning)) {
                    continue;
                }
                extractTrackedFieldsToTrie(spanningLink.data.__ref, spanning, next, spanningVisitedRecordIds, depth + 1);
                if (keys(next.children).length > 0) {
                    current.children[key] = next;
                }
                else {
                    continue;
                }
            }
            else {
                // Skip the field, if its value is null at the max level depth.
                // Ideally, it should only skip relationship field. However,
                // on the client, there is not a reliable way to determine the
                // the field type.
                if (depth === MAX_RECORD_DEPTH && field.scalar('value') === null) {
                    continue;
                }
                const state = fieldValueRep.linkData();
                if (state !== undefined) {
                    const { fields } = state;
                    // W-8058425, do not include external lookups added by getTrackedFields
                    if (includes.call(fields, 'ExternalId')) {
                        continue;
                    }
                    for (let s = 0, len = fields.length; s < len; s += 1) {
                        const childFieldName = fields[s];
                        next.children[childFieldName] = {
                            name: childFieldName,
                            children: {},
                        };
                    }
                }
            }
            current.children[key] = next;
        }
    }
}
function isExternalLookupFieldKey(spanningNode) {
    // The only way to know if a record is an external lookup is to look into its fields
    // list and find an "ExternalId" field.
    // Filter Error and null nodes
    if (!isGraphNode(spanningNode) || !spanningNode.isScalar('apiName')) {
        return false;
    }
    return endsWith.call(spanningNode.scalar('apiName'), CUSTOM_EXTERNAL_OBJECT_FIELD_SUFFIX);
}
function convertTrieToFields(root) {
    if (keys(root.children).length === 0) {
        return [];
    }
    return convertTrieToFieldsRecursively(root);
}
function convertTrieToFieldsRecursively(root) {
    const childKeys = keys(root.children);
    if (childKeys.length === 0) {
        if (root.name === '') {
            return [];
        }
        return [root.name];
    }
    return reduce.call(childKeys, (acc, cur) => concat.call(acc, convertTrieToFieldsRecursively(root.children[cur]).map((i) => `${root.name}.${i}`)), []);
}
const BLANK_RECORD_FIELDS_TRIE = ObjectFreeze({
    name: '',
    children: {},
});
const convertFieldsToTrie = (fields = [], isOptional = false) => {
    if (fields.length === 0) {
        return BLANK_RECORD_FIELDS_TRIE;
    }
    const name = getObjectNameFromField(fields[0]);
    const fieldsTrie = {
        name,
        children: {},
        optional: isOptional,
    };
    insertFieldsIntoTrie(fieldsTrie, fields, isOptional);
    return fieldsTrie;
};
const getObjectNameFromField = (field) => {
    const fieldApiName = getFieldApiName(field);
    if (fieldApiName === undefined) {
        return '';
    }
    return splitQualifiedFieldApiName(fieldApiName)[0];
};
// merge all nodes in Trie B into Trie A
function mergeFieldsTries(rootA, rootB) {
    const rootAchildren = rootA.children;
    const rootBchildren = rootB.children;
    const childBKeys = keys(rootBchildren);
    for (let i = 0, len = childBKeys.length; i < len; i++) {
        const childBKey = childBKeys[i];
        if (rootAchildren[childBKey] === undefined) {
            rootAchildren[childBKey] = rootBchildren[childBKey];
        }
        else {
            mergeFieldsTries(rootAchildren[childBKey], rootBchildren[childBKey]);
        }
    }
}
function getTrackedFields(key, graphNode, fieldsFromConfig) {
    const fieldsList = fieldsFromConfig === undefined ? [] : [...fieldsFromConfig];
    if (!isGraphNode(graphNode)) {
        return fieldsList;
    }
    const name = graphNode.scalar('apiName');
    const root = {
        name,
        children: {},
    };
    extractTrackedFieldsToTrie(key, graphNode, root);
    const rootFromConfig = {
        name,
        children: {},
    };
    insertFieldsIntoTrie(rootFromConfig, fieldsList);
    mergeFieldsTries(root, rootFromConfig);
    return convertTrieToFields(root).sort();
}
/**
 * Returns a new object that has a list of fields that has been filtered by
 * edited fields. Only contains fields that have been edited from their original
 * values (excluding Id which is always copied over).
 * @param input The RecordInputRepresentation object to filter.
 * @param original The Record object that contains the original field values.
 * @returns RecordInputRepresentation, see the description
 */
function createRecordInputFilteredByEditedFields(input, original) {
    const filteredRecordInput = getRecordInput();
    // Always copy over any existing id.
    if (original.id) {
        filteredRecordInput.fields.Id = original.id;
    }
    const recordInputFields = input.fields;
    const originalRecordFields = original.fields;
    const recordInputFieldPropertyNames = keys(recordInputFields);
    for (let i = 0, len = recordInputFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordInputFieldPropertyNames[i];
        let originalRecordFieldsEntry;
        if (originalRecordFields) {
            originalRecordFieldsEntry = originalRecordFields[fieldName];
        }
        if (!originalRecordFieldsEntry ||
            (originalRecordFields &&
                recordInputFields[fieldName] !== originalRecordFieldsEntry.value)) {
            filteredRecordInput.fields[fieldName] = recordInputFields[fieldName];
        }
    }
    return filteredRecordInput;
}
/**
 * Returns an object with its data populated from the given record. All fields
 * with values that aren't nested records will be assigned. This object can be
 * used to create a record.
 * @param record The record that contains the source data.
 * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
 *        If provided, only fields that are createable=true (excluding Id) will
 *        be assigned to the object return value.
 * @returns RecordInputRepresentation See description.
 */
function generateRecordInputForCreate(record, objectInfo) {
    const recordInput = _generateRecordInput(record, (field) => field.createable === true, objectInfo);
    recordInput.apiName = record.apiName;
    // fields.Id is not required for CREATE which might have been copied over,
    // so delete fields.Id
    delete recordInput.fields.Id;
    return recordInput;
}
/**
 * Returns an object with its data populated from the given record. All fields
 * with values that aren't nested records will be assigned. This object can be
 * used to update a record.
 * @param record The record that contains the source data.
 * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
 *        If provided, only fields that are updateable=true (excluding Id) will
 *        be assigned to the object return value.
 * @returns RecordInputRepresentation See description.
 */
function generateRecordInputForUpdate(record, objectInfo) {
    const recordInput = _generateRecordInput(record, (field) => field.updateable === true, objectInfo);
    if (!record.id) {
        throw new Error('record must have id for update');
    }
    // Always copy over any existing id.
    recordInput.fields.Id = record.id;
    return recordInput;
}
function isRecordInputFieldValue(unknown) {
    const type = typeof unknown;
    return unknown === null || type === 'string' || type === 'number' || type === 'boolean';
}
/**
 * Returns an object with its data populated from the given record. All fields
 * with values that aren't nested records will be assigned.
 * @param record The record that contains the source data.
 * @param copyFieldPredicate predicate to determine if a field should be copied.
 *        Required if "objectInfo" parameter is passed.
 * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
 *        If provided, only fields that match the copyFieldPredicate (excluding
 *        Id) will be assigned to the object return value.
 * @returns RecordInputRepresentation
 */
function _generateRecordInput(record, copyFieldPredicate, objectInfo) {
    const recordInput = getRecordInput();
    const recordFields = record.fields;
    let objectInfoFields;
    if (objectInfo) {
        objectInfoFields = objectInfo.fields;
    }
    const recordFieldPropertyNames = keys(recordFields);
    for (let i = 0, len = recordFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordFieldPropertyNames[i];
        const recordFieldsFieldNameEntry = recordFields[fieldName].value;
        if (isRecordInputFieldValue(recordFieldsFieldNameEntry)) {
            if (objectInfoFields && copyFieldPredicate) {
                const objectInfoFieldsFieldNameValue = objectInfoFields[fieldName];
                if (objectInfoFieldsFieldNameValue &&
                    copyFieldPredicate(objectInfoFieldsFieldNameValue)) {
                    recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
                }
            }
            else {
                recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
            }
        }
    }
    return recordInput;
}
/**
 * Gets a new Record Input.
 */
function getRecordInput() {
    return {
        apiName: undefined,
        fields: {},
    };
}
/**
 * Gets a field's value from a record.
 * @param record The record.
 * @param field The qualified API name of the field to return.
 * @returns The field's value (which may be a record in the case of spanning
 *          fields), or undefined if the field isn't found.
 */
function getFieldValue(record, field) {
    const fieldValueRepresentation = getField(record, field);
    if (fieldValueRepresentation === undefined) {
        return undefined;
    }
    if (isFieldValueRepresentation(fieldValueRepresentation)) {
        return fieldValueRepresentation.value;
    }
    return fieldValueRepresentation;
}
/**
 * Gets a field's display value from a record.
 * @param record The record.
 * @param field The qualified API name of the field to return.
 * @returns The field's display value, or undefined if the field isn't found.
 */
function getFieldDisplayValue(record, field) {
    const fieldValueRepresentation = getField(record, field);
    if (fieldValueRepresentation === undefined) {
        return undefined;
    }
    if (isFieldValueRepresentation(fieldValueRepresentation)) {
        return fieldValueRepresentation.displayValue;
    }
    return fieldValueRepresentation;
}
function isFieldValueRepresentation(unknown) {
    if (typeof unknown !== 'object' || unknown === null) {
        return false;
    }
    return 'value' in unknown && 'displayValue' in unknown;
}
function getField(record, field) {
    const fieldApiName = getFieldApiName(field);
    if (fieldApiName === undefined) {
        return undefined;
    }
    const unqualifiedField = splitQualifiedFieldApiName(fieldApiName)[1];
    const fields = unqualifiedField.split('.');
    let r = record;
    while (r && r.fields) {
        const f = fields.shift();
        const fvr = r.fields[f];
        if (fvr === undefined) {
            return undefined;
        }
        else if (fields.length > 0) {
            r = fvr.value;
        }
        else {
            return fvr;
        }
    }
    return r;
}
function getRecordTypeId(record) {
    return record.recordTypeId === null ? MASTER_RECORD_TYPE_ID : record.recordTypeId;
}
// This function traverses through a record and marks missing
// optional fields as "missing"
function markMissingOptionalFields(record, optionalFields) {
    if (!isGraphNode(record)) {
        return;
    }
    const apiName = record.scalar('apiName');
    for (let a = 0, aLen = optionalFields.length; a < aLen; a++) {
        const parts = optionalFields[a].split('.');
        if (parts[0] === apiName) {
            _markMissingPath(record, parts.slice(1));
        }
    }
}
function markNulledOutPath(record, path) {
    if (!isGraphNode(record)) {
        return;
    }
    const fieldValueRepresentation = record.object('fields');
    const fieldName = path.shift();
    if (fieldValueRepresentation.isUndefined(fieldName)) {
        return;
    }
    const link = fieldValueRepresentation.link(fieldName);
    const resolved = link.follow();
    if (isGraphNode(resolved) && resolved.isScalar('value') && path.length > 0) {
        const linkState = link.linkData();
        const fields = linkState === undefined ? [] : linkState.fields;
        link.writeLinkData({
            fields: dedupe([...fields, path.join('.')]),
        });
    }
}
function markNulledOutRequiredFields(record, fields) {
    if (!isGraphNode(record)) {
        return;
    }
    const apiName = record.scalar('apiName');
    for (let a = 0, aLen = fields.length; a < aLen; a++) {
        const parts = fields[a].split('.');
        if (parts[0] === apiName) {
            markNulledOutPath(record, parts.slice(1));
        }
    }
}
function _markMissingPath(record, path) {
    // Filter out Error and null nodes
    if (!isGraphNode(record)) {
        return;
    }
    const fieldValueRepresentation = record.object('fields');
    const fieldName = path.shift();
    if (fieldValueRepresentation.isUndefined(fieldName) === true) {
        // TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
        // an undefined/non-present __ref if isMissing is present
        fieldValueRepresentation.write(fieldName, {
            __ref: undefined,
            isMissing: true,
        });
        return;
    }
    const link = fieldValueRepresentation.link(fieldName);
    if (link.isPending()) {
        // TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
        // an undefined/non-present __ref if isMissing is present
        fieldValueRepresentation.write(fieldName, {
            __ref: undefined,
            isMissing: true,
        });
    }
    else if (path.length > 0 && link.isMissing() === false) {
        const fieldValue = link.follow();
        // Filter out Error and null nodes
        if (!isGraphNode(fieldValue)) {
            return;
        }
        // if value is not a scalar, follow the link and mark it as missing
        if (fieldValue.isScalar('value') === false) {
            _markMissingPath(fieldValue
                .link('value')
                .follow(), path);
        }
    }
}
/**
 * Tells you if an objectApiName is supported by UI API or not.
 * Note: Luvio does not currently support all the entities, the list is limited to UI API supported entities
 * @param objectApiName the object API name from a record.
 * @return True if the provided objectApiName is supported in UI API.
 */
function isSupportedEntity(objectApiName) {
    return (UIAPI_SUPPORTED_ENTITY_API_NAMES[objectApiName] === true ||
        endsWith.call(objectApiName, CUSTOM_API_NAME_SUFFIX));
}
/** Return true if a >= b */
function isSuperset(a, b) {
    if (b.length > a.length) {
        return false;
    }
    const aMap = {};
    // Put all keys from subset into a map
    // so we don't have to use subset.includes which will be slow
    for (let i = 0, len = a.length; i < len; i += 1) {
        aMap[a[i]] = true;
    }
    for (let i = 0, len = b.length; i < len; i += 1) {
        if (aMap[b[i]] === undefined) {
            return false;
        }
    }
    return true;
}
/** return true if a and b start with the same root name and a contains all nodes in b */
function isSuperRecordFieldTrie(a, b) {
    if (a.name !== b.name) {
        return false;
    }
    const childrenA = a.children;
    const childrenB = b.children;
    const childKeysA = keys(childrenA);
    const childKeysB = keys(childrenB);
    const childKeysBLength = childKeysB.length;
    if (childKeysBLength > childKeysA.length) {
        return false;
    }
    let ret = true;
    for (let i = 0; i < childKeysBLength; i++) {
        const childBKey = childKeysB[i];
        const childA = childrenA[childBKey];
        if (childA === undefined) {
            return false;
        }
        ret = ret && isSuperRecordFieldTrie(childA, childrenB[childBKey]);
    }
    return ret;
}

function selectChildResourceParams(_luvio, childResources) {
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$5(childResource);
                const childSnapshot = reader.read(buildRecordSelector(childResource.urlParams.recordId, childResource.queryParams.fields || [], childResource.queryParams.optionalFields || []));
                const childSink = {};
                reader.seenIds[childKey] = true;
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshot.error.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.error.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        if (childSnapshot.data === undefined) {
                            reader.markMissingLink(childKey);
                        }
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        reader.seenIds[childKey] = true;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        },
    };
}

function ingestSuccessChildResourceParams(luvio, childResourceParamsArray, childEnvelopes) {
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    let snapshotState = 'Fulfilled';
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: 'OK',
                headers: undefined,
            };
            const childKey = keyBuilder$5(childResourceParams);
            const childTrackedFields = getTrackedFields(childKey, luvio.getNode(childKey), childResourceParams.queryParams.optionalFields);
            const childSnapshot = ingestSuccess(luvio, {
                recordId: childResourceParams.urlParams.recordId,
                fields: childResourceParams.queryParams.fields,
                optionalFields: childResourceParams.queryParams.optionalFields,
            }, childKey, childTrackedFields, childResponse);
            if (childSnapshot.state === 'Stale') {
                snapshotState = 'Stale';
            }
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else if (result.statusCode === 404) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childErrorSnapshot = ingestError$1(luvio, {
                recordId: childResourceParams.urlParams.recordId,
                fields: childResourceParams.queryParams.fields,
                optionalFields: childResourceParams.queryParams.optionalFields,
            }, keyBuilder$5(childResourceParams), childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$5(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childErrorSnapshot.error,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses,
    };
    return { childSnapshotData: ObjectFreeze(childSnapshotData), seenRecords, snapshotState };
}

const nonCachedErrors = ObjectCreate(null);
function keyBuilder$3(params) {
    return keyPrefix + 'BatchRepresentation(' + 'childRelationships:' + params.queryParams.childRelationships + ',' + 'fields:' + params.queryParams.fields + ',' + 'layoutTypes:' + params.queryParams.layoutTypes + ',' + 'modes:' + params.queryParams.modes + ',' + 'optionalFields:' + params.queryParams.optionalFields + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'updateMru:' + params.queryParams.updateMru + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
}
function ingestError(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$3(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/records/batch/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function createResourceParams(config) {
    const { records: configRecords } = config;
    const recordIds = [];
    const resourceConfigFields = [];
    const resourceConfigOptionalFields = [];
    for (let index = 0, len = configRecords.length; index < len; index += 1) {
        const { recordIds: recordIdsFromConfig, fields = [], optionalFields = [], } = configRecords[index];
        ArrayPrototypePush.call(recordIds, ...recordIdsFromConfig);
        if (fields.length > 0) {
            ArrayPrototypePush.call(resourceConfigFields, ...fields);
        }
        if (optionalFields.length > 0) {
            ArrayPrototypePush.call(resourceConfigOptionalFields, ...optionalFields);
        }
    }
    return {
        urlParams: {
            recordIds,
        },
        queryParams: {
            fields: resourceConfigFields.length > 0 ? resourceConfigFields : undefined,
            optionalFields: resourceConfigOptionalFields.length > 0 ? resourceConfigOptionalFields : undefined,
        },
    };
}

/**
 * Returns the field API name.
 * @param value The value from which to get the field API name.
 * @returns The field API name.
 */
function getFieldApiNamesArray(value) {
    const valueArray = isArray(value) ? value : [value];
    const array = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getFieldApiName(item);
        if (apiName === undefined) {
            return undefined;
        }
        push.call(array, apiName);
    }
    if (array.length === 0) {
        return undefined;
    }
    return dedupe(array).sort();
}

const RECORD_ID_DECODER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456';
/**
 * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
 * @param value A 15- or 18-char record id.
 * @returns An 18-char record id, and throws error if an invalid record id was provided.
 */
function getRecordId18(value) {
    if (!isString(value)) {
        return undefined;
    }
    else if (value.length === 18) {
        return value;
    }
    else if (value.length === 15) {
        // Add the 3 character suffix
        let recordId = value;
        for (let offset = 0; offset < 15; offset += 5) {
            let decodeValue = 0;
            for (let bit = 0; bit < 5; bit++) {
                const c = value[offset + bit];
                if (c >= 'A' && c <= 'Z') {
                    decodeValue += 1 << bit;
                }
            }
            recordId += RECORD_ID_DECODER[decodeValue];
        }
        return recordId;
    }
    return undefined;
}

function coerceRecordId18Array(value) {
    const valueArray = ArrayIsArray(value) ? value : [value];
    const ret = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const coerced = getRecordId18(item);
        if (coerced === undefined) {
            return undefined;
        }
        ArrayPrototypePush.call(ret, coerced);
    }
    if (ret.length === 0) {
        return undefined;
    }
    return dedupe(ret);
}
function coerceConfig(config) {
    const coercedRecordsConfig = { records: [] };
    const { records: recordsFromConfig = [] } = config;
    for (let index = 0, len = recordsFromConfig.length; index < len; index += 1) {
        const coeredRecordConfig = {};
        const currentRecordBatch = recordsFromConfig[index];
        if (untrustedIsObject(currentRecordBatch)) {
            const recordIds = coerceRecordId18Array(currentRecordBatch.recordIds);
            if (recordIds !== undefined) {
                coeredRecordConfig.recordIds = recordIds;
            }
            const optionalFields = getFieldApiNamesArray(currentRecordBatch.optionalFields);
            if (optionalFields !== undefined) {
                coeredRecordConfig.optionalFields = optionalFields;
            }
            const fields = getFieldApiNamesArray(currentRecordBatch.fields);
            if (fields !== undefined) {
                coeredRecordConfig.fields = fields;
            }
            ArrayPrototypePush.call(coercedRecordsConfig.records, coeredRecordConfig);
        }
    }
    return coercedRecordsConfig;
}
function typeCheckConfig(untrustedConfig) {
    const coercedConfig = coerceConfig(untrustedConfig);
    const config = {};
    const untrustedConfigs_records = coercedConfig.records;
    if (ArrayIsArray(untrustedConfigs_records)) {
        const records = [];
        for (let index = 0, len = untrustedConfigs_records.length; index < len; index += 1) {
            const output_recordEntityConfig = {};
            const untrustedConfig_recordEntity = untrustedConfigs_records[index];
            if (untrustedIsObject(untrustedConfig_recordEntity)) {
                const { recordIds: untrustedConfig_recordIds, fields: untrustedConfig_fields, optionalFields: untrustedConfig_optionalFields, } = untrustedConfig_recordEntity;
                if (ArrayIsArray(untrustedConfig_recordIds)) {
                    const untrustedConfig_recordIds_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
                        const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
                        if (typeof untrustedConfig_recordIds_item === 'string') {
                            ArrayPrototypePush.call(untrustedConfig_recordIds_array, untrustedConfig_recordIds_item);
                        }
                    }
                    output_recordEntityConfig.recordIds = untrustedConfig_recordIds_array;
                }
                if (!output_recordEntityConfig.recordIds ||
                    output_recordEntityConfig.recordIds.length === 0) {
                    continue;
                }
                if (ArrayIsArray(untrustedConfig_fields)) {
                    const untrustedConfig_fields_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
                        const untrustedConfig_fields_item = untrustedConfig_fields[i];
                        if (typeof untrustedConfig_fields_item === 'string') {
                            ArrayPrototypePush.call(untrustedConfig_fields_array, untrustedConfig_fields_item);
                        }
                    }
                    output_recordEntityConfig.fields = untrustedConfig_fields_array;
                }
                if (ArrayIsArray(untrustedConfig_optionalFields)) {
                    const untrustedConfig_optionalFields_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
                        const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
                        if (typeof untrustedConfig_optionalFields_item === 'string') {
                            ArrayPrototypePush.call(untrustedConfig_optionalFields_array, untrustedConfig_optionalFields_item);
                        }
                    }
                    output_recordEntityConfig.optionalFields = untrustedConfig_optionalFields_array;
                }
                if (output_recordEntityConfig.fields === undefined &&
                    output_recordEntityConfig.optionalFields === undefined) {
                    continue;
                }
                ArrayPrototypePush.call(records, output_recordEntityConfig);
            }
        }
        if (records.length > 0) {
            assign(config, { records });
        }
    }
    return config;
}

function createChildResourceParams(config) {
    const childResources = [];
    const { records } = config;
    for (let outerIdx = 0, numOfRecordBatches = records.length; outerIdx < numOfRecordBatches; outerIdx += 1) {
        const currentRecordBatch = records[outerIdx];
        const { recordIds, fields, optionalFields } = currentRecordBatch;
        for (let innerIdx = 0, numOfRecordIds = recordIds.length; innerIdx < numOfRecordIds; innerIdx += 1) {
            const currentRecordId = recordIds[innerIdx];
            const queryParams = {};
            if (ArrayIsArray(fields)) {
                queryParams.fields = fields;
            }
            if (ArrayIsArray(optionalFields)) {
                queryParams.optionalFields = optionalFields;
            }
            childResources.push({
                urlParams: {
                    recordId: currentRecordId,
                },
                queryParams,
            });
        }
    }
    return childResources;
}

function adapterFragment(luvio, config) {
    const childResources = createChildResourceParams(config);
    return selectChildResourceParams(luvio, childResources);
}

function onResourceResponseSuccess(luvio, config, resourceParams, response) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams(config);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' +
                childResourceParamsArray.length +
                ' items, received ' +
                childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$3(resourceParams);
    const { childSnapshotData, seenRecords } = ingestSuccessChildResourceParams(luvio, childResourceParamsArray, childEnvelopes);
    const snapshot = {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: adapterFragment(luvio, config),
            variables: {},
        },
        refresh: {
            config,
            resolve: () => buildNetworkSnapshot(luvio, config, snapshotRefreshOptions),
        },
        variables: {},
    };
    luvio.storeBroadcast();
    return snapshot;
}

const getRecords_ConfigPropertyNames = {
    displayName: 'getRecords',
    parameters: {
        required: ['records'],
        optional: [],
    },
};

function keyBuilder$4(luvio, config) {
    const resourceParams = createResourceParams(config);
    return keyBuilder$3(resourceParams);
}
function validateAdapterConfig(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot(luvio, config) {
    const selector = {
        recordId: keyBuilder$4(luvio, config),
        node: adapterFragment(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseError(luvio, config, resourceParams, response) {
    const snapshot = ingestError(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot(luvio, config, override) {
    const resourceParams = createResourceParams(config);
    const request = createResourceRequest(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot(luvio, config, snapshot) {
    const resourceParams = createResourceParams(config);
    const request = createResourceRequest(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError(luvio, config, resourceParams, response);
    });
}
const getRecordsAdapterFactory = (luvio) => function uiApi__getRecords(untrustedConfig) {
    const config = validateAdapterConfig(untrustedConfig, getRecords_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot(luvio, config);
};

// iterate through the map to build configs for network calls
function resolveConflict(luvio, map) {
    const ids = keys(map);
    if (ids.length === 0)
        return;
    if (ids.length === 1) {
        const recordId = ids[0];
        const config = {
            recordId,
            optionalFields: convertTrieToFields(map[recordId].trackedFields),
        };
        buildNetworkSnapshot$1(luvio, config);
    }
    else {
        const records = reduce.call(ids, (acc, id) => {
            const { trackedFields } = map[id];
            push.call(acc, {
                recordIds: [id],
                optionalFields: convertTrieToFields(trackedFields),
            });
            return acc;
        }, []);
        const config = { records };
        buildNetworkSnapshot(luvio, config);
    }
}

function createFieldsIngestSuccess(params) {
    const { fields, optionalFields, trackedFields } = params;
    const recordConflictMap = {};
    const ingest = createRecordIngest(fields, optionalFields, recordConflictMap);
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}

function fulfill(existing, incoming) {
    // early out if incoming isn't a request only for fields and optionalFields
    const { queryParams, headers, basePath, baseUri } = incoming;
    const { basePath: existingBasePath, baseUri: existingBaseUri, headers: existingHeaders, } = existing;
    const path = `${baseUri}${basePath}`;
    const existingPath = `${existingBasePath}${existingBaseUri}`;
    if (queryParams.layoutTypes !== undefined) {
        return false;
    }
    if (existingPath !== path) {
        return false;
    }
    const headersKeys = keys(headers);
    const headersKeyLength = headersKeys.length;
    if (headersKeyLength !== keys(existingHeaders).length) {
        return false;
    }
    for (let i = 0, len = headersKeyLength; i < len; i++) {
        let key = headersKeys[i];
        if (headers[key] !== existingHeaders[key]) {
            return false;
        }
    }
    // TODO W-6900100 - handle when incoming.fields are only in existing.optionalFields, and
    // existing's response doesn't include those fields. We need to detect this then
    // re-issue the request to get the relevant error response.
    const existingFieldsUnion = unionFields(existing.queryParams.fields, existing.queryParams.optionalFields);
    const incomingFieldsUnion = unionFields(queryParams.fields, queryParams.optionalFields);
    return isSuperset(existingFieldsUnion, incomingFieldsUnion);
}
function unionFields(fields, optionalFields) {
    const fieldsArray = isArray(fields) ? fields : [];
    const optionalFieldsArray = isArray(optionalFields) ? optionalFields : [];
    return [...fieldsArray, ...optionalFieldsArray];
}

const createResourceRequest$1 = function getUiApiRecordsByRecordIdCreateResourceRequest(config) {
    return {
        ...createResourceRequest$2(config),
        fulfill: fulfill,
    };
};

function keyBuilder$5(params) {
    return keyBuilder$2({
        recordId: params.urlParams.recordId
    });
}
function createResourceRequest$2(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function toSortedStringArray(value) {
    const valueArray = isArray(value) ? value : [value];
    if (valueArray.length !== 0 && isArrayOfNonEmptyStrings(valueArray)) {
        return dedupe(valueArray).sort();
    }
    return undefined;
}

const oneOfConfigPropertiesIdentifier = [
    'layoutTypes',
    'fields',
    'optionalFields'
];
function createResourceParams$1(config) {
    return {
        urlParams: {
            recordId: config.recordId
        },
        queryParams: {
            childRelationships: config.childRelationships, fields: config.fields, forms: config.forms, layoutTypes: config.layoutTypes, modes: config.modes, optionalFields: config.optionalFields, pageSize: config.pageSize, updateMru: config.updateMru
        }
    };
}
function coerceConfig$1(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    const childRelationships = config.childRelationships;
    if (childRelationships !== undefined) {
        coercedConfig.childRelationships = childRelationships;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const forms = config.forms;
    if (forms !== undefined) {
        coercedConfig.forms = forms;
    }
    const layoutTypes = toSortedStringArray(config.layoutTypes);
    if (layoutTypes !== undefined) {
        coercedConfig.layoutTypes = layoutTypes;
    }
    const modes = toSortedStringArray(config.modes);
    if (modes !== undefined) {
        coercedConfig.modes = modes;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const updateMru = config.updateMru;
    if (updateMru !== undefined) {
        coercedConfig.updateMru = updateMru;
    }
    return coercedConfig;
}
function typeCheckConfig$1(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_childRelationships = untrustedConfig.childRelationships;
    if (ArrayIsArray(untrustedConfig_childRelationships)) {
        const untrustedConfig_childRelationships_array = [];
        for (let i = 0, arrayLength = untrustedConfig_childRelationships.length; i < arrayLength; i++) {
            const untrustedConfig_childRelationships_item = untrustedConfig_childRelationships[i];
            if (typeof untrustedConfig_childRelationships_item === 'string') {
                untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);
            }
        }
        config.childRelationships = untrustedConfig_childRelationships_array;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_forms = untrustedConfig.forms;
    if (ArrayIsArray(untrustedConfig_forms)) {
        const untrustedConfig_forms_array = [];
        for (let i = 0, arrayLength = untrustedConfig_forms.length; i < arrayLength; i++) {
            const untrustedConfig_forms_item = untrustedConfig_forms[i];
            if (typeof untrustedConfig_forms_item === 'string') {
                untrustedConfig_forms_array.push(untrustedConfig_forms_item);
            }
        }
        config.forms = untrustedConfig_forms_array;
    }
    const untrustedConfig_layoutTypes = untrustedConfig.layoutTypes;
    if (ArrayIsArray(untrustedConfig_layoutTypes)) {
        const untrustedConfig_layoutTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_layoutTypes.length; i < arrayLength; i++) {
            const untrustedConfig_layoutTypes_item = untrustedConfig_layoutTypes[i];
            if (typeof untrustedConfig_layoutTypes_item === 'string') {
                untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);
            }
        }
        config.layoutTypes = untrustedConfig_layoutTypes_array;
    }
    const untrustedConfig_modes = untrustedConfig.modes;
    if (ArrayIsArray(untrustedConfig_modes)) {
        const untrustedConfig_modes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_modes.length; i < arrayLength; i++) {
            const untrustedConfig_modes_item = untrustedConfig_modes[i];
            if (typeof untrustedConfig_modes_item === 'string') {
                untrustedConfig_modes_array.push(untrustedConfig_modes_item);
            }
        }
        config.modes = untrustedConfig_modes_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_updateMru = untrustedConfig.updateMru;
    if (typeof untrustedConfig_updateMru === 'boolean') {
        config.updateMru = untrustedConfig_updateMru;
    }
    return config;
}
function validateAdapterConfig$1(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier);
    }
    const coercedConfig = coerceConfig$1(untrustedConfig);
    const config = typeCheckConfig$1(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    if (config.layoutTypes === undefined &&
        config.fields === undefined &&
        config.optionalFields === undefined) {
        return null;
    }
    return config;
}

function isFulfilledSnapshot(snapshot) {
    return snapshot.state === 'Fulfilled';
}
function isUnfulfilledSnapshot(snapshot) {
    return snapshot.state === 'Unfulfilled';
}
function isErrorSnapshot(snapshot) {
    return snapshot.state === 'Error';
}

// used by getUiApiRecordsBatchByRecordIds#selectChildResourceParams
function buildRecordSelector(recordId, fields, optionalFields) {
    return {
        recordId: keyBuilder$2({ recordId }),
        node: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: buildSelectionFromFields(fields, optionalFields),
        },
        variables: {},
    };
}
function buildSnapshotRefresh(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$1(luvio, config),
    };
}
function prepareRequest(luvio, config) {
    const { recordId, fields } = config;
    // Should this go into the coersion logic?
    const key = keyBuilder$5(createResourceParams$1(config));
    const allTrackedFields = getTrackedFields(key, luvio.getNode(key), config.optionalFields);
    const optionalFields = fields === undefined ? allTrackedFields : difference(allTrackedFields, fields);
    const params = createResourceParams$1({
        recordId,
        fields,
        optionalFields: optionalFields.length > 0 ? optionalFields : undefined,
    });
    const request = createResourceRequest$1(params);
    return { request, key, allTrackedFields };
}
function ingestSuccess(luvio, config, key, allTrackedFields, response) {
    const { body } = response;
    const fields = config.fields === undefined ? [] : config.fields;
    const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
    const fieldTrie = convertFieldsToTrie(fields, false);
    luvio.storeIngest(key, createFieldsIngestSuccess({
        fields: fieldTrie,
        optionalFields: convertFieldsToTrie(optionalFields, true),
        trackedFields: convertFieldsToTrie(allTrackedFields, true),
    }), body);
    return luvio.storeLookup(buildRecordSelector(config.recordId, fields, optionalFields), buildSnapshotRefresh(luvio, config));
}
function onResourceSuccess(luvio, config, key, allTrackedFields, response) {
    const snapshot = ingestSuccess(luvio, config, key, allTrackedFields, response);
    luvio.storeBroadcast();
    return snapshot;
}
function ingestError$1(luvio, config, key, err) {
    const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh(luvio, config));
    luvio.storeIngestError(key, errorSnapshot, TTL$1);
    return errorSnapshot;
}
function onResourceError(luvio, config, key, err) {
    const errorSnapshot = ingestError$1(luvio, config, key, err);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function buildNetworkSnapshot$1(luvio, config) {
    const { request, key, allTrackedFields } = prepareRequest(luvio, config);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResourceSuccess(luvio, config, key, allTrackedFields, response);
    }, (err) => {
        return onResourceError(luvio, config, key, err);
    });
}
function resolveUnfulfilledSnapshot$1(luvio, config, snapshot) {
    const { request, key, allTrackedFields } = prepareRequest(luvio, config);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot).then((response) => {
        return onResourceSuccess(luvio, config, key, allTrackedFields, response);
    }, (err) => {
        return onResourceError(luvio, config, key, err);
    });
}
// used by getRecordLayoutType#refresh
function buildInMemorySnapshot$1(luvio, config, refresh) {
    const fields = config.fields === undefined ? [] : config.fields;
    const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
    const sel = buildRecordSelector(config.recordId, fields, optionalFields);
    return luvio.storeLookup(sel, refresh ? refresh : buildSnapshotRefresh(luvio, config));
}
function getRecordByFields(luvio, config) {
    const snapshot = buildInMemorySnapshot$1(luvio, config);
    if (luvio.snapshotAvailable(snapshot)) {
        return snapshot;
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot$1(luvio, config, snapshot);
    }
    return buildNetworkSnapshot$1(luvio, config);
}

const INCOMING_WEAKETAG_0_KEY = 'incoming-weaketag-0';
const EXISTING_WEAKETAG_0_KEY = 'existing-weaketag-0';
const RECORD_API_NAME_CHANGE_EVENT = 'record-api-name-change-event';
// This function sets fields that we are refreshing to pending
// These values will go into the store
function mergePendingFields(newRecord, oldRecord) {
    // TODO W-6900046 - avoid casting to any by updating
    // RecordRepresentationNormalized['fields'] to include `pending:true` property
    const mergedFields = { ...newRecord.fields };
    const merged = { ...newRecord, fields: mergedFields };
    const existingFields = keys(oldRecord.fields);
    for (let i = 0, len = existingFields.length; i < len; i += 1) {
        const spanningFieldName = existingFields[i];
        if (newRecord.fields[spanningFieldName] === undefined) {
            // TODO W-6900046 - fix above casting issue so we're not stuffing arbitrary things
            // into RecordRepresentationNormalized['fields']
            mergedFields[spanningFieldName] = {
                __ref: undefined,
                pending: true,
            };
        }
    }
    return merged;
}
// This method gets called
// when incoming record has a higher version
// than the record that is currently in the store
function mergeAndRefreshHigherVersionRecord(luvio, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap) {
    // If the higher version (incoming) does not contain a superset of fields as existing
    // then we need to refresh to get updated versions of fields in existing
    if (isSuperRecordFieldTrie(incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot) ===
        false) {
        // If this is an unsupported entity, do NOT attempt to go to the network
        // Simply merge what we have and move on
        if (isSupportedEntity(incoming.apiName) === false) {
            return mergeRecordFields(incoming, existing);
        }
        if (recordConflictMap) {
            // update the conflict map to resolve the record conflict in resolveConflict
            recordConflictMap[incoming.id] = {
                recordId: incoming.id,
                trackedFields: existingTrackedFieldsTrieRoot,
            };
        }
        else {
            buildNetworkSnapshot$1(luvio, {
                recordId: incoming.id,
                optionalFields: convertTrieToFields(incomingTrackedFieldsTrieRoot),
            });
        }
        // We want to mark fields in the store as pending
        // Because we don't want to emit any data to components
        return mergePendingFields(incoming, existing);
    }
    return incoming;
}
// This method gets called
// when incoming record has a lower version
// than the record that is currently in the store
function mergeAndRefreshLowerVersionRecord(luvio, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap) {
    // If the higher version (existing) does not have a superset of fields as incoming
    // then we need to refresh to get updated versions of fields on incoming
    if (isSuperRecordFieldTrie(existingTrackedFieldsTrieRoot, incomingTrackedFieldsTrieRoot) ===
        false) {
        // If this is an unsupported entity, do NOT attempt to go to the network
        // Simply merge what we have and move on
        if (isSupportedEntity(incoming.apiName) === false) {
            return mergeRecordFields(existing, incoming);
        }
        const merged = mergePendingFields(existing, incoming);
        // update the conflict map to resolve the record conflict in resolveConflict
        if (recordConflictMap) {
            recordConflictMap[incoming.id] = {
                recordId: incoming.id,
                trackedFields: incomingTrackedFieldsTrieRoot,
            };
        }
        else {
            buildNetworkSnapshot$1(luvio, {
                recordId: incoming.id,
                optionalFields: convertTrieToFields(incomingTrackedFieldsTrieRoot),
            });
        }
        return merged;
    }
    return existing;
}
function mergeRecordConflict(luvio, incoming, existing, recordConflictMap) {
    const incomingNode = luvio.wrapNormalizedGraphNode(incoming);
    const existingNode = luvio.wrapNormalizedGraphNode(existing);
    const incomingTrackedFieldsTrieRoot = {
        name: incoming.apiName,
        children: {},
    };
    const existingTrackedFieldsTrieRoot = {
        name: existing.apiName,
        children: {},
    };
    const recordKey = keyBuilder$2({
        recordId: incoming.id,
    });
    extractTrackedFieldsToTrie(recordKey, incomingNode, incomingTrackedFieldsTrieRoot);
    extractTrackedFieldsToTrie(recordKey, existingNode, existingTrackedFieldsTrieRoot);
    if (incoming.weakEtag > existing.weakEtag) {
        return mergeAndRefreshHigherVersionRecord(luvio, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap);
    }
    return mergeAndRefreshLowerVersionRecord(luvio, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot, recordConflictMap);
}
function getNotNull(recordAValue, recordBValue) {
    return recordAValue === null ? recordBValue : recordAValue;
}
function mergeRecordFields(recordA, recordB) {
    const lastModifiedDate = getNotNull(recordA.lastModifiedDate, recordB.lastModifiedDate);
    const lastModifiedById = getNotNull(recordA.lastModifiedById, recordB.lastModifiedById);
    const systemModstamp = getNotNull(recordA.systemModstamp, recordB.systemModstamp);
    return {
        ...recordA,
        fields: {
            ...recordB.fields,
            ...recordA.fields,
        },
        lastModifiedDate,
        lastModifiedById,
        systemModstamp,
    };
}
function isErrorEntry(entry) {
    return entry.__type === 'error';
}
function merge(existing, incoming, luvio, _path, recordConflictMap) {
    if (existing === undefined || isErrorEntry(existing)) {
        return incoming;
    }
    // recordTypeId may get changed based on record state.
    // Evicts all dependencies from store.
    if (incoming.recordTypeId !== existing.recordTypeId) {
        const recordDepKey = depenpendencyKeyBuilder({ recordId: existing.id });
        const node = luvio.getNode(recordDepKey);
        if (isGraphNode(node)) {
            const dependencies = node.retrieve();
            if (dependencies !== null) {
                const depKeys = keys(dependencies);
                for (let i = 0, len = depKeys.length; i < len; i++) {
                    luvio.storeEvict(depKeys[i]);
                }
            }
        }
    }
    // TODO - handle merging of records that change apiName
    // if (existing.apiName !== incoming.apiName) {
    //     if (process.env.NODE_ENV === 'production') {
    //         lds.log(`API Name changed from ${existing.apiName} to ${incoming.apiName}`);
    //     } else {
    //         throw new Error('API Name cannot be different for merging records.');
    //     }
    // }
    // Adding instrumentation to see how frequently this occurs
    if (existing.apiName !== incoming.apiName) {
        const paramsBuilder = () => {
            return {
                [RECORD_API_NAME_CHANGE_EVENT]: true,
                existingApiName: existing.apiName,
                incomingApiName: incoming.apiName,
            };
        };
        luvio.instrument(paramsBuilder);
    }
    const incomingWeakEtag = incoming.weakEtag;
    const existingWeakEtag = existing.weakEtag;
    if (incomingWeakEtag === 0 || existingWeakEtag === 0) {
        const paramsBuilder = () => {
            return {
                [INCOMING_WEAKETAG_0_KEY]: incomingWeakEtag === 0,
                [EXISTING_WEAKETAG_0_KEY]: existingWeakEtag === 0,
                apiName: incoming.apiName,
            };
        };
        luvio.instrument(paramsBuilder);
    }
    // TODO W-6900085 - UIAPI returns weakEtag=0 when the record is >2 levels nested. For now
    // we treat the record as mergeable.
    if (incomingWeakEtag !== 0 && existingWeakEtag !== 0 && incomingWeakEtag !== existingWeakEtag) {
        return mergeRecordConflict(luvio, incoming, existing, recordConflictMap);
    }
    return mergeRecordFields(incoming, existing);
}
function depenpendencyKeyBuilder(config) {
    return `UiApi::RecordRepresentationDependency:${config.recordId}`;
}

function merge$1(existing, incoming, luvio, path) {
    if (existing === undefined) {
        return incoming;
    }
    // Temporary fix for the issue that non-null displayValue gets replaced by null in mistake. (W-8904195)
    // If displayValue and value are both null, it means the field is empty.
    //
    // Couple sources may emit incorrect null displayValue to LDS:
    //   1. ADS may receive records with incorrect null displayValue from RecordGvp and emit to LDS.
    //      This case may affect certain types of fields:
    //      a. Spanning record field.
    //      b. Formattable fields, such as date, currency.
    //   2. AggregateUi endpoint. For some fields, displayValue only gets populated when certain combination
    //      of fields are requested. Currently, LDS handles large record requests with aggregateUi endpoint.
    //      On the network layer, record fields get split into separate chunks. Potentially, when certain
    //      combination of fields gets split into separate chunks, it would result in displayValue getting set
    //      to null.
    //   3. Any resource that returns nested Records, like list-records and list-ui, potentially exhibits this behavior
    //
    // There might be more cases masked by this workaround. We need to be careful when removing this code.
    // It would be required to have some telemetries in prod to verify if any code hits this workaround.
    if (incoming.displayValue === null &&
        incoming.value !== null &&
        existing.displayValue !== null) {
        incoming.displayValue = existing.displayValue;
        // Temporary instrumentation to capture distribution and frequency, W-8990630
        luvio.instrument(() => {
            return {
                kind: 'interaction',
                target: 'merge',
                scope: 'lds-adapters-uiapi',
                context: {
                    entityName: path.parent.data.apiName,
                    fieldName: path.propertyName,
                },
                eventSource: 'lds-dv-bandaid',
                eventType: 'system',
                attributes: null,
            };
        });
    }
    const { value } = incoming;
    if (value === null || value.__ref === undefined) {
        // Parent will never be null this field only exists in the context of a RecordRep.
        const parent = path.parent;
        // It may happen that a parent.exists is null, this is the case when the same field is
        // ingested multiple times in the same ingestion cycle. For example: when the same record
        // is present multiple time in the ingested payload.
        if (parent.existing === undefined) {
            return incoming;
        }
        const existingVersion = parent.existing.weakEtag;
        const incomingVersion = parent.data.weakEtag;
        if (existingVersion > incomingVersion) {
            return existing;
        }
    }
    return incoming;
}

function normalize$4(input, existing, path, luvio, store, timestamp, fieldsTrie, optionalFieldsTrie, recordConflictMap) {
    const input_value = input.value;
    const input_value_id = path.fullPath + '__value';
    if (input_value !== null && typeof input_value === 'object') {
        const ingest = createRecordIngest(fieldsTrie, optionalFieldsTrie, recordConflictMap);
        input.value = ingest(input_value, {
            fullPath: input_value_id,
            propertyName: 'value',
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            },
        }, luvio, store, timestamp);
    }
    return input;
}

function makeIngest(fieldsTrie, optionalFieldsTrie, recordConflictMap) {
    return (input, path, luvio, store, timestamp) => {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$8(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = path.fullPath;
        let incomingRecord = normalize$4(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        }, luvio, store, timestamp, fieldsTrie, optionalFieldsTrie, recordConflictMap);
        const existingRecord = store.records[key];
        incomingRecord = merge$1(existingRecord, incomingRecord, luvio, path);
        if (existingRecord === undefined || equals$4(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        return createLink(key);
    };
}

/**
 * Adds fields listed in the two trie parameters into the store link.
 * Functionally analogous to markNulledOutRequiredFields.
 * @param fieldsTrie
 * @param optionalFieldsTrie
 * @param storeLink
 */
function addFieldsToStoreLink(fieldsTrie, optionalFieldsTrie, storeLink) {
    let fields = [];
    const fieldSubtries = [];
    if (fieldsTrie) {
        push.call(fieldSubtries, fieldsTrie);
    }
    if (optionalFieldsTrie) {
        push.call(fieldSubtries, optionalFieldsTrie);
    }
    for (let i = 0; i < fieldSubtries.length; i++) {
        const subtrie = fieldSubtries[i];
        const fieldNames = keys(subtrie.children);
        for (let i = 0; i < fieldNames.length; i++) {
            const fieldName = fieldNames[i];
            const childTrie = subtrie.children[fieldName];
            if (childTrie) {
                fields = [...fields, ...convertTrieToFieldsRecursively(childTrie)];
            }
        }
    }
    fields = dedupe(fields);
    if (fields.length > 0) {
        storeLink.data = {
            fields,
        };
    }
}

function getChildRecordFieldTrie(parent, key) {
    const value = parent.children[key];
    if (value === undefined) {
        return BLANK_RECORD_FIELDS_TRIE;
    }
    return value;
}
function createFieldsIngestion(fieldsTrie, optionalFieldsTrie, recordConflictMap) {
    return (data, path, luvio, store, timestamp) => {
        if (process.env.NODE_ENV !== 'production') {
            if (typeof path.propertyName !== 'string') {
                throw new Error('FieldValueRepresentation should always have a string propertyName value');
            }
        }
        const key = path.propertyName;
        const fieldsSubtrie = getChildRecordFieldTrie(fieldsTrie, key);
        const optionalFieldsSubtrie = getChildRecordFieldTrie(optionalFieldsTrie, key);
        const fieldValueLink = makeIngest(fieldsSubtrie, optionalFieldsSubtrie, recordConflictMap)(data, path, luvio, store, timestamp);
        // If a relationship field is null, memorize names of subordinate fields.
        // Spannning fields are specified in the dot notation.
        if (data.value === null) {
            addFieldsToStoreLink(fieldsSubtrie, optionalFieldsSubtrie, fieldValueLink);
        }
        return fieldValueLink;
    };
}
function createChildRecordNormalize(fieldsTrie, optionalFieldsTrie, recordConflictMap) {
    return dynamicNormalize({
        childRelationships: ingest$2,
        fields: createFieldsIngestion(fieldsTrie, optionalFieldsTrie, recordConflictMap),
    });
}
const createRecordIngest = (fieldsTrie, optionalFieldsTrie, recordConflictMap) => {
    const childNormalize = createChildRecordNormalize(fieldsTrie, optionalFieldsTrie, recordConflictMap || {});
    return (input, path, luvio, store, timestamp) => {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$9(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = keyBuilderFromType$2(input);
        const recordPath = {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        };
        let incomingRecord = childNormalize(input, store.records[key], recordPath, luvio, store, timestamp);
        const existingRecord = store.records[key];
        incomingRecord = merge(existingRecord, incomingRecord, luvio, path, recordConflictMap);
        if (existingRecord === undefined || equals$5(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        luvio.storeSetExpiration(key, timestamp + 30000);
        return createLink(key);
    };
};

const ingest$4 = createRecordIngest(BLANK_RECORD_FIELDS_TRIE, BLANK_RECORD_FIELDS_TRIE);

function validate$a(obj, path = 'ListRecordCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray$1(obj_fields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
            const obj_fields_item = obj_fields[i];
            const path_fields_item = path_fields + '[' + i + ']';
            if (typeof obj_fields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
            }
        }
        const obj_listInfoETag = obj.listInfoETag;
        const path_listInfoETag = path + '.listInfoETag';
        if (typeof obj_listInfoETag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        if (typeof obj_listReference !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_listReference + '" (at "' + path_listReference + '")');
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray$1(obj_optionalFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
            const obj_optionalFields_item = obj_optionalFields[i];
            const path_optionalFields_item = path_optionalFields + '[' + i + ']';
            if (typeof obj_optionalFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
            }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || (typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray$1(obj_records)) {
            return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
            const obj_records_item = obj_records[i];
            const path_records_item = path_records + '[' + i + ']';
            if (typeof obj_records_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
            }
        }
        const obj_sortBy = obj.sortBy;
        const path_sortBy = path + '.sortBy';
        let obj_sortBy_union0 = null;
        const obj_sortBy_union0_error = (() => {
            if (!ArrayIsArray$1(obj_sortBy)) {
                return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
            }
            for (let i = 0; i < obj_sortBy.length; i++) {
                const obj_sortBy_item = obj_sortBy[i];
                const path_sortBy_item = path_sortBy + '[' + i + ']';
                if (typeof obj_sortBy_item !== 'string') {
                    return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
                }
            }
        })();
        if (obj_sortBy_union0_error != null) {
            obj_sortBy_union0 = obj_sortBy_union0_error.message;
        }
        let obj_sortBy_union1 = null;
        const obj_sortBy_union1_error = (() => {
            if (obj_sortBy !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
            }
        })();
        if (obj_sortBy_union1_error != null) {
            obj_sortBy_union1 = obj_sortBy_union1_error.message;
        }
        if (obj_sortBy_union0 && obj_sortBy_union1) {
            let message = 'Object doesn\'t match union (at "' + path_sortBy + '")';
            message += '\n' + obj_sortBy_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_sortBy_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$6(config) {
    return keyPrefix + 'ListRecordCollectionRepresentation:' + config.listViewId + ':' + (config.sortBy === null ? '' : '[' + config.sortBy.join(',') + ']');
}
function keyBuilderFromType$4(object) {
    const keyParams = {
        listViewId: object.listInfoETag,
        sortBy: object.sortBy
    };
    return keyBuilder$6(keyParams);
}
function paginationKeyBuilder(config) {
    return keyBuilder$6(config) + '__pagination';
}
function normalize$5(input, existing, path, luvio, store, timestamp) {
    const input_listReference = input.listReference;
    const input_listReference_id = path.fullPath + '__listReference';
    input.listReference = ingest(input_listReference, {
        fullPath: input_listReference_id,
        propertyName: 'listReference',
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, luvio, store);
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$4(input_records_item, {
            fullPath: input_records_item_id,
            propertyName: i,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
function equals$6(existing, incoming) {
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_pageSize = existing.pageSize;
    const incoming_pageSize = incoming.pageSize;
    if (!(existing_pageSize === incoming_pageSize)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_listInfoETag = existing.listInfoETag;
    const incoming_listInfoETag = incoming.listInfoETag;
    if (!(existing_listInfoETag === incoming_listInfoETag)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_items = equalsArray(existing_fields, incoming_fields, (existing_fields_item, incoming_fields_item) => {
        if (!(existing_fields_item === incoming_fields_item)) {
            return false;
        }
    });
    if (equals_fields_items === false) {
        return false;
    }
    const existing_listReference = existing.listReference;
    const incoming_listReference = incoming.listReference;
    if (!(existing_listReference.__ref === incoming_listReference.__ref)) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_optionalFields = existing.optionalFields;
    const incoming_optionalFields = incoming.optionalFields;
    const equals_optionalFields_items = equalsArray(existing_optionalFields, incoming_optionalFields, (existing_optionalFields_item, incoming_optionalFields_item) => {
        if (!(existing_optionalFields_item === incoming_optionalFields_item)) {
            return false;
        }
    });
    if (equals_optionalFields_items === false) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
            return false;
        }
    });
    if (equals_records_items === false) {
        return false;
    }
    const existing_sortBy = existing.sortBy;
    const incoming_sortBy = incoming.sortBy;
    if (!((() => {
        if (existing_sortBy === null || incoming_sortBy === null) {
            return existing_sortBy === incoming_sortBy;
        }
        const equals_sortBy_items = equalsArray(existing_sortBy, incoming_sortBy, (existing_sortBy_item, incoming_sortBy_item) => {
            if (!(existing_sortBy_item === incoming_sortBy_item)) {
                return false;
            }
        });
        if (equals_sortBy_items === false) {
            return false;
        }
    })())) {
        return false;
    }
    return true;
}
const ingest$5 = function ListRecordCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$a(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$4(input);
    let incomingRecord = normalize$5(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    const paginationKey = paginationKeyBuilder({
        listViewId: input.listInfoETag,
        sortBy: input.sortBy,
    });
    const { isPastEnd, offsetFor, save, setEnd, setToken } = luvio.pagination(paginationKey);
    const currentOffset = offsetFor(input.currentPageToken);
    if (process.env.NODE_ENV !== 'production') {
        if (currentOffset === undefined ||
            (existingRecord &&
                existingRecord.records.length < currentOffset)) {
            throw new RangeError("currentPageToken value " + input.currentPageToken + " not recognized");
        }
    }
    const nextOffset = currentOffset + input.count;
    if (input.nextPageToken) {
        setToken(input.nextPageToken, nextOffset);
        if (isPastEnd(nextOffset)) {
            setEnd(undefined);
        }
    }
    else {
        setEnd(nextOffset);
    }
    if (input.previousPageToken) {
        // TODO - need request's pageSize to ingest previousPageToken at end of list
        if (input.nextPageToken) {
            setToken(input.previousPageToken, currentOffset - input.count);
        }
    }
    save();
    if (existingRecord) {
        incomingRecord.currentPageUrl = existingRecord.currentPageUrl;
        // TODO: needs optimization
        incomingRecord.records = [
            ...existingRecord.records.slice(0, currentOffset),
            ...incomingRecord.records,
            ...(input.nextPageToken ?
                existingRecord.records.slice(nextOffset) :
                []),
        ];
    }
    if (existingRecord === undefined || equals$6(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$b(obj, path = 'ListUiRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_info = obj.info;
        const path_info = path + '.info';
        if (typeof obj_info !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_info + '" (at "' + path_info + '")');
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$7(config) {
    return keyPrefix + 'ListUiRepresentation:' + (config.listViewApiName === null ? '' : config.listViewApiName) + ':' + config.objectApiName + ':' + config.type + ':' + (config.sortBy === null ? '' : '[' + config.sortBy.join(',') + ']');
}
function keyBuilderFromType$5(object) {
    const keyParams = {
        listViewApiName: object.info.listReference.listViewApiName,
        objectApiName: object.info.listReference.objectApiName,
        type: object.info.listReference.type,
        sortBy: object.records.sortBy
    };
    return keyBuilder$7(keyParams);
}
function normalize$6(input, existing, path, luvio, store, timestamp) {
    const input_info = input.info;
    const input_info_id = path.fullPath + '__info';
    input.info = ingest$1(input_info, {
        fullPath: input_info_id,
        propertyName: 'info',
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, luvio, store, timestamp);
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    input.records = ingest$5(input_records, {
        fullPath: input_records_id,
        propertyName: 'records',
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, luvio, store, timestamp);
    return input;
}
function equals$7(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_info = existing.info;
    const incoming_info = incoming.info;
    if (!(existing_info.__ref === incoming_info.__ref)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    if (!(existing_records.__ref === incoming_records.__ref)) {
        return false;
    }
    return true;
}
const ingest$6 = function ListUiRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$b(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$5(input);
    let incomingRecord = normalize$6(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$7(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};
function createResourceRequest$3(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function isObjectId(unknown) {
    if (typeof unknown !== 'object' || unknown === null) {
        return false;
    }
    return isString(unknown.objectApiName);
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getObjectApiName(value) {
    // Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed.length > 0) {
            return trimmed;
        }
    }
    else if (isObjectId(value)) {
        return value.objectApiName.trim();
    }
    return undefined;
}

const getListUiByApiName_ConfigPropertyNames = {
    displayName: 'getListUiByApiName',
    parameters: {
        required: ['listViewApiName', 'objectApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function coerceConfig$2(config) {
    const coercedConfig = {};
    const listViewApiName = config.listViewApiName;
    if (listViewApiName !== undefined) {
        coercedConfig.listViewApiName = listViewApiName;
    }
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const sortBy = getFieldApiNamesArray(config.sortBy);
    if (sortBy !== undefined) {
        coercedConfig.sortBy = sortBy;
    }
    return coercedConfig;
}
function typeCheckConfig$2(untrustedConfig) {
    const config = {};
    const untrustedConfig_listViewApiName = untrustedConfig.listViewApiName;
    if (typeof untrustedConfig_listViewApiName === 'string') {
        config.listViewApiName = untrustedConfig_listViewApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$2(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$2(untrustedConfig);
    const config = typeCheckConfig$2(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function createResourceRequest$4(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.listViewId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getListUiByListViewId_ConfigPropertyNames = {
    displayName: 'getListUiByListViewId',
    parameters: {
        required: ['listViewId'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function coerceConfig$3(config) {
    const coercedConfig = {};
    const listViewId = config.listViewId;
    if (listViewId !== undefined) {
        coercedConfig.listViewId = listViewId;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const sortBy = getFieldApiNamesArray(config.sortBy);
    if (sortBy !== undefined) {
        coercedConfig.sortBy = sortBy;
    }
    return coercedConfig;
}
function typeCheckConfig$3(untrustedConfig) {
    const config = {};
    const untrustedConfig_listViewId = untrustedConfig.listViewId;
    if (typeof untrustedConfig_listViewId === 'string') {
        config.listViewId = untrustedConfig_listViewId;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$3(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$3(untrustedConfig);
    const config = typeCheckConfig$3(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function createResourceRequest$5(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/list-records/' + config.urlParams.listViewId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function createResourceRequest$6(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/list-records/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function buildListRefByIdContextKey(listViewId) {
    return `listReferenceById::${listViewId}`;
}
function buildListRefByApiNameContextKey(objectApiName, listViewApiName) {
    return `listReferenceByApiName::${objectApiName}:${listViewApiName}`;
}
/**
 * Adds a list reference so it can be retrieved with #getListReference later.
 *
 * @param listRef list reference
 */
function addListReference(listRef, context) {
    if (listRef.id) {
        context.set(buildListRefByIdContextKey(listRef.id), listRef);
    }
    context.set(buildListRefByApiNameContextKey(listRef.objectApiName, listRef.listViewApiName || ''), listRef);
}
/**
 * Returns a list reference from the store if it's present.
 *
 * @param query list view to look for
 * @param luvio Luvio
 */
function getListReference(query, context) {
    return query.listViewId
        ? context.get(buildListRefByIdContextKey(query.listViewId))
        : context.get(buildListRefByApiNameContextKey(query.objectApiName || '', query.listViewApiName || ''));
}
/**
 * Reader selections to copy a list info
 */
const LIST_INFO_SELECTIONS = select$5().selections;
/**
 * List info private memebers
 */
const LIST_INFO_PRIVATES = select$5().private;
const LIST_INFO_SELECTIONS_ETAG = [
    ...LIST_INFO_SELECTIONS,
    { kind: 'Scalar', name: 'eTag' },
];
/**
 * Retrieves the snapshot of the list info corresponding to the specified list
 * reference from the store.
 *
 * @param listRef list reference
 * @param luvio Luvio
 */
function getListInfo(listRef, luvio, 
// TODO - W-9051409 - today makeDurable environment needs a refresh set for
// "resolveUnfulfilledSnapshot" override to work properly, but once this work
// item is done we won't have "resolveUnfulfilledSnapshot" anymore and this
// "refresh" parameter can go away
refresh) {
    const key = keyBuilder$1(listRef);
    return luvio.storeLookup({
        recordId: key,
        node: { kind: 'Fragment', selections: LIST_INFO_SELECTIONS_ETAG, private: [] },
        variables: {},
    }, refresh);
}
function buildDefaultsKey(listRef) {
    const { objectApiName, listViewApiName } = listRef;
    return `defaults::${objectApiName}:${listViewApiName}`;
}
/**
 * Update the default values based on a server response.
 *
 * @param config getListUi config
 * @param serverResponse ListUiRepresentation from the server
 */
function addServerDefaults(config, serverResponse, context) {
    const { records: { sortBy }, info: { listReference }, } = serverResponse;
    if (config.sortBy !== undefined || sortBy === null) {
        return;
    }
    const key = buildDefaultsKey(listReference);
    const currentDefaults = context.get(key) || {};
    context.set(key, { ...currentDefaults, sortBy });
}
/**
 * Returns default values observed on previous requests for a list.
 *
 * @param config getListUi config
 * @returns defaults from previous requests for this list, or {} if no defaults are known
 */
function getServerDefaults(config, context) {
    const listRef = getListReference(config, context);
    if (listRef === undefined) {
        return {};
    }
    const key = buildDefaultsKey(listRef);
    return context.get(key) || {};
}
// Logic to deal with fields on the list view. This would be reasonably straightforward
// except that the server sometimes adds 5 well-known fields to every record & nested
// record in its responses.
// hardcoded fields that the server adds
const DEFAULT_SERVER_FIELDS = [
    'CreatedDate',
    'Id',
    'LastModifiedById',
    'LastModifiedDate',
    'SystemModstamp',
];
/**
 * Adds default fields for every record referenced in a given field name. E.g. if field
 * is "Opportunity.Account.Name" then add default fields "Opportunity.CreatedDate",
 * "Opportunity.Id", ..., "Opportunity.Account.CreatedDate", "Opportunity.Account.Id", ... .
 *
 * @param field explicitly included field
 * @param defaultFields fields object to be updated with the fields that the server will
 *    implicitly add
 */
function addDefaultFields(field, defaultFields) {
    const fieldParts = field.split('.');
    for (let i = 1; i < fieldParts.length; ++i) {
        const fieldPrefix = fieldParts.slice(0, i).join('.');
        for (let j = 0; j < DEFAULT_SERVER_FIELDS.length; ++j) {
            defaultFields[`${fieldPrefix}.${DEFAULT_SERVER_FIELDS[j]}`] = true;
        }
    }
}
/**
 * Indicates if a RecordRepresentation contains a specified field.
 *
 * @param record record
 * @param field field to check for, split on '.'s, with the leading object api name omitted.
 *    E.g. if searching an Opportunity for "Opportunity.Account.Name" this parameter should
 *    be ['Account','Name'].
 */
function recordContainsField(record, field) {
    // make sure it looks like a record and the first piece of the field path has a value
    if (!record ||
        !record.fields ||
        !record.fields[field[0]] ||
        record.fields[field[0]].value === undefined) {
        return false;
    }
    // recurse if nested record
    else if (field.length > 1) {
        return recordContainsField(record.fields[field[0]].value, field.slice(1));
    }
    // found it
    return true;
}
function listFields(luvio, { fields = [], optionalFields = [], sortBy, }, listInfo) {
    const { displayColumns, listReference: { objectApiName }, } = listInfo;
    let fields_ = {}, optionalFields_ = {}, defaultFields_ = {};
    // all the fields in the list info are required
    for (let i = 0, len = displayColumns.length; i < len; ++i) {
        const qualifiedField = `${objectApiName}.${displayColumns[i].fieldApiName}`;
        fields_[qualifiedField] = true;
        addDefaultFields(qualifiedField, defaultFields_);
    }
    // required fields from the component
    for (let i = 0, len = fields.length; i < len; ++i) {
        const qualifiedField = fields[i].startsWith(`${objectApiName}.`)
            ? fields[i]
            : `${objectApiName}.${fields[i]}`;
        if (!fields_[qualifiedField]) {
            fields_[qualifiedField] = true;
            addDefaultFields(qualifiedField, defaultFields_);
        }
    }
    // optional fields from the component
    for (let i = 0, len = optionalFields.length; i < len; ++i) {
        const qualifiedField = optionalFields[i].startsWith(`${objectApiName}.`)
            ? optionalFields[i]
            : `${objectApiName}.${optionalFields[i]}`;
        if (!fields_[qualifiedField]) {
            optionalFields_[qualifiedField] = true;
            addDefaultFields(qualifiedField, defaultFields_);
        }
    }
    const key = keyBuilder$6({
        listViewId: listInfo.eTag,
        sortBy: sortBy || null,
    }) + '__fieldstatus';
    const node = luvio.getNode(key);
    const defaultServerFieldStatus = isGraphNode(node)
        ? node.retrieve()
        : { missingFields: { ...defaultFields_ } };
    return {
        getRecordSelectionFieldSets() {
            const optionalPlusDefaultFields = { ...optionalFields_ };
            const fields = keys(defaultFields_);
            for (let i = 0; i < fields.length; ++i) {
                const field = fields[i];
                if (!fields_[field] && !defaultServerFieldStatus.missingFields[field]) {
                    optionalPlusDefaultFields[field] = true;
                }
            }
            return [keys(fields_).sort(), keys(optionalPlusDefaultFields).sort()];
        },
        processRecords(records) {
            const { missingFields } = defaultServerFieldStatus;
            const fields = keys(missingFields);
            for (let i = 0; i < fields.length; ++i) {
                const field = fields[i], splitField = field.split('.').slice(1);
                for (let i = 0; i < records.length; ++i) {
                    if (recordContainsField(records[i], splitField)) {
                        delete missingFields[field];
                        break;
                    }
                }
            }
            luvio.storePublish(key, defaultServerFieldStatus);
            // snapshots do not subscribe to this key, so no need to broadcast
            return this;
        },
    };
}
function isResultListInfoRepresentation(result) {
    return 'listReference' in result.body;
}

function paginatedDataCustomReader(key, selection, record, data, variables, reader) {
    const nonCustomSelection = {
        name: selection.name,
        plural: true,
        pageToken: selection.pageToken,
        pageSize: selection.pageSize,
        tokenDataKey: selection.tokenDataKey,
    };
    if (record[selection.name] && record[selection.name][0] && record[selection.name][0].__ref) {
        nonCustomSelection.kind = 'Link';
        nonCustomSelection.fragment = {
            kind: 'Fragment',
            selections: selection.selections,
            private: selection.private,
        };
        reader.readPluralLink(key, nonCustomSelection, record, data);
    }
    else {
        nonCustomSelection.kind = 'Object';
        nonCustomSelection.selections = selection.selections;
        reader.readPluralObject(key, nonCustomSelection, record, data);
    }
    const pagination = reader.pagination(selection.tokenDataKey);
    variables.__pageSize = selection.pageSize;
    const currentOffset = pagination.offsetFor(selection.pageToken);
    const nextOffset = currentOffset + selection.pageSize;
    const previousOffset = currentOffset - selection.pageSize;
    // count
    variables.count = data[selection.name].length;
    // current/next/previousPageToken
    variables.currentPageToken = selection.pageToken || pagination.defaultToken();
    const nextPageToken = pagination.isPastEnd(nextOffset) ? null : pagination.tokenFor(nextOffset);
    if (nextPageToken !== undefined) {
        variables.nextPageToken = nextPageToken;
    }
    const previousPageToken = previousOffset < 0 ? null : pagination.tokenFor(previousOffset);
    if (previousPageToken !== undefined) {
        variables.previousPageToken = previousPageToken;
    }
    // current/next/previousPageUrls cannot be generated until we have a template url
}
function variablesCustomReader(key, selection, record, data, variables, reader) {
    reader.readScalar(selection.name, variables, data);
}
function urlCustomReader(key, selection, record, data, variables, reader) {
    let urlProp = selection.name;
    let tokenProp = `${urlProp.substring(0, urlProp.indexOf('Url'))}Token`;
    if (variables[tokenProp]) {
        // currentPageUrl should never be empty so use that as the template
        variables[urlProp] = record.currentPageUrl
            .replace(/pageToken=[^&]+/, `pageToken=${variables[tokenProp]}`)
            .replace(/pageSize=\d+/, `pageSize=${variables.__pageSize}`);
    }
    else if (variables[tokenProp] === null) {
        variables[urlProp] = null;
    }
    reader.readScalar(selection.name, variables, data);
}
/**
 * Constructs a PathSelection[] to have Reader correctly populate paginated data
 * and metadata in a Snapshot. The metadata is assumed to follow the standard
 * UI API naming conventions: count, currentPageToken, currentPageUrl,
 * nextPageToken, nextPageUrl, previousPageToken, and previousPageUrl.
 *
 * @param config.name name of the field containing the paginated data
 * @param config.pageSize number of items to be included
 * @param config.pageToken token corresponding to starting offset
 * @param config.selections PathSelection[] to apply to each item
 * @param config.tokenDataKey store key of the pagination data
 * @returns PathSelection[] to populate the paginated data and associated metadata
 */
function pathSelectionsFor(config) {
    return [
        {
            kind: 'Custom',
            name: config.name,
            pageToken: config.pageToken,
            pageSize: config.pageSize,
            plural: true,
            reader: paginatedDataCustomReader,
            selections: config.selections,
            private: config.private,
            tokenDataKey: config.tokenDataKey,
        },
        {
            kind: 'Custom',
            name: 'count',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'currentPageToken',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'currentPageUrl',
            reader: urlCustomReader,
        },
        {
            kind: 'Custom',
            name: 'nextPageToken',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'nextPageUrl',
            reader: urlCustomReader,
        },
        {
            kind: 'Custom',
            name: 'previousPageToken',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'previousPageUrl',
            reader: urlCustomReader,
        },
    ];
}
/**
 * Returns a PathSelection that injects a predetermined value at the specified name.
 *
 * @param config.name key associated with the value
 * @param config.value value to be injected
 */
function staticValuePathSelection(config) {
    return {
        kind: 'Custom',
        name: config.name,
        reader: (key, _selection, _record, data, _variables, _reader) => {
            data[key] = config.value;
        },
    };
}
/**
 * Examines a set of paginated data & metadata from an UnfulfilledSnapshot and computes a
 * pageToken and pageSize that will minimize the amount of data requested while still
 * satisfying the original request.
 *
 * @param config.name name of the field within data that contains the items
 * @param conifg.data paginated data/metadata from an UnfulfilledSnapshot
 * @param config.pageSize requested pageSize
 * @param config.pagination pagination data/functions from engine
 * @returns pageToken & pageSize to fill in the missing data
 */
function minimizeRequest(config) {
    // the only way to handle missing current or previous token is to ask for the full set of requested records
    if (!config.data || !config.data[config.name] || config.data.previousPageToken === undefined) {
        return {
            pageSize: config.pageSize,
            pageToken: config.pageToken,
        };
    }
    else {
        // compute the offset of the last record that was found
        const pageTokenOffset = config.pagination.offsetFor(config.data.currentPageToken);
        const lastFoundOffset = pageTokenOffset + config.data[config.name].length;
        // backup to the nearest offset for which we have a token
        const [newToken, newOffset] = config.pagination.tokenForAtMost(lastFoundOffset);
        // recompute pageToken and pageSize for query based on new starting token
        return {
            pageSize: pageTokenOffset - newOffset + config.pageSize,
            pageToken: newToken,
        };
    }
}

function validate$c(obj, path = 'ListViewSummaryRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listUiUrl = obj.listUiUrl;
        const path_listUiUrl = path + '.listUiUrl';
        if (typeof obj_listUiUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listUiUrl + '" (at "' + path_listUiUrl + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$e = function ListViewSummaryRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'listUiUrl',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$8(existing, incoming) {
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_label = existing.label;
    const incoming_label = incoming.label;
    if (!(existing_label === incoming_label)) {
        return false;
    }
    const existing_listUiUrl = existing.listUiUrl;
    const incoming_listUiUrl = incoming.listUiUrl;
    if (!(existing_listUiUrl === incoming_listUiUrl)) {
        return false;
    }
    return true;
}

function validate$d(obj, path = 'ListViewSummaryCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_lists = obj.lists;
        const path_lists = path + '.lists';
        if (!ArrayIsArray$1(obj_lists)) {
            return new TypeError('Expected "array" but received "' + typeof obj_lists + '" (at "' + path_lists + '")');
        }
        for (let i = 0; i < obj_lists.length; i++) {
            const obj_lists_item = obj_lists[i];
            const path_lists_item = path_lists + '[' + i + ']';
            const referencepath_lists_itemValidationError = validate$c(obj_lists_item, path_lists_item);
            if (referencepath_lists_itemValidationError !== null) {
                let message = 'Object doesn\'t match ListViewSummaryRepresentation (at "' + path_lists_item + '")\n';
                message += referencepath_lists_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || (typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_queryString = obj.queryString;
        const path_queryString = path + '.queryString';
        let obj_queryString_union0 = null;
        const obj_queryString_union0_error = (() => {
            if (typeof obj_queryString !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
            }
        })();
        if (obj_queryString_union0_error != null) {
            obj_queryString_union0 = obj_queryString_union0_error.message;
        }
        let obj_queryString_union1 = null;
        const obj_queryString_union1_error = (() => {
            if (obj_queryString !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
            }
        })();
        if (obj_queryString_union1_error != null) {
            obj_queryString_union1 = obj_queryString_union1_error.message;
        }
        if (obj_queryString_union0 && obj_queryString_union1) {
            let message = 'Object doesn\'t match union (at "' + path_queryString + '")';
            message += '\n' + obj_queryString_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_queryString_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recentListsOnly = obj.recentListsOnly;
        const path_recentListsOnly = path + '.recentListsOnly';
        if (typeof obj_recentListsOnly !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_recentListsOnly + '" (at "' + path_recentListsOnly + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$c(config) {
    return keyPrefix + 'ListViewSummaryCollectionRepresentation:' + config.objectApiName + ':' + (config.queryString === null ? '' : config.queryString) + ':' + config.recentListsOnly;
}
function keyBuilderFromType$6(object) {
    const keyParams = {
        objectApiName: object.objectApiName,
        queryString: object.queryString,
        recentListsOnly: object.recentListsOnly
    };
    return keyBuilder$c(keyParams);
}
function paginationKeyBuilder$1(config) {
    return keyBuilder$c(config) + '__pagination';
}
function normalize$7(input, existing, path, luvio, store, timestamp) {
    return input;
}
function equals$9(existing, incoming) {
    const existing_recentListsOnly = existing.recentListsOnly;
    const incoming_recentListsOnly = incoming.recentListsOnly;
    if (!(existing_recentListsOnly === incoming_recentListsOnly)) {
        return false;
    }
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_pageSize = existing.pageSize;
    const incoming_pageSize = incoming.pageSize;
    if (!(existing_pageSize === incoming_pageSize)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_lists = existing.lists;
    const incoming_lists = incoming.lists;
    const equals_lists_items = equalsArray(existing_lists, incoming_lists, (existing_lists_item, incoming_lists_item) => {
        if (!(equals$8(existing_lists_item, incoming_lists_item))) {
            return false;
        }
    });
    if (equals_lists_items === false) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_queryString = existing.queryString;
    const incoming_queryString = incoming.queryString;
    if (!(existing_queryString === incoming_queryString)) {
        return false;
    }
    return true;
}
const ingest$7 = function ListViewSummaryCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$d(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$6(input);
    let incomingRecord = normalize$7(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    const paginationKey = paginationKeyBuilder$1({
        objectApiName: input.objectApiName,
        queryString: input.queryString,
        recentListsOnly: input.recentListsOnly,
    });
    const { isPastEnd, offsetFor, save, setEnd, setToken } = luvio.pagination(paginationKey);
    const currentOffset = offsetFor(input.currentPageToken);
    if (process.env.NODE_ENV !== 'production') {
        if (currentOffset === undefined ||
            (existingRecord &&
                existingRecord.lists.length < currentOffset)) {
            throw new RangeError("currentPageToken value " + input.currentPageToken + " not recognized");
        }
    }
    const nextOffset = currentOffset + input.count;
    if (input.nextPageToken) {
        setToken(input.nextPageToken, nextOffset);
        if (isPastEnd(nextOffset)) {
            setEnd(undefined);
        }
    }
    else {
        setEnd(nextOffset);
    }
    if (input.previousPageToken) {
        // TODO - need request's pageSize to ingest previousPageToken at end of list
        if (input.nextPageToken) {
            setToken(input.previousPageToken, currentOffset - input.count);
        }
    }
    save();
    if (existingRecord) {
        incomingRecord.currentPageUrl = existingRecord.currentPageUrl;
        // TODO: needs optimization
        incomingRecord.lists = [
            ...existingRecord.lists.slice(0, currentOffset),
            ...incomingRecord.lists,
            ...(input.nextPageToken ?
                existingRecord.lists.slice(nextOffset) :
                []),
        ];
    }
    if (existingRecord === undefined || equals$9(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function keyBuilder$d(params) {
    return keyBuilder$c({
        objectApiName: params.urlParams.objectApiName,
        queryString: params.queryParams.q || null,
        recentListsOnly: params.queryParams.recentListsOnly || false
    });
}
function createResourceRequest$7(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getListViewSummaryCollection_ConfigPropertyNames = {
    displayName: 'getListViewSummaryCollection',
    parameters: {
        required: ['objectApiName'],
        optional: ['pageSize', 'pageToken', 'q', 'recentListsOnly']
    }
};
function createResourceParams$4(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            pageSize: config.pageSize, pageToken: config.pageToken, q: config.q, recentListsOnly: config.recentListsOnly
        }
    };
}
function coerceConfig$4(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const q = config.q;
    if (q !== undefined) {
        coercedConfig.q = q;
    }
    const recentListsOnly = config.recentListsOnly;
    if (recentListsOnly !== undefined) {
        coercedConfig.recentListsOnly = recentListsOnly;
    }
    return coercedConfig;
}
function typeCheckConfig$4(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_q = untrustedConfig.q;
    if (typeof untrustedConfig_q === 'string') {
        config.q = untrustedConfig_q;
    }
    const untrustedConfig_recentListsOnly = untrustedConfig.recentListsOnly;
    if (typeof untrustedConfig_recentListsOnly === 'boolean') {
        config.recentListsOnly = untrustedConfig_recentListsOnly;
    }
    return config;
}
function validateAdapterConfig$4(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$4(untrustedConfig);
    const config = typeCheckConfig$4(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

// TODO RAML - this more properly goes in the generated resource files
const DEFAULT_PAGE_SIZE = 20;
const LISTVIEWSUMMARY_PATH_SELECTIONS = select$e().selections;
function buildListViewSummaryCollectionFragment(config) {
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            ...pathSelectionsFor({
                name: 'lists',
                selections: LISTVIEWSUMMARY_PATH_SELECTIONS,
                pageSize: config.pageSize || DEFAULT_PAGE_SIZE,
                pageToken: config.pageToken,
                tokenDataKey: paginationKeyBuilder$1({
                    objectApiName: config.objectApiName,
                    queryString: config.q === undefined ? null : config.q,
                    recentListsOnly: config.recentListsOnly === undefined ? false : config.recentListsOnly,
                }),
            }),
            {
                kind: 'Scalar',
                name: 'objectApiName',
            },
            staticValuePathSelection({
                name: 'pageSize',
                value: config.pageSize === undefined ? DEFAULT_PAGE_SIZE : config.pageSize,
            }),
            {
                kind: 'Scalar',
                name: 'queryString',
            },
            {
                kind: 'Scalar',
                name: 'recentListsOnly',
            },
        ],
    };
}
function buildRefreshSnapshot(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$4(luvio, config),
    };
}
function buildInMemorySnapshot$4(luvio, config) {
    const selector = {
        recordId: keyBuilder$d(createResourceParams$4(config)),
        node: buildListViewSummaryCollectionFragment(config),
        variables: {},
    };
    return luvio.storeLookup(selector, buildRefreshSnapshot(luvio, config));
}
function prepareRequest$1(luvio, config, resourceParams, snapshot) {
    const request = createResourceRequest$7(resourceParams);
    if (snapshot) {
        // compute the minimum number of records we need to request
        const { pageSize, pageToken } = minimizeRequest({
            data: snapshot.data,
            name: 'lists',
            pageSize: config.pageSize || DEFAULT_PAGE_SIZE,
            pageToken: config.pageToken,
            pagination: luvio.pagination(paginationKeyBuilder$1({
                objectApiName: config.objectApiName,
                queryString: config.q === undefined ? null : config.q,
                recentListsOnly: config.recentListsOnly === undefined ? false : config.recentListsOnly,
            })),
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE || request.queryParams.pageSize !== undefined) {
            request.queryParams.pageSize = pageSize;
        }
        if (pageToken || request.queryParams.pageToken !== undefined) {
            request.queryParams.pageToken = pageToken;
        }
    }
    return request;
}
function onResourceSuccess$1(luvio, config, key, response) {
    const { body } = response;
    luvio.storeIngest(key, ingest$7, body);
    luvio.storeBroadcast();
    return buildInMemorySnapshot$4(luvio, config);
}
function onResourceError$1(luvio, config, key, error) {
    const errorSnapshot = luvio.errorSnapshot(error, buildRefreshSnapshot(luvio, config));
    luvio.storeIngestError(key, errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function resolveUnfulfilledSnapshot$4(luvio, config, snapshot) {
    const resourceParams = createResourceParams$4(config);
    const key = keyBuilder$d(resourceParams);
    const request = prepareRequest$1(luvio, config, resourceParams, snapshot);
    return luvio
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then((resp) => {
        return onResourceSuccess$1(luvio, config, key, resp);
    }, (error) => {
        return onResourceError$1(luvio, config, key, error);
    });
}
function buildNetworkSnapshot$4(luvio, config, snapshot) {
    const resourceParams = createResourceParams$4(config);
    const key = keyBuilder$d(resourceParams);
    const request = prepareRequest$1(luvio, config, resourceParams, snapshot);
    return luvio.dispatchResourceRequest(request).then((resp) => {
        return onResourceSuccess$1(luvio, config, key, resp);
    }, (error) => {
        return onResourceError$1(luvio, config, key, error);
    });
}
const factory = (luvio) => function getListViewSummaryCollection(untrustedConfig) {
    const config = validateAdapterConfig$4(untrustedConfig, getListViewSummaryCollection_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$4(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot)) {
        return cacheSnapshot;
    }
    if (isUnfulfilledSnapshot(cacheSnapshot)) {
        return resolveUnfulfilledSnapshot$4(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$4(luvio, config, cacheSnapshot);
};

function keyBuilder$e(params) {
    return keyBuilder$7({
        listViewApiName: null,
        objectApiName: params.urlParams.objectApiName,
        type: "mru",
        sortBy: params.queryParams.sortBy || null
    });
}
function createResourceRequest$8(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/mru-list-ui/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getMruListUi_ConfigPropertyNames = {
    displayName: 'getMruListUi',
    parameters: {
        required: ['objectApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function createResourceParams$5(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            fields: config.fields, optionalFields: config.optionalFields, pageSize: config.pageSize, pageToken: config.pageToken, sortBy: config.sortBy
        }
    };
}
function coerceConfig$5(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const sortBy = getFieldApiNamesArray(config.sortBy);
    if (sortBy !== undefined) {
        coercedConfig.sortBy = sortBy;
    }
    return coercedConfig;
}
function typeCheckConfig$5(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$5(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$5(untrustedConfig);
    const config = typeCheckConfig$5(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function createResourceRequest$9(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/mru-list-records/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const LIST_REFERENCE_SELECTIONS = select$4();
// TODO RAML - this more properly goes in the generated resource files
const DEFAULT_PAGE_SIZE$1 = 50;
// make local copies of the adapter configs so we can ignore other getListUi config parameters to match
// lds222 behavior
const getMruListUi_ConfigPropertyNames_augmented = {
    ...getMruListUi_ConfigPropertyNames,
    parameters: {
        ...getMruListUi_ConfigPropertyNames.parameters,
        optional: [
            ...getMruListUi_ConfigPropertyNames.parameters.optional,
            'listViewApiName',
            'listViewId',
        ],
    },
};
function buildListUiFragment(config, listInfo, fields) {
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            {
                kind: 'Link',
                name: 'info',
                fragment: {
                    kind: 'Fragment',
                    private: LIST_INFO_PRIVATES,
                    selections: LIST_INFO_SELECTIONS,
                },
            },
            {
                kind: 'Link',
                name: 'records',
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: [
                        ...pathSelectionsFor({
                            name: 'records',
                            pageSize: config.pageSize || DEFAULT_PAGE_SIZE$1,
                            pageToken: config.pageToken,
                            private: ['eTag', 'weakEtag'],
                            selections: buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),
                            tokenDataKey: paginationKeyBuilder({
                                listViewId: listInfo.eTag,
                                sortBy: config.sortBy === undefined ? null : config.sortBy,
                            }),
                        }),
                        {
                            kind: 'Scalar',
                            name: 'fields',
                            plural: true,
                        },
                        {
                            kind: 'Scalar',
                            name: 'listInfoETag',
                        },
                        {
                            kind: 'Link',
                            name: 'listReference',
                            fragment: LIST_REFERENCE_SELECTIONS,
                        },
                        {
                            kind: 'Scalar',
                            name: 'optionalFields',
                            plural: true,
                        },
                        staticValuePathSelection({
                            name: 'pageSize',
                            value: config.pageSize === undefined ? DEFAULT_PAGE_SIZE$1 : config.pageSize,
                        }),
                        {
                            // TODO - check type; re-verify after sortBy added to key
                            kind: 'Scalar',
                            name: 'sortBy',
                        },
                    ],
                },
            },
        ],
    };
}
function buildSnapshotRefresh$1(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot_getMruListUi(luvio, config),
    };
}
function onResourceSuccess_getMruListUi(luvio, config, response) {
    const { body } = response;
    const listInfo = body.info;
    // response might have records.sortBy in csv format
    const sortBy = body.records.sortBy;
    if (sortBy && typeof sortBy === 'string') {
        body.records.sortBy = sortBy.split(',');
    }
    const listUiKey = keyBuilder$7({
        ...listInfo.listReference,
        sortBy: body.records.sortBy,
    });
    // grab relevant bits before ingest destroys the structure
    const fields = listFields(luvio, config, listInfo);
    fields.processRecords(body.records.records);
    // build the selector while the list info is still easily accessible
    const fragment = buildListUiFragment(config, listInfo, fields);
    luvio.storeIngest(listUiKey, ingest$6, body);
    const snapshot = luvio.storeLookup({
        recordId: listUiKey,
        node: fragment,
        variables: {},
    }, buildSnapshotRefresh$1(luvio, config));
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceError_getMruListUi(luvio, config, err) {
    return luvio.errorSnapshot(err, buildSnapshotRefresh$1(luvio, config));
}
function buildInMemorySnapshot$5(luvio, config, listInfo, fields) {
    const listFields_ = fields || listFields(luvio, config, listInfo);
    const resourceParams = createResourceParams$5(config);
    const selector = {
        recordId: keyBuilder$e(resourceParams),
        node: buildListUiFragment(config, listInfo, listFields_),
        variables: {},
    };
    return luvio.storeLookup(selector, buildSnapshotRefresh$1(luvio, config));
}
function resolveUnfulfilledSnapshot_getMruListUi(luvio, config, snapshot) {
    const params = createResourceParams$5(config);
    const request = createResourceRequest$8(params);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot).then((response) => {
        return onResourceSuccess_getMruListUi(luvio, config, response);
    }, (err) => {
        return onResourceError_getMruListUi(luvio, config, err);
    });
}
/**
 * Builds, sends, and processes the result of a mru-list-ui request, ignoring any cached
 * data for the list.
 *
 * @param luvio Luvio engine
 * @param config wire config
 */
function buildNetworkSnapshot_getMruListUi(luvio, config) {
    const params = createResourceParams$5(config);
    const request = createResourceRequest$8(params);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResourceSuccess_getMruListUi(luvio, config, response);
    }, (err) => {
        return onResourceError_getMruListUi(luvio, config, err);
    });
}
function prepareRequest_getMruListRecords(luvio, config, listInfo, snapshot) {
    const { fields, optionalFields, pageSize, pageToken, sortBy } = config;
    const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy,
    };
    const request = createResourceRequest$9({
        urlParams: {
            objectApiName: config.objectApiName,
        },
        queryParams,
    });
    if (snapshot) {
        // compute the minimum number of records we need to request
        const { pageSize, pageToken } = minimizeRequest({
            data: snapshot.data ? snapshot.data.records : null,
            name: 'records',
            pageSize: config.pageSize || DEFAULT_PAGE_SIZE$1,
            pageToken: config.pageToken,
            pagination: luvio.pagination(paginationKeyBuilder({
                listViewId: listInfo.eTag,
                sortBy: config.sortBy === undefined ? null : config.sortBy,
            })),
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE$1 || request.queryParams.pageSize !== undefined) {
            request.queryParams.pageSize = pageSize;
        }
        if (pageToken !== undefined || request.queryParams.pageToken !== undefined) {
            request.queryParams.pageToken = pageToken;
        }
    }
    return request;
}
function onResourceSuccess_getMruListRecords(luvio, config, listInfo, response) {
    const { body } = response;
    const { listInfoETag } = body;
    // fall back to mru-list-ui if list view has changed
    if (listInfoETag !== listInfo.eTag) {
        return buildNetworkSnapshot_getMruListUi(luvio, config);
    }
    // server returns sortBy in csv format
    if (body.sortBy) {
        body.sortBy = body.sortBy.split(',');
    }
    const fields = listFields(luvio, config, listInfo).processRecords(body.records);
    luvio.storeIngest(keyBuilder$6({
        listViewId: listInfoETag,
        sortBy: body.sortBy,
    }), ingest$5, body);
    const snapshot = buildInMemorySnapshot$5(luvio, config, listInfo, fields);
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceError_getMruListRecords(luvio, config, listInfo, err) {
    const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$1(luvio, config));
    luvio.storeIngestError(keyBuilder$7({
        ...listInfo.listReference,
        sortBy: config.sortBy === undefined ? null : config.sortBy,
    }), errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function resolveUnfulfilledSnapshot_getMruListRecords(luvio, config, listInfo, snapshot) {
    const request = prepareRequest_getMruListRecords(luvio, config, listInfo, snapshot);
    return luvio
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceSuccess_getMruListRecords(luvio, config, listInfo, response);
    }, (err) => {
        return onResourceError_getMruListRecords(luvio, config, listInfo, err);
    });
}
function buildNetworkSnapshot_getMruListRecords(luvio, config, listInfo, snapshot) {
    const request = prepareRequest_getMruListRecords(luvio, config, listInfo, snapshot);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResourceSuccess_getMruListRecords(luvio, config, listInfo, response);
    }, (err) => {
        return onResourceError_getMruListRecords(luvio, config, listInfo, err);
    });
}
function getMruListUiSnapshotFromListInfo(luvio, config, listInfo) {
    // with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot = buildInMemorySnapshot$5(luvio, config, listInfo);
    // if the list ui was not found in the store then
    // make a full list-ui request
    if (!snapshot.data) {
        if (isUnfulfilledSnapshot(snapshot)) {
            return resolveUnfulfilledSnapshot_getMruListUi(luvio, config, snapshot);
        }
        return buildNetworkSnapshot_getMruListUi(luvio, config);
    }
    if (luvio.snapshotAvailable(snapshot)) {
        // cache hit :partyparrot:
        return snapshot;
    }
    // we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot_getMruListRecords(luvio, config, listInfo, snapshot);
    }
    return buildNetworkSnapshot_getMruListRecords(luvio, config, listInfo, snapshot);
}
const factory$1 = (luvio) => function getMruListUi(untrustedConfig) {
    const config = validateAdapterConfig$5(untrustedConfig, getMruListUi_ConfigPropertyNames_augmented);
    if (config === null) {
        return null;
    }
    // try to get a list reference and a list info for the list; this should come back
    // non-null if we have the list info cached
    const listInfoSnapshot = getListInfo({
        id: null,
        listViewApiName: null,
        objectApiName: config.objectApiName,
        type: 'mru',
    }, luvio, buildSnapshotRefresh$1(luvio, config));
    // if we have list info then build a snapshot from that
    if (isFulfilledSnapshot(listInfoSnapshot)) {
        return getMruListUiSnapshotFromListInfo(luvio, config, listInfoSnapshot.data);
    }
    // if listInfoSnapshot is unfulfilled then we can try to resolve it
    if (isUnfulfilledSnapshot(listInfoSnapshot)) {
        const mruListUiResourceRequest = createResourceRequest$8(createResourceParams$5(config));
        // In default environment resolving an unfulfilled snapshot is just hitting the network
        // with the given ResourceRequest (so mru-list-ui in this case).  In durable environment
        // resolving an unfulfilled snapshot will first attempt to read the missing cache keys
        // from the given unfulfilled snapshot (a list-info snapshot in this case) and build a
        // fulfilled snapshot from that if those cache keys are present, otherwise it hits the
        // network with the given resource request.  Usually the ResourceRequest and the unfulfilled
        // snapshot are for the same response Type, but this lists adapter is special (it mixes
        // calls with list-info, list-records, and mru-list-ui), and so our use of resolveUnfulfilledSnapshot
        // is special (polymorphic response, could either be a list-info representation or a
        // list-ui representation).
        return luvio
            .resolveUnfulfilledSnapshot(mruListUiResourceRequest, listInfoSnapshot)
            .then((response) => {
            // if result came from cache we know it's a listinfo, otherwise
            // it's a full list-ui response
            if (isResultListInfoRepresentation(response)) {
                return getMruListUiSnapshotFromListInfo(luvio, config, response.body);
            }
            else {
                return onResourceSuccess_getMruListUi(luvio, config, response);
            }
        }, (err) => {
            return onResourceError_getMruListUi(luvio, config, err);
        });
    }
    // if listInfoSnapshot in any other state then we make a full mru-list-ui request
    return buildNetworkSnapshot_getMruListUi(luvio, config);
};

const LIST_REFERENCE_SELECTIONS$1 = select$4();
// TODO RAML - this more properly goes in the generated resource files
const DEFAULT_PAGE_SIZE$2 = 50;
// make local copies of the adapter configs so we can have them ignore each other's config parameters
// to match lds222 behavior
const getListUiByApiName_ConfigPropertyNames_augmented = {
    ...getListUiByApiName_ConfigPropertyNames,
    parameters: {
        ...getListUiByApiName_ConfigPropertyNames.parameters,
        optional: [...getListUiByApiName_ConfigPropertyNames.parameters.optional, 'listViewId'],
    },
};
const getListUiByListViewId_ConfigPropertyNames_augmented = {
    ...getListUiByListViewId_ConfigPropertyNames,
    parameters: {
        ...getListUiByListViewId_ConfigPropertyNames.parameters,
        optional: [
            ...getListUiByListViewId_ConfigPropertyNames.parameters.optional,
            'listViewApiName',
            'objectApiName',
        ],
    },
};
function getSortBy(config, context) {
    if (config.sortBy !== undefined) {
        return config.sortBy;
    }
    const defaults = getServerDefaults(config, context);
    if (defaults.sortBy !== undefined) {
        return defaults.sortBy;
    }
    return null;
}
function buildListUiFragment$1(config, context, listInfo, fields) {
    const defaultedConfig = { ...getServerDefaults(config, context), ...config };
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            {
                kind: 'Link',
                name: 'info',
                fragment: {
                    kind: 'Fragment',
                    private: LIST_INFO_PRIVATES,
                    selections: LIST_INFO_SELECTIONS,
                },
            },
            {
                kind: 'Link',
                name: 'records',
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: [
                        ...pathSelectionsFor({
                            name: 'records',
                            pageSize: defaultedConfig.pageSize || DEFAULT_PAGE_SIZE$2,
                            pageToken: defaultedConfig.pageToken,
                            private: ['eTag', 'weakEtag'],
                            selections: buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),
                            tokenDataKey: paginationKeyBuilder({
                                listViewId: listInfo.eTag,
                                sortBy: defaultedConfig.sortBy === undefined
                                    ? null
                                    : defaultedConfig.sortBy,
                            }),
                        }),
                        {
                            kind: 'Scalar',
                            name: 'fields',
                            plural: true,
                        },
                        {
                            kind: 'Scalar',
                            name: 'listInfoETag',
                        },
                        {
                            kind: 'Link',
                            name: 'listReference',
                            fragment: LIST_REFERENCE_SELECTIONS$1,
                        },
                        {
                            kind: 'Scalar',
                            name: 'optionalFields',
                            plural: true,
                        },
                        staticValuePathSelection({
                            name: 'pageSize',
                            value: defaultedConfig.pageSize === undefined
                                ? DEFAULT_PAGE_SIZE$2
                                : defaultedConfig.pageSize,
                        }),
                        {
                            kind: 'Scalar',
                            name: 'sortBy',
                            plural: true,
                        },
                    ],
                },
            },
        ],
    };
}
function buildInMemorySnapshot$6(luvio, context, config, listInfo, fields) {
    const listUiKey = keyBuilder$7({
        ...listInfo.listReference,
        sortBy: getSortBy(config, context),
    });
    const listFields_ = fields || listFields(luvio, config, listInfo);
    const selector = {
        recordId: listUiKey,
        node: buildListUiFragment$1(config, context, listInfo, listFields_),
        variables: {},
    };
    return luvio.storeLookup(selector, buildSnapshotRefresh$2(luvio, context, config));
}
function buildSnapshotRefresh$2(luvio, context, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot_getListUi(luvio, context, config),
    };
}
function prepareRequest_getListUi(config) {
    const { fields, optionalFields, pageSize, pageToken, sortBy } = config;
    const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy,
    };
    let request;
    if (isGetListUiByApiNameConfig(config)) {
        request = createResourceRequest$3({
            urlParams: {
                listViewApiName: config.listViewApiName,
                objectApiName: config.objectApiName,
            },
            queryParams,
        });
    }
    else if (isGetListUiByListViewIdConfig(config)) {
        request = createResourceRequest$4({
            urlParams: { listViewId: config.listViewId },
            queryParams,
        });
    }
    else {
        throw new Error('unrecognized config');
    }
    return request;
}
function onResourceSuccess_getListUi(luvio, context, config, response) {
    const { body } = response, listInfo = body.info, { listReference } = listInfo;
    // response might have records.sortBy in csv format
    const sortBy = body.records.sortBy;
    if (sortBy && typeof sortBy === 'string') {
        body.records.sortBy = sortBy.split(',');
    }
    const listUiKey = keyBuilder$7({
        ...listReference,
        sortBy: body.records.sortBy,
    });
    // grab relevant bits before ingest destroys the structure
    const fields = listFields(luvio, config, listInfo);
    fields.processRecords(body.records.records);
    // remember the id/name of this list
    addListReference(listReference, context);
    // remember any default values that the server filled in
    addServerDefaults(config, body, context);
    // build the selector while the list info is still easily accessible
    const fragment = buildListUiFragment$1(config, context, listInfo, fields);
    luvio.storeIngest(listUiKey, ingest$6, body);
    const snapshot = luvio.storeLookup({
        recordId: listUiKey,
        node: fragment,
        variables: {},
    }, buildSnapshotRefresh$2(luvio, context, config));
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceError_getListUi(luvio, context, config, err) {
    return luvio.errorSnapshot(err, buildSnapshotRefresh$2(luvio, context, config));
}
function resolveUnfulfilledSnapshot_getListUi(luvio, context, config, snapshot) {
    const request = prepareRequest_getListUi(config);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot).then((response) => {
        return onResourceSuccess_getListUi(luvio, context, config, response);
    }, (err) => {
        return onResourceError_getListUi(luvio, context, config, err);
    });
}
/**
 * Builds, sends, and processes the result of a list-ui request, ignoring any cached
 * data for the list view.
 *
 * @param luvio Luvio engine
 * @param config wire config
 */
function buildNetworkSnapshot_getListUi(luvio, context, config) {
    const request = prepareRequest_getListUi(config);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResourceSuccess_getListUi(luvio, context, config, response);
    }, (err) => {
        return onResourceError_getListUi(luvio, context, config, err);
    });
}
function prepareRequest_getListRecords(luvio, context, config, listInfo, snapshot) {
    const { fields, optionalFields, pageSize, pageToken, sortBy } = config;
    const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy,
    };
    let request;
    if (isGetListUiByApiNameConfig(config)) {
        request = createResourceRequest$6({
            urlParams: {
                listViewApiName: config.listViewApiName,
                objectApiName: config.objectApiName,
            },
            queryParams,
        });
    }
    else if (isGetListUiByListViewIdConfig(config)) {
        request = createResourceRequest$5({
            urlParams: { listViewId: config.listViewId },
            queryParams,
        });
    }
    else {
        throw new Error('how did MRU config get here?');
    }
    if (snapshot) {
        // compute the minimum number of records we need to request
        const { pageSize, pageToken } = minimizeRequest({
            data: snapshot.data ? snapshot.data.records : null,
            name: 'records',
            pageSize: config.pageSize || DEFAULT_PAGE_SIZE$2,
            pageToken: config.pageToken,
            pagination: luvio.pagination(paginationKeyBuilder({
                listViewId: listInfo.eTag,
                sortBy: getSortBy(config, context),
            })),
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE$2 || request.queryParams.pageSize !== undefined) {
            request.queryParams.pageSize = pageSize;
        }
        if (pageToken || request.queryParams.pageToken !== undefined) {
            request.queryParams.pageToken = pageToken;
        }
    }
    return request;
}
function onResourceSuccess_getListRecords(luvio, context, config, listInfo, response) {
    const { body } = response;
    const { listInfoETag } = body;
    // fall back to list-ui if list view has changed
    if (listInfoETag !== listInfo.eTag) {
        return buildNetworkSnapshot_getListUi(luvio, context, config);
    }
    // response might have records.sortBy in csv format
    const { sortBy } = body;
    if (sortBy && typeof sortBy === 'string') {
        body.sortBy = sortBy.split(',');
    }
    const fields = listFields(luvio, config, listInfo).processRecords(body.records);
    luvio.storeIngest(keyBuilder$6({
        listViewId: listInfoETag,
        sortBy: body.sortBy,
    }), ingest$5, body);
    luvio.storeBroadcast();
    return buildInMemorySnapshot$6(luvio, context, config, listInfo, fields);
}
function onResourceError_getListRecords(luvio, context, config, listInfo, err) {
    const errorSnapshot = luvio.errorSnapshot(err);
    luvio.storeIngestError(keyBuilder$7({
        ...listInfo.listReference,
        sortBy: getSortBy(config, context),
    }), errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function resolveUnfulfilledSnapshot_getListRecords(luvio, context, config, listInfo, snapshot) {
    const request = prepareRequest_getListRecords(luvio, context, config, listInfo, snapshot);
    return luvio
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceSuccess_getListRecords(luvio, context, config, listInfo, response);
    }, (err) => {
        return onResourceError_getListRecords(luvio, context, config, listInfo, err);
    });
}
function buildNetworkSnapshot_getListRecords(luvio, context, config, listInfo, snapshot) {
    const request = prepareRequest_getListRecords(luvio, context, config, listInfo, snapshot);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResourceSuccess_getListRecords(luvio, context, config, listInfo, response);
    }, (err) => {
        return onResourceError_getListRecords(luvio, context, config, listInfo, err);
    });
}
// functions to discern config variations
function isGetListUiByApiNameConfig(config) {
    return config.listViewApiName !== undefined;
}
function looksLikeGetListUiByApiNameConfig(untrustedConfig) {
    return (untrustedIsObject(untrustedConfig) &&
        untrustedConfig.objectApiName &&
        untrustedConfig.listViewApiName);
}
function isGetListUiByListViewIdConfig(config) {
    return !!config.listViewId;
}
function looksLikeGetListUiByListViewIdConfig(untrustedConfig) {
    return (untrustedIsObject(untrustedConfig) &&
        untrustedConfig.listViewId);
}
function looksLikeGetListViewSummaryCollectionConfig(untrustedConfig) {
    return (untrustedIsObject(untrustedConfig) &&
        untrustedConfig.objectApiName &&
        !untrustedConfig.listViewId &&
        !untrustedConfig.listViewApiName);
}
function looksLikeGetMruListUiConfig(untrustedConfig) {
    // the MRU symbol is a carryover hack from 222 and doesn't show up in any
    // of the generated config types, so we cast to any in order to check for it
    return untrustedIsObject(untrustedConfig) && untrustedConfig.listViewApiName === MRU;
}
function validateGetListUiConfig(untrustedConfig) {
    return looksLikeGetListUiByApiNameConfig(untrustedConfig)
        ? validateAdapterConfig$2(untrustedConfig, getListUiByApiName_ConfigPropertyNames_augmented)
        : looksLikeGetListUiByListViewIdConfig(untrustedConfig)
            ? validateAdapterConfig$3(untrustedConfig, getListUiByListViewId_ConfigPropertyNames_augmented)
            : null;
}
// the listViewApiName value to pass to getListUi() to request the MRU list
const MRU = Symbol.for('MRU');
function getListUiSnapshotFromListInfo(luvio, context, config, listInfo) {
    // with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot = buildInMemorySnapshot$6(luvio, context, config, listInfo);
    // if the list ui was not found in the store then
    // make a full list-ui request
    if (!snapshot.data) {
        if (isUnfulfilledSnapshot(snapshot)) {
            return resolveUnfulfilledSnapshot_getListUi(luvio, context, config, snapshot);
        }
        return buildNetworkSnapshot_getListUi(luvio, context, config);
    }
    if (luvio.snapshotAvailable(snapshot)) {
        // cache hit :partyparrot:
        return snapshot;
    }
    // we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot_getListRecords(luvio, context, config, listInfo, snapshot);
    }
    return buildNetworkSnapshot_getListRecords(luvio, context, config, listInfo, snapshot);
}
const factory$2 = (luvio) => {
    // adapter implementation for getListUiBy*
    const listUiAdapter = (untrustedConfig, context) => {
        const config = validateGetListUiConfig(untrustedConfig);
        if (config === null) {
            return null;
        }
        // try to get a list reference and a list info for the list; this should come back
        // non-null if we have the list info cached
        const listRef = getListReference(config, context);
        // no listRef means we can't even attempt to build an in-memory snapshot
        // so make a full list-ui request
        if (listRef === undefined) {
            return buildNetworkSnapshot_getListUi(luvio, context, config);
        }
        const listInfoSnapshot = getListInfo(listRef, luvio, buildSnapshotRefresh$2(luvio, context, config));
        // if we have list info then build a snapshot from that
        if (isFulfilledSnapshot(listInfoSnapshot)) {
            return getListUiSnapshotFromListInfo(luvio, context, config, listInfoSnapshot.data);
        }
        // if listInfoSnapshot is unfulfilled then we can try to resolve it
        if (isUnfulfilledSnapshot(listInfoSnapshot)) {
            const listUiResourceRequest = prepareRequest_getListUi(config);
            // In default environment resolving an unfulfilled snapshot is just hitting the network
            // with the given ResourceRequest (so list-ui in this case).  In durable environment
            // resolving an unfulfilled snapshot will first attempt to read the missing cache keys
            // from the given unfulfilled snapshot (a list-info snapshot in this case) and build a
            // fulfilled snapshot from that if those cache keys are present, otherwise it hits the
            // network with the given resource request.  Usually the ResourceRequest and the unfulfilled
            // snapshot are for the same response Type, but this lists adapter is special (it mixes
            // calls with list-info, list-records, and list-ui), and so our use of resolveUnfulfilledSnapshot
            // is special (polymorphic response, could either be a list-info representation or a
            // list-ui representation).
            return luvio.resolveUnfulfilledSnapshot(listUiResourceRequest, listInfoSnapshot).then((response) => {
                // if result came from cache we know it's a listinfo, otherwise
                // it's a full list-ui response
                if (isResultListInfoRepresentation(response)) {
                    return getListUiSnapshotFromListInfo(luvio, context, config, response.body);
                }
                else {
                    return onResourceSuccess_getListUi(luvio, context, config, response);
                }
            }, (err) => {
                return onResourceError_getListUi(luvio, context, config, err);
            });
        }
        // if listInfoSnapshot in any other state then we make a full list-ui request
        return buildNetworkSnapshot_getListUi(luvio, context, config);
    };
    let listViewSummaryCollectionAdapter = null;
    let mruAdapter = null;
    // delegate to various other adapter based on what config looks like; note that the adapters
    // we delegate to are responsible for returning refreshable results
    return luvio.withContext(function UiApi__custom_getListUi(untrustedConfig, context) {
        // if the MRU symbol is there then just return the getMruListUi adapter
        if (looksLikeGetMruListUiConfig(untrustedConfig)) {
            if (mruAdapter === null) {
                mruAdapter = factory$1(luvio);
            }
            // the symbol in the listViewApiName is just a hack so we can recognize the request as MRU
            const mruConfig = { ...untrustedConfig };
            delete mruConfig.listViewApiName;
            return mruAdapter(mruConfig);
        }
        // if config has objectApiName but no listViewId or listViewApiName then hand off
        // to listViewSummaryCollectionAdapter
        if (looksLikeGetListViewSummaryCollectionConfig(untrustedConfig)) {
            if (listViewSummaryCollectionAdapter === null) {
                listViewSummaryCollectionAdapter =
                    factory(luvio);
            }
            return listViewSummaryCollectionAdapter(untrustedConfig);
        }
        // see if config looks like a listViewId or listViewApiName request
        if (looksLikeGetListUiByApiNameConfig(untrustedConfig) ||
            looksLikeGetListUiByListViewIdConfig(untrustedConfig)) {
            return listUiAdapter(untrustedConfig, context);
        }
        return null;
    });
};

function validate$e(obj, path = 'ChildRelationshipRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_childObjectApiName = obj.childObjectApiName;
        const path_childObjectApiName = path + '.childObjectApiName';
        if (typeof obj_childObjectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_childObjectApiName + '" (at "' + path_childObjectApiName + '")');
        }
        const obj_fieldName = obj.fieldName;
        const path_fieldName = path + '.fieldName';
        if (typeof obj_fieldName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldName + '" (at "' + path_fieldName + '")');
        }
        const obj_junctionIdListNames = obj.junctionIdListNames;
        const path_junctionIdListNames = path + '.junctionIdListNames';
        if (!ArrayIsArray$1(obj_junctionIdListNames)) {
            return new TypeError('Expected "array" but received "' + typeof obj_junctionIdListNames + '" (at "' + path_junctionIdListNames + '")');
        }
        for (let i = 0; i < obj_junctionIdListNames.length; i++) {
            const obj_junctionIdListNames_item = obj_junctionIdListNames[i];
            const path_junctionIdListNames_item = path_junctionIdListNames + '[' + i + ']';
            if (typeof obj_junctionIdListNames_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_junctionIdListNames_item + '" (at "' + path_junctionIdListNames_item + '")');
            }
        }
        const obj_junctionReferenceTo = obj.junctionReferenceTo;
        const path_junctionReferenceTo = path + '.junctionReferenceTo';
        if (!ArrayIsArray$1(obj_junctionReferenceTo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_junctionReferenceTo + '" (at "' + path_junctionReferenceTo + '")');
        }
        for (let i = 0; i < obj_junctionReferenceTo.length; i++) {
            const obj_junctionReferenceTo_item = obj_junctionReferenceTo[i];
            const path_junctionReferenceTo_item = path_junctionReferenceTo + '[' + i + ']';
            if (typeof obj_junctionReferenceTo_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_junctionReferenceTo_item + '" (at "' + path_junctionReferenceTo_item + '")');
            }
        }
        const obj_relationshipName = obj.relationshipName;
        const path_relationshipName = path + '.relationshipName';
        if (typeof obj_relationshipName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$5(input) {
    const input_junctionIdListNames = input.junctionIdListNames;
    ObjectFreeze$1(input_junctionIdListNames);
    const input_junctionReferenceTo = input.junctionReferenceTo;
    ObjectFreeze$1(input_junctionReferenceTo);
    ObjectFreeze$1(input);
}

function validate$f(obj, path = 'FilteredLookupInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_controllingFields = obj.controllingFields;
        const path_controllingFields = path + '.controllingFields';
        if (!ArrayIsArray$1(obj_controllingFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_controllingFields + '" (at "' + path_controllingFields + '")');
        }
        for (let i = 0; i < obj_controllingFields.length; i++) {
            const obj_controllingFields_item = obj_controllingFields[i];
            const path_controllingFields_item = path_controllingFields + '[' + i + ']';
            if (typeof obj_controllingFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_controllingFields_item + '" (at "' + path_controllingFields_item + '")');
            }
        }
        const obj_dependent = obj.dependent;
        const path_dependent = path + '.dependent';
        if (typeof obj_dependent !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_dependent + '" (at "' + path_dependent + '")');
        }
        const obj_optionalFilter = obj.optionalFilter;
        const path_optionalFilter = path + '.optionalFilter';
        if (typeof obj_optionalFilter !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_optionalFilter + '" (at "' + path_optionalFilter + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$6(input) {
    const input_controllingFields = input.controllingFields;
    ObjectFreeze$1(input_controllingFields);
    ObjectFreeze$1(input);
}

function validate$g(obj, path = 'ReferenceToInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray$1(obj_nameFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
            const obj_nameFields_item = obj_nameFields[i];
            const path_nameFields_item = path_nameFields + '[' + i + ']';
            if (typeof obj_nameFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$7(input) {
    const input_nameFields = input.nameFields;
    ObjectFreeze$1(input_nameFields);
    ObjectFreeze$1(input);
}

function validate$h(obj, path = 'FieldRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_calculated = obj.calculated;
        const path_calculated = path + '.calculated';
        if (typeof obj_calculated !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_calculated + '" (at "' + path_calculated + '")');
        }
        const obj_compound = obj.compound;
        const path_compound = path + '.compound';
        if (typeof obj_compound !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_compound + '" (at "' + path_compound + '")');
        }
        const obj_compoundComponentName = obj.compoundComponentName;
        const path_compoundComponentName = path + '.compoundComponentName';
        let obj_compoundComponentName_union0 = null;
        const obj_compoundComponentName_union0_error = (() => {
            if (typeof obj_compoundComponentName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_compoundComponentName + '" (at "' + path_compoundComponentName + '")');
            }
        })();
        if (obj_compoundComponentName_union0_error != null) {
            obj_compoundComponentName_union0 = obj_compoundComponentName_union0_error.message;
        }
        let obj_compoundComponentName_union1 = null;
        const obj_compoundComponentName_union1_error = (() => {
            if (obj_compoundComponentName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_compoundComponentName + '" (at "' + path_compoundComponentName + '")');
            }
        })();
        if (obj_compoundComponentName_union1_error != null) {
            obj_compoundComponentName_union1 = obj_compoundComponentName_union1_error.message;
        }
        if (obj_compoundComponentName_union0 && obj_compoundComponentName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_compoundComponentName + '")';
            message += '\n' + obj_compoundComponentName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_compoundComponentName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_compoundFieldName = obj.compoundFieldName;
        const path_compoundFieldName = path + '.compoundFieldName';
        let obj_compoundFieldName_union0 = null;
        const obj_compoundFieldName_union0_error = (() => {
            if (typeof obj_compoundFieldName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_compoundFieldName + '" (at "' + path_compoundFieldName + '")');
            }
        })();
        if (obj_compoundFieldName_union0_error != null) {
            obj_compoundFieldName_union0 = obj_compoundFieldName_union0_error.message;
        }
        let obj_compoundFieldName_union1 = null;
        const obj_compoundFieldName_union1_error = (() => {
            if (obj_compoundFieldName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_compoundFieldName + '" (at "' + path_compoundFieldName + '")');
            }
        })();
        if (obj_compoundFieldName_union1_error != null) {
            obj_compoundFieldName_union1 = obj_compoundFieldName_union1_error.message;
        }
        if (obj_compoundFieldName_union0 && obj_compoundFieldName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_compoundFieldName + '")';
            message += '\n' + obj_compoundFieldName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_compoundFieldName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_controllerName = obj.controllerName;
        const path_controllerName = path + '.controllerName';
        let obj_controllerName_union0 = null;
        const obj_controllerName_union0_error = (() => {
            if (typeof obj_controllerName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_controllerName + '" (at "' + path_controllerName + '")');
            }
        })();
        if (obj_controllerName_union0_error != null) {
            obj_controllerName_union0 = obj_controllerName_union0_error.message;
        }
        let obj_controllerName_union1 = null;
        const obj_controllerName_union1_error = (() => {
            if (obj_controllerName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_controllerName + '" (at "' + path_controllerName + '")');
            }
        })();
        if (obj_controllerName_union1_error != null) {
            obj_controllerName_union1 = obj_controllerName_union1_error.message;
        }
        if (obj_controllerName_union0 && obj_controllerName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_controllerName + '")';
            message += '\n' + obj_controllerName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_controllerName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_controllingFields = obj.controllingFields;
        const path_controllingFields = path + '.controllingFields';
        if (!ArrayIsArray$1(obj_controllingFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_controllingFields + '" (at "' + path_controllingFields + '")');
        }
        for (let i = 0; i < obj_controllingFields.length; i++) {
            const obj_controllingFields_item = obj_controllingFields[i];
            const path_controllingFields_item = path_controllingFields + '[' + i + ']';
            if (typeof obj_controllingFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_controllingFields_item + '" (at "' + path_controllingFields_item + '")');
            }
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_dataType = obj.dataType;
        const path_dataType = path + '.dataType';
        if (typeof obj_dataType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
        }
        const obj_extraTypeInfo = obj.extraTypeInfo;
        const path_extraTypeInfo = path + '.extraTypeInfo';
        let obj_extraTypeInfo_union0 = null;
        const obj_extraTypeInfo_union0_error = (() => {
            if (typeof obj_extraTypeInfo !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_extraTypeInfo + '" (at "' + path_extraTypeInfo + '")');
            }
        })();
        if (obj_extraTypeInfo_union0_error != null) {
            obj_extraTypeInfo_union0 = obj_extraTypeInfo_union0_error.message;
        }
        let obj_extraTypeInfo_union1 = null;
        const obj_extraTypeInfo_union1_error = (() => {
            if (obj_extraTypeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_extraTypeInfo + '" (at "' + path_extraTypeInfo + '")');
            }
        })();
        if (obj_extraTypeInfo_union1_error != null) {
            obj_extraTypeInfo_union1 = obj_extraTypeInfo_union1_error.message;
        }
        if (obj_extraTypeInfo_union0 && obj_extraTypeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_extraTypeInfo + '")';
            message += '\n' + obj_extraTypeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_extraTypeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_filterable = obj.filterable;
        const path_filterable = path + '.filterable';
        if (typeof obj_filterable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
        }
        const obj_filteredLookupInfo = obj.filteredLookupInfo;
        const path_filteredLookupInfo = path + '.filteredLookupInfo';
        let obj_filteredLookupInfo_union0 = null;
        const obj_filteredLookupInfo_union0_error = (() => {
            const referencepath_filteredLookupInfoValidationError = validate$f(obj_filteredLookupInfo, path_filteredLookupInfo);
            if (referencepath_filteredLookupInfoValidationError !== null) {
                let message = 'Object doesn\'t match FilteredLookupInfoRepresentation (at "' + path_filteredLookupInfo + '")\n';
                message += referencepath_filteredLookupInfoValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_filteredLookupInfo_union0_error != null) {
            obj_filteredLookupInfo_union0 = obj_filteredLookupInfo_union0_error.message;
        }
        let obj_filteredLookupInfo_union1 = null;
        const obj_filteredLookupInfo_union1_error = (() => {
            if (obj_filteredLookupInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_filteredLookupInfo + '" (at "' + path_filteredLookupInfo + '")');
            }
        })();
        if (obj_filteredLookupInfo_union1_error != null) {
            obj_filteredLookupInfo_union1 = obj_filteredLookupInfo_union1_error.message;
        }
        if (obj_filteredLookupInfo_union0 && obj_filteredLookupInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_filteredLookupInfo + '")';
            message += '\n' + obj_filteredLookupInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_filteredLookupInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_highScaleNumber = obj.highScaleNumber;
        const path_highScaleNumber = path + '.highScaleNumber';
        if (typeof obj_highScaleNumber !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_highScaleNumber + '" (at "' + path_highScaleNumber + '")');
        }
        const obj_htmlFormatted = obj.htmlFormatted;
        const path_htmlFormatted = path + '.htmlFormatted';
        if (typeof obj_htmlFormatted !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_htmlFormatted + '" (at "' + path_htmlFormatted + '")');
        }
        const obj_inlineHelpText = obj.inlineHelpText;
        const path_inlineHelpText = path + '.inlineHelpText';
        let obj_inlineHelpText_union0 = null;
        const obj_inlineHelpText_union0_error = (() => {
            if (typeof obj_inlineHelpText !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_inlineHelpText + '" (at "' + path_inlineHelpText + '")');
            }
        })();
        if (obj_inlineHelpText_union0_error != null) {
            obj_inlineHelpText_union0 = obj_inlineHelpText_union0_error.message;
        }
        let obj_inlineHelpText_union1 = null;
        const obj_inlineHelpText_union1_error = (() => {
            if (obj_inlineHelpText !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_inlineHelpText + '" (at "' + path_inlineHelpText + '")');
            }
        })();
        if (obj_inlineHelpText_union1_error != null) {
            obj_inlineHelpText_union1 = obj_inlineHelpText_union1_error.message;
        }
        if (obj_inlineHelpText_union0 && obj_inlineHelpText_union1) {
            let message = 'Object doesn\'t match union (at "' + path_inlineHelpText + '")';
            message += '\n' + obj_inlineHelpText_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_inlineHelpText_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_length = obj.length;
        const path_length = path + '.length';
        if (typeof obj_length !== 'number' || (typeof obj_length === 'number' && Math.floor(obj_length) !== obj_length)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_length + '" (at "' + path_length + '")');
        }
        const obj_nameField = obj.nameField;
        const path_nameField = path + '.nameField';
        if (typeof obj_nameField !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_nameField + '" (at "' + path_nameField + '")');
        }
        const obj_polymorphicForeignKey = obj.polymorphicForeignKey;
        const path_polymorphicForeignKey = path + '.polymorphicForeignKey';
        if (typeof obj_polymorphicForeignKey !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_polymorphicForeignKey + '" (at "' + path_polymorphicForeignKey + '")');
        }
        const obj_precision = obj.precision;
        const path_precision = path + '.precision';
        if (typeof obj_precision !== 'number' || (typeof obj_precision === 'number' && Math.floor(obj_precision) !== obj_precision)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_precision + '" (at "' + path_precision + '")');
        }
        const obj_reference = obj.reference;
        const path_reference = path + '.reference';
        if (typeof obj_reference !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_reference + '" (at "' + path_reference + '")');
        }
        const obj_referenceTargetField = obj.referenceTargetField;
        const path_referenceTargetField = path + '.referenceTargetField';
        let obj_referenceTargetField_union0 = null;
        const obj_referenceTargetField_union0_error = (() => {
            if (typeof obj_referenceTargetField !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_referenceTargetField + '" (at "' + path_referenceTargetField + '")');
            }
        })();
        if (obj_referenceTargetField_union0_error != null) {
            obj_referenceTargetField_union0 = obj_referenceTargetField_union0_error.message;
        }
        let obj_referenceTargetField_union1 = null;
        const obj_referenceTargetField_union1_error = (() => {
            if (obj_referenceTargetField !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_referenceTargetField + '" (at "' + path_referenceTargetField + '")');
            }
        })();
        if (obj_referenceTargetField_union1_error != null) {
            obj_referenceTargetField_union1 = obj_referenceTargetField_union1_error.message;
        }
        if (obj_referenceTargetField_union0 && obj_referenceTargetField_union1) {
            let message = 'Object doesn\'t match union (at "' + path_referenceTargetField + '")';
            message += '\n' + obj_referenceTargetField_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_referenceTargetField_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_referenceToInfos = obj.referenceToInfos;
        const path_referenceToInfos = path + '.referenceToInfos';
        if (!ArrayIsArray$1(obj_referenceToInfos)) {
            return new TypeError('Expected "array" but received "' + typeof obj_referenceToInfos + '" (at "' + path_referenceToInfos + '")');
        }
        for (let i = 0; i < obj_referenceToInfos.length; i++) {
            const obj_referenceToInfos_item = obj_referenceToInfos[i];
            const path_referenceToInfos_item = path_referenceToInfos + '[' + i + ']';
            const referencepath_referenceToInfos_itemValidationError = validate$g(obj_referenceToInfos_item, path_referenceToInfos_item);
            if (referencepath_referenceToInfos_itemValidationError !== null) {
                let message = 'Object doesn\'t match ReferenceToInfoRepresentation (at "' + path_referenceToInfos_item + '")\n';
                message += referencepath_referenceToInfos_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_relationshipName = obj.relationshipName;
        const path_relationshipName = path + '.relationshipName';
        let obj_relationshipName_union0 = null;
        const obj_relationshipName_union0_error = (() => {
            if (typeof obj_relationshipName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
            }
        })();
        if (obj_relationshipName_union0_error != null) {
            obj_relationshipName_union0 = obj_relationshipName_union0_error.message;
        }
        let obj_relationshipName_union1 = null;
        const obj_relationshipName_union1_error = (() => {
            if (obj_relationshipName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
            }
        })();
        if (obj_relationshipName_union1_error != null) {
            obj_relationshipName_union1 = obj_relationshipName_union1_error.message;
        }
        if (obj_relationshipName_union0 && obj_relationshipName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relationshipName + '")';
            message += '\n' + obj_relationshipName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relationshipName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
        const obj_scale = obj.scale;
        const path_scale = path + '.scale';
        if (typeof obj_scale !== 'number' || (typeof obj_scale === 'number' && Math.floor(obj_scale) !== obj_scale)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_scale + '" (at "' + path_scale + '")');
        }
        const obj_searchPrefilterable = obj.searchPrefilterable;
        const path_searchPrefilterable = path + '.searchPrefilterable';
        if (typeof obj_searchPrefilterable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_searchPrefilterable + '" (at "' + path_searchPrefilterable + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
        const obj_unique = obj.unique;
        const path_unique = path + '.unique';
        if (typeof obj_unique !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_unique + '" (at "' + path_unique + '")');
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$8(input) {
    const input_controllingFields = input.controllingFields;
    ObjectFreeze$1(input_controllingFields);
    const input_filteredLookupInfo = input.filteredLookupInfo;
    if (input_filteredLookupInfo !== null && typeof input_filteredLookupInfo === 'object') {
        deepFreeze$6(input_filteredLookupInfo);
    }
    const input_referenceToInfos = input.referenceToInfos;
    for (let i = 0; i < input_referenceToInfos.length; i++) {
        const input_referenceToInfos_item = input_referenceToInfos[i];
        deepFreeze$7(input_referenceToInfos_item);
    }
    ObjectFreeze$1(input_referenceToInfos);
    ObjectFreeze$1(input);
}

function validate$i(obj, path = 'ThemeInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
            if (typeof obj_iconUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union0_error != null) {
            obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
            if (obj_iconUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union1_error != null) {
            obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
            message += '\n' + obj_iconUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_iconUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$9(input) {
    ObjectFreeze$1(input);
}

const TTL$2 = 900000;
function validate$j(obj, path = 'ObjectInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_associateEntityType = obj.associateEntityType;
        const path_associateEntityType = path + '.associateEntityType';
        let obj_associateEntityType_union0 = null;
        const obj_associateEntityType_union0_error = (() => {
            if (typeof obj_associateEntityType !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_associateEntityType + '" (at "' + path_associateEntityType + '")');
            }
        })();
        if (obj_associateEntityType_union0_error != null) {
            obj_associateEntityType_union0 = obj_associateEntityType_union0_error.message;
        }
        let obj_associateEntityType_union1 = null;
        const obj_associateEntityType_union1_error = (() => {
            if (obj_associateEntityType !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_associateEntityType + '" (at "' + path_associateEntityType + '")');
            }
        })();
        if (obj_associateEntityType_union1_error != null) {
            obj_associateEntityType_union1 = obj_associateEntityType_union1_error.message;
        }
        if (obj_associateEntityType_union0 && obj_associateEntityType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_associateEntityType + '")';
            message += '\n' + obj_associateEntityType_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_associateEntityType_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_associateParentEntity = obj.associateParentEntity;
        const path_associateParentEntity = path + '.associateParentEntity';
        let obj_associateParentEntity_union0 = null;
        const obj_associateParentEntity_union0_error = (() => {
            if (typeof obj_associateParentEntity !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_associateParentEntity + '" (at "' + path_associateParentEntity + '")');
            }
        })();
        if (obj_associateParentEntity_union0_error != null) {
            obj_associateParentEntity_union0 = obj_associateParentEntity_union0_error.message;
        }
        let obj_associateParentEntity_union1 = null;
        const obj_associateParentEntity_union1_error = (() => {
            if (obj_associateParentEntity !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_associateParentEntity + '" (at "' + path_associateParentEntity + '")');
            }
        })();
        if (obj_associateParentEntity_union1_error != null) {
            obj_associateParentEntity_union1 = obj_associateParentEntity_union1_error.message;
        }
        if (obj_associateParentEntity_union0 && obj_associateParentEntity_union1) {
            let message = 'Object doesn\'t match union (at "' + path_associateParentEntity + '")';
            message += '\n' + obj_associateParentEntity_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_associateParentEntity_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (!ArrayIsArray$1(obj_childRelationships)) {
            return new TypeError('Expected "array" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        for (let i = 0; i < obj_childRelationships.length; i++) {
            const obj_childRelationships_item = obj_childRelationships[i];
            const path_childRelationships_item = path_childRelationships + '[' + i + ']';
            const referencepath_childRelationships_itemValidationError = validate$e(obj_childRelationships_item, path_childRelationships_item);
            if (referencepath_childRelationships_itemValidationError !== null) {
                let message = 'Object doesn\'t match ChildRelationshipRepresentation (at "' + path_childRelationships_item + '")\n';
                message += referencepath_childRelationships_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_defaultRecordTypeId = obj.defaultRecordTypeId;
        const path_defaultRecordTypeId = path + '.defaultRecordTypeId';
        let obj_defaultRecordTypeId_union0 = null;
        const obj_defaultRecordTypeId_union0_error = (() => {
            if (typeof obj_defaultRecordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_defaultRecordTypeId + '" (at "' + path_defaultRecordTypeId + '")');
            }
        })();
        if (obj_defaultRecordTypeId_union0_error != null) {
            obj_defaultRecordTypeId_union0 = obj_defaultRecordTypeId_union0_error.message;
        }
        let obj_defaultRecordTypeId_union1 = null;
        const obj_defaultRecordTypeId_union1_error = (() => {
            if (obj_defaultRecordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_defaultRecordTypeId + '" (at "' + path_defaultRecordTypeId + '")');
            }
        })();
        if (obj_defaultRecordTypeId_union1_error != null) {
            obj_defaultRecordTypeId_union1 = obj_defaultRecordTypeId_union1_error.message;
        }
        if (obj_defaultRecordTypeId_union0 && obj_defaultRecordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_defaultRecordTypeId + '")';
            message += '\n' + obj_defaultRecordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_defaultRecordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_dependentFields = obj.dependentFields;
        const path_dependentFields = path + '.dependentFields';
        if (typeof obj_dependentFields !== 'object' || ArrayIsArray$1(obj_dependentFields) || obj_dependentFields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_dependentFields + '" (at "' + path_dependentFields + '")');
        }
        const obj_dependentFields_keys = ObjectKeys$1(obj_dependentFields);
        for (let i = 0; i < obj_dependentFields_keys.length; i++) {
            const key = obj_dependentFields_keys[i];
            const obj_dependentFields_prop = obj_dependentFields[key];
            const path_dependentFields_prop = path_dependentFields + '["' + key + '"]';
            if (typeof obj_dependentFields_prop !== 'object' || ArrayIsArray$1(obj_dependentFields_prop) || obj_dependentFields_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_dependentFields_prop + '" (at "' + path_dependentFields_prop + '")');
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_feedEnabled = obj.feedEnabled;
        const path_feedEnabled = path + '.feedEnabled';
        if (typeof obj_feedEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_feedEnabled + '" (at "' + path_feedEnabled + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            const referencepath_fields_propValidationError = validate$h(obj_fields_prop, path_fields_prop);
            if (referencepath_fields_propValidationError !== null) {
                let message = 'Object doesn\'t match FieldRepresentation (at "' + path_fields_prop + '")\n';
                message += referencepath_fields_propValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
            if (typeof obj_keyPrefix !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union0_error != null) {
            obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
            if (obj_keyPrefix !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union1_error != null) {
            obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
            let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
            message += '\n' + obj_keyPrefix_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_keyPrefix_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_labelPlural = obj.labelPlural;
        const path_labelPlural = path + '.labelPlural';
        if (typeof obj_labelPlural !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_labelPlural + '" (at "' + path_labelPlural + '")');
        }
        const obj_layoutable = obj.layoutable;
        const path_layoutable = path + '.layoutable';
        if (typeof obj_layoutable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_layoutable + '" (at "' + path_layoutable + '")');
        }
        const obj_mruEnabled = obj.mruEnabled;
        const path_mruEnabled = path + '.mruEnabled';
        if (typeof obj_mruEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_mruEnabled + '" (at "' + path_mruEnabled + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray$1(obj_nameFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
            const obj_nameFields_item = obj_nameFields[i];
            const path_nameFields_item = path_nameFields + '[' + i + ']';
            if (typeof obj_nameFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
            }
        }
        const obj_queryable = obj.queryable;
        const path_queryable = path + '.queryable';
        if (typeof obj_queryable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_queryable + '" (at "' + path_queryable + '")');
        }
        const obj_recordTypeInfos = obj.recordTypeInfos;
        const path_recordTypeInfos = path + '.recordTypeInfos';
        if (typeof obj_recordTypeInfos !== 'object' || ArrayIsArray$1(obj_recordTypeInfos) || obj_recordTypeInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_recordTypeInfos + '" (at "' + path_recordTypeInfos + '")');
        }
        const obj_recordTypeInfos_keys = ObjectKeys$1(obj_recordTypeInfos);
        for (let i = 0; i < obj_recordTypeInfos_keys.length; i++) {
            const key = obj_recordTypeInfos_keys[i];
            const obj_recordTypeInfos_prop = obj_recordTypeInfos[key];
            const path_recordTypeInfos_prop = path_recordTypeInfos + '["' + key + '"]';
            const referencepath_recordTypeInfos_propValidationError = validate$6(obj_recordTypeInfos_prop, path_recordTypeInfos_prop);
            if (referencepath_recordTypeInfos_propValidationError !== null) {
                let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfos_prop + '")\n';
                message += referencepath_recordTypeInfos_propValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_searchable = obj.searchable;
        const path_searchable = path + '.searchable';
        if (typeof obj_searchable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_searchable + '" (at "' + path_searchable + '")');
        }
        const obj_themeInfo = obj.themeInfo;
        const path_themeInfo = path + '.themeInfo';
        let obj_themeInfo_union0 = null;
        const obj_themeInfo_union0_error = (() => {
            const referencepath_themeInfoValidationError = validate$i(obj_themeInfo, path_themeInfo);
            if (referencepath_themeInfoValidationError !== null) {
                let message = 'Object doesn\'t match ThemeInfoRepresentation (at "' + path_themeInfo + '")\n';
                message += referencepath_themeInfoValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_themeInfo_union0_error != null) {
            obj_themeInfo_union0 = obj_themeInfo_union0_error.message;
        }
        let obj_themeInfo_union1 = null;
        const obj_themeInfo_union1_error = (() => {
            if (obj_themeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_themeInfo + '" (at "' + path_themeInfo + '")');
            }
        })();
        if (obj_themeInfo_union1_error != null) {
            obj_themeInfo_union1 = obj_themeInfo_union1_error.message;
        }
        if (obj_themeInfo_union0 && obj_themeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_themeInfo + '")';
            message += '\n' + obj_themeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_themeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$f(config) {
    return keyPrefix + 'ObjectInfoRepresentation:' + config.apiName;
}
function keyBuilderFromType$7(object) {
    const keyParams = {
        apiName: object.apiName
    };
    return keyBuilder$f(keyParams);
}
function normalize$8(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$f = function ObjectInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'associateEntityType',
                kind: 'Scalar'
            },
            {
                name: 'associateParentEntity',
                kind: 'Scalar'
            },
            {
                name: 'childRelationships',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'createable',
                kind: 'Scalar'
            },
            {
                name: 'custom',
                kind: 'Scalar'
            },
            {
                name: 'defaultRecordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'deletable',
                kind: 'Scalar'
            },
            {
                name: 'dependentFields',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'feedEnabled',
                kind: 'Scalar'
            },
            {
                name: 'fields',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'keyPrefix',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'labelPlural',
                kind: 'Scalar'
            },
            {
                name: 'layoutable',
                kind: 'Scalar'
            },
            {
                name: 'mruEnabled',
                kind: 'Scalar'
            },
            {
                name: 'nameFields',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'queryable',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeInfos',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'searchable',
                kind: 'Scalar'
            },
            {
                name: 'themeInfo',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'updateable',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$a(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$a(input) {
    const input_childRelationships = input.childRelationships;
    for (let i = 0; i < input_childRelationships.length; i++) {
        const input_childRelationships_item = input_childRelationships[i];
        deepFreeze$5(input_childRelationships_item);
    }
    ObjectFreeze$1(input_childRelationships);
    const input_dependentFields = input.dependentFields;
    const input_dependentFields_keys = Object.keys(input_dependentFields);
    const input_dependentFields_length = input_dependentFields_keys.length;
    for (let i = 0; i < input_dependentFields_length; i++) {
        const key = input_dependentFields_keys[i];
        const input_dependentFields_prop = input_dependentFields[key];
        ObjectFreeze$1(input_dependentFields_prop);
    }
    ObjectFreeze$1(input_dependentFields);
    const input_fields = input.fields;
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        deepFreeze$8(input_fields_prop);
    }
    ObjectFreeze$1(input_fields);
    const input_nameFields = input.nameFields;
    ObjectFreeze$1(input_nameFields);
    const input_recordTypeInfos = input.recordTypeInfos;
    const input_recordTypeInfos_keys = Object.keys(input_recordTypeInfos);
    const input_recordTypeInfos_length = input_recordTypeInfos_keys.length;
    for (let i = 0; i < input_recordTypeInfos_length; i++) {
        const key = input_recordTypeInfos_keys[i];
        const input_recordTypeInfos_prop = input_recordTypeInfos[key];
        deepFreeze$4(input_recordTypeInfos_prop);
    }
    ObjectFreeze$1(input_recordTypeInfos);
    const input_themeInfo = input.themeInfo;
    if (input_themeInfo !== null && typeof input_themeInfo === 'object') {
        deepFreeze$9(input_themeInfo);
    }
    ObjectFreeze$1(input);
}
const ingest$8 = function ObjectInfoRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$j(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$7(input);
    let incomingRecord = normalize$8(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$a(input);
    if (existingRecord === undefined || equals$a(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function select$g(luvio, params) {
    return select$f();
}
function keyBuilder$g(params) {
    return keyBuilder$f({
        apiName: params.urlParams.objectApiName
    });
}
function ingestSuccess$3(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$g(resourceParams);
    luvio.storeIngest(key, ingest$8, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$g(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$4(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$g(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$2);
    return errorSnapshot;
}
function createResourceRequest$a(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const getObjectInfo_ConfigPropertyNames = {
    displayName: 'getObjectInfo',
    parameters: {
        required: ['objectApiName'],
        optional: []
    }
};
function createResourceParams$6(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        }
    };
}
function coerceConfig$6(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    return coercedConfig;
}
function keyBuilder$h(luvio, config) {
    const resourceParams = createResourceParams$6(config);
    return keyBuilder$g(resourceParams);
}
function typeCheckConfig$6(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    return config;
}
function validateAdapterConfig$6(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$6(untrustedConfig);
    const config = typeCheckConfig$6(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$3(luvio, config) {
    const resourceParams = createResourceParams$6(config);
    return select$g();
}
function buildInMemorySnapshot$7(luvio, config) {
    const selector = {
        recordId: keyBuilder$h(luvio, config),
        node: adapterFragment$3(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$5(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$3(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$3(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$5(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$3(luvio, config, resourceParams, response) {
    const snapshot = ingestError$4(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$5(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$5(luvio, config, override) {
    const resourceParams = createResourceParams$6(config);
    const request = createResourceRequest$a(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$3(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$3(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$5(luvio, config, snapshot) {
    const resourceParams = createResourceParams$6(config);
    const request = createResourceRequest$a(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$3(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$3(luvio, config, resourceParams, response);
    });
}
const getObjectInfoAdapterFactory = (luvio) => function uiApi__getObjectInfo(untrustedConfig) {
    const config = validateAdapterConfig$6(untrustedConfig, getObjectInfo_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$7(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$5(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$5(luvio, config);
};

function validate$k(obj, path = 'RecordLayoutSaveOptionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_defaultValue = obj.defaultValue;
        const path_defaultValue = path + '.defaultValue';
        if (typeof obj_defaultValue !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_defaultValue + '" (at "' + path_defaultValue + '")');
        }
        const obj_isDisplayed = obj.isDisplayed;
        const path_isDisplayed = path + '.isDisplayed';
        if (typeof obj_isDisplayed !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isDisplayed + '" (at "' + path_isDisplayed + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_restHeaderName = obj.restHeaderName;
        const path_restHeaderName = path + '.restHeaderName';
        if (typeof obj_restHeaderName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_restHeaderName + '" (at "' + path_restHeaderName + '")');
        }
        const obj_soapHeaderName = obj.soapHeaderName;
        const path_soapHeaderName = path + '.soapHeaderName';
        if (typeof obj_soapHeaderName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_soapHeaderName + '" (at "' + path_soapHeaderName + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$b(input) {
    ObjectFreeze$1(input);
}

var DiscriminatorValues;
(function (DiscriminatorValues) {
    DiscriminatorValues["EmptySpace"] = "EmptySpace";
    DiscriminatorValues["ReportChart"] = "ReportChart";
    DiscriminatorValues["VisualforcePage"] = "VisualforcePage";
    DiscriminatorValues["Canvas"] = "Canvas";
    DiscriminatorValues["Field"] = "Field";
    DiscriminatorValues["CustomLink"] = "CustomLink";
})(DiscriminatorValues || (DiscriminatorValues = {}));
function validate$l(obj, path = 'AbstractRecordLayoutComponentRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        let obj_apiName_union0 = null;
        const obj_apiName_union0_error = (() => {
            if (typeof obj_apiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
        })();
        if (obj_apiName_union0_error != null) {
            obj_apiName_union0 = obj_apiName_union0_error.message;
        }
        let obj_apiName_union1 = null;
        const obj_apiName_union1_error = (() => {
            if (obj_apiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
        })();
        if (obj_apiName_union1_error != null) {
            obj_apiName_union1 = obj_apiName_union1_error.message;
        }
        if (obj_apiName_union0 && obj_apiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
            message += '\n' + obj_apiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_apiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_componentType = obj.componentType;
        const path_componentType = path + '.componentType';
        if (typeof obj_componentType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_componentType + '" (at "' + path_componentType + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$c(input) {
    ObjectFreeze$1(input);
}

function validate$m(obj, path = 'RecordLayoutItemRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_editableForNew = obj.editableForNew;
        const path_editableForNew = path + '.editableForNew';
        if (typeof obj_editableForNew !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_editableForNew + '" (at "' + path_editableForNew + '")');
        }
        const obj_editableForUpdate = obj.editableForUpdate;
        const path_editableForUpdate = path + '.editableForUpdate';
        if (typeof obj_editableForUpdate !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_editableForUpdate + '" (at "' + path_editableForUpdate + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_layoutComponents = obj.layoutComponents;
        const path_layoutComponents = path + '.layoutComponents';
        if (!ArrayIsArray$1(obj_layoutComponents)) {
            return new TypeError('Expected "array" but received "' + typeof obj_layoutComponents + '" (at "' + path_layoutComponents + '")');
        }
        for (let i = 0; i < obj_layoutComponents.length; i++) {
            const obj_layoutComponents_item = obj_layoutComponents[i];
            const path_layoutComponents_item = path_layoutComponents + '[' + i + ']';
            const referencepath_layoutComponents_itemValidationError = validate$l(obj_layoutComponents_item, path_layoutComponents_item);
            if (referencepath_layoutComponents_itemValidationError !== null) {
                let message = 'Object doesn\'t match AbstractRecordLayoutComponentRepresentation (at "' + path_layoutComponents_item + '")\n';
                message += referencepath_layoutComponents_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_lookupIdApiName = obj.lookupIdApiName;
        const path_lookupIdApiName = path + '.lookupIdApiName';
        let obj_lookupIdApiName_union0 = null;
        const obj_lookupIdApiName_union0_error = (() => {
            if (typeof obj_lookupIdApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lookupIdApiName + '" (at "' + path_lookupIdApiName + '")');
            }
        })();
        if (obj_lookupIdApiName_union0_error != null) {
            obj_lookupIdApiName_union0 = obj_lookupIdApiName_union0_error.message;
        }
        let obj_lookupIdApiName_union1 = null;
        const obj_lookupIdApiName_union1_error = (() => {
            if (obj_lookupIdApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lookupIdApiName + '" (at "' + path_lookupIdApiName + '")');
            }
        })();
        if (obj_lookupIdApiName_union1_error != null) {
            obj_lookupIdApiName_union1 = obj_lookupIdApiName_union1_error.message;
        }
        if (obj_lookupIdApiName_union0 && obj_lookupIdApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lookupIdApiName + '")';
            message += '\n' + obj_lookupIdApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lookupIdApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$d(input) {
    const input_layoutComponents = input.layoutComponents;
    for (let i = 0; i < input_layoutComponents.length; i++) {
        const input_layoutComponents_item = input_layoutComponents[i];
        deepFreeze$c(input_layoutComponents_item);
    }
    ObjectFreeze$1(input_layoutComponents);
    ObjectFreeze$1(input);
}

function validate$n(obj, path = 'RecordLayoutRowRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_layoutItems = obj.layoutItems;
        const path_layoutItems = path + '.layoutItems';
        if (!ArrayIsArray$1(obj_layoutItems)) {
            return new TypeError('Expected "array" but received "' + typeof obj_layoutItems + '" (at "' + path_layoutItems + '")');
        }
        for (let i = 0; i < obj_layoutItems.length; i++) {
            const obj_layoutItems_item = obj_layoutItems[i];
            const path_layoutItems_item = path_layoutItems + '[' + i + ']';
            const referencepath_layoutItems_itemValidationError = validate$m(obj_layoutItems_item, path_layoutItems_item);
            if (referencepath_layoutItems_itemValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutItemRepresentation (at "' + path_layoutItems_item + '")\n';
                message += referencepath_layoutItems_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$e(input) {
    const input_layoutItems = input.layoutItems;
    for (let i = 0; i < input_layoutItems.length; i++) {
        const input_layoutItems_item = input_layoutItems[i];
        deepFreeze$d(input_layoutItems_item);
    }
    ObjectFreeze$1(input_layoutItems);
    ObjectFreeze$1(input);
}

function validate$o(obj, path = 'RecordLayoutSectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collapsible = obj.collapsible;
        const path_collapsible = path + '.collapsible';
        if (typeof obj_collapsible !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_collapsible + '" (at "' + path_collapsible + '")');
        }
        const obj_columns = obj.columns;
        const path_columns = path + '.columns';
        if (typeof obj_columns !== 'number' || (typeof obj_columns === 'number' && Math.floor(obj_columns) !== obj_columns)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_columns + '" (at "' + path_columns + '")');
        }
        const obj_heading = obj.heading;
        const path_heading = path + '.heading';
        let obj_heading_union0 = null;
        const obj_heading_union0_error = (() => {
            if (typeof obj_heading !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_heading + '" (at "' + path_heading + '")');
            }
        })();
        if (obj_heading_union0_error != null) {
            obj_heading_union0 = obj_heading_union0_error.message;
        }
        let obj_heading_union1 = null;
        const obj_heading_union1_error = (() => {
            if (obj_heading !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_heading + '" (at "' + path_heading + '")');
            }
        })();
        if (obj_heading_union1_error != null) {
            obj_heading_union1 = obj_heading_union1_error.message;
        }
        if (obj_heading_union0 && obj_heading_union1) {
            let message = 'Object doesn\'t match union (at "' + path_heading + '")';
            message += '\n' + obj_heading_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_heading_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_layoutRows = obj.layoutRows;
        const path_layoutRows = path + '.layoutRows';
        if (!ArrayIsArray$1(obj_layoutRows)) {
            return new TypeError('Expected "array" but received "' + typeof obj_layoutRows + '" (at "' + path_layoutRows + '")');
        }
        for (let i = 0; i < obj_layoutRows.length; i++) {
            const obj_layoutRows_item = obj_layoutRows[i];
            const path_layoutRows_item = path_layoutRows + '[' + i + ']';
            const referencepath_layoutRows_itemValidationError = validate$n(obj_layoutRows_item, path_layoutRows_item);
            if (referencepath_layoutRows_itemValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutRowRepresentation (at "' + path_layoutRows_item + '")\n';
                message += referencepath_layoutRows_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_rows = obj.rows;
        const path_rows = path + '.rows';
        if (typeof obj_rows !== 'number' || (typeof obj_rows === 'number' && Math.floor(obj_rows) !== obj_rows)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_rows + '" (at "' + path_rows + '")');
        }
        const obj_useHeading = obj.useHeading;
        const path_useHeading = path + '.useHeading';
        if (typeof obj_useHeading !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_useHeading + '" (at "' + path_useHeading + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$f(input) {
    const input_layoutRows = input.layoutRows;
    for (let i = 0; i < input_layoutRows.length; i++) {
        const input_layoutRows_item = input_layoutRows[i];
        deepFreeze$e(input_layoutRows_item);
    }
    ObjectFreeze$1(input_layoutRows);
    ObjectFreeze$1(input);
}

function validate$p(obj, path = 'RecordLayoutRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_layoutType = obj.layoutType;
        const path_layoutType = path + '.layoutType';
        if (typeof obj_layoutType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_layoutType + '" (at "' + path_layoutType + '")');
        }
        const obj_mode = obj.mode;
        const path_mode = path + '.mode';
        if (typeof obj_mode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_mode + '" (at "' + path_mode + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
        const obj_saveOptions = obj.saveOptions;
        const path_saveOptions = path + '.saveOptions';
        if (!ArrayIsArray$1(obj_saveOptions)) {
            return new TypeError('Expected "array" but received "' + typeof obj_saveOptions + '" (at "' + path_saveOptions + '")');
        }
        for (let i = 0; i < obj_saveOptions.length; i++) {
            const obj_saveOptions_item = obj_saveOptions[i];
            const path_saveOptions_item = path_saveOptions + '[' + i + ']';
            const referencepath_saveOptions_itemValidationError = validate$k(obj_saveOptions_item, path_saveOptions_item);
            if (referencepath_saveOptions_itemValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutSaveOptionRepresentation (at "' + path_saveOptions_item + '")\n';
                message += referencepath_saveOptions_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_sections = obj.sections;
        const path_sections = path + '.sections';
        if (!ArrayIsArray$1(obj_sections)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sections + '" (at "' + path_sections + '")');
        }
        for (let i = 0; i < obj_sections.length; i++) {
            const obj_sections_item = obj_sections[i];
            const path_sections_item = path_sections + '[' + i + ']';
            const referencepath_sections_itemValidationError = validate$o(obj_sections_item, path_sections_item);
            if (referencepath_sections_itemValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutSectionRepresentation (at "' + path_sections_item + '")\n';
                message += referencepath_sections_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$i(config) {
    return keyPrefix + 'RecordLayoutRepresentation:' + config.recordTypeId + ':' + config.objectApiName + ':' + config.layoutType + ':' + config.mode;
}
function keyBuilderFromType$8(object) {
    const keyParams = {
        recordTypeId: object.recordTypeId,
        objectApiName: object.objectApiName,
        layoutType: object.layoutType,
        mode: object.mode
    };
    return keyBuilder$i(keyParams);
}
function normalize$9(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$h = function RecordLayoutRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'layoutType',
                kind: 'Scalar'
            },
            {
                name: 'mode',
                kind: 'Scalar'
            },
            {
                name: 'objectApiName',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'saveOptions',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'sections',
                kind: 'Object',
                opaque: true
            }
        ]
    };
};
function equals$b(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$g(input) {
    const input_saveOptions = input.saveOptions;
    for (let i = 0; i < input_saveOptions.length; i++) {
        const input_saveOptions_item = input_saveOptions[i];
        deepFreeze$b(input_saveOptions_item);
    }
    ObjectFreeze$1(input_saveOptions);
    const input_sections = input.sections;
    for (let i = 0; i < input_sections.length; i++) {
        const input_sections_item = input_sections[i];
        deepFreeze$f(input_sections_item);
    }
    ObjectFreeze$1(input_sections);
    ObjectFreeze$1(input);
}
const ingest$9 = function RecordLayoutRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$p(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$8(input);
    let incomingRecord = normalize$9(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$g(input);
    if (existingRecord === undefined || equals$b(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

var LayoutMode;
(function (LayoutMode) {
    LayoutMode["View"] = "View";
    LayoutMode["Edit"] = "Edit";
    LayoutMode["Create"] = "Create";
})(LayoutMode || (LayoutMode = {}));

const FIELD_ID = 'Id';
const FIELD_NAME = 'Name';
const COMPONENT_TYPE_FIELD = 'Field';
function isFieldAReferenceWithRelationshipName(objectInfo, fieldApiName) {
    const field = objectInfo.fields[fieldApiName];
    if (field === undefined) {
        return false;
    }
    // TODO - can reference===true and relationshipName===null?
    return field.reference === true && field.relationshipName !== null;
}
function getRelationshipName(objectInfo, fieldApiName) {
    // TODO RAML - fix typing so isFieldAReferenceWithRelationshipName enables calling this without `relationshipName!`
    return objectInfo.fields[fieldApiName].relationshipName;
}
function getNameField(objectInfo, fieldApiName) {
    // TODO - this logic is adopted from lds222. It searches
    // ObjectInfoRep.ReferenceToInfoRep[].nameFields[]:
    // 1. If any of the arrays are empty returns `Name`
    // 2. If `Name` is found in any array position then returns it
    // 2. Else returns ObjectInfoRep.ReferenceToInfoRep[0].nameFields[0]
    // Rationale for this is unclear and needs clarification.
    const referenceToInfos = objectInfo.fields[fieldApiName].referenceToInfos;
    if (referenceToInfos.length < 1) {
        return FIELD_NAME;
    }
    const firstReferenceNameFields = referenceToInfos[0].nameFields;
    if (firstReferenceNameFields.length < 1) {
        return FIELD_NAME;
    }
    for (let a = 0, alen = referenceToInfos.length; a < alen; a++) {
        const nameFields = referenceToInfos[a].nameFields;
        for (let b = 0, blen = nameFields.length; b < blen; b++) {
            const nameField = nameFields[b];
            if (nameField === FIELD_NAME) {
                return nameField;
            }
        }
    }
    return firstReferenceNameFields[0];
}
function getQualifiedFieldApiNamesFromLayout(layout, objectInfo) {
    const qualifiedFieldNames = [];
    for (let a = 0, alen = layout.sections.length; a < alen; a++) {
        const section = layout.sections[a];
        for (let b = 0, blen = section.layoutRows.length; b < blen; b++) {
            const row = section.layoutRows[b];
            for (let c = 0, clen = row.layoutItems.length; c < clen; c++) {
                const item = row.layoutItems[c];
                for (let d = 0, dlen = item.layoutComponents.length; d < dlen; d++) {
                    const component = item.layoutComponents[d];
                    const { apiName } = component;
                    if (apiName && component.componentType === COMPONENT_TYPE_FIELD) {
                        if (isFieldAReferenceWithRelationshipName(objectInfo, apiName)) {
                            const relationshipFieldApiName = getRelationshipName(objectInfo, apiName);
                            // By default, include the "Id" field on spanning records that are on the layout.
                            qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${FIELD_ID}`);
                            const nameField = getNameField(objectInfo, apiName);
                            qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${nameField}`);
                        }
                        qualifiedFieldNames.push(`${objectInfo.apiName}.${component.apiName}`);
                    }
                }
            }
        }
    }
    return qualifiedFieldNames;
}

function validate$q(obj, path = 'RecordLayoutSectionUserStateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collapsed = obj.collapsed;
        const path_collapsed = path + '.collapsed';
        if (typeof obj_collapsed !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_collapsed + '" (at "' + path_collapsed + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$h(input) {
    ObjectFreeze$1(input);
}

function validate$r(obj, path = 'RecordLayoutUserStateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_sectionUserStates = obj.sectionUserStates;
        const path_sectionUserStates = path + '.sectionUserStates';
        if (typeof obj_sectionUserStates !== 'object' || ArrayIsArray$1(obj_sectionUserStates) || obj_sectionUserStates === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates + '" (at "' + path_sectionUserStates + '")');
        }
        const obj_sectionUserStates_keys = ObjectKeys$1(obj_sectionUserStates);
        for (let i = 0; i < obj_sectionUserStates_keys.length; i++) {
            const key = obj_sectionUserStates_keys[i];
            const obj_sectionUserStates_prop = obj_sectionUserStates[key];
            const path_sectionUserStates_prop = path_sectionUserStates + '["' + key + '"]';
            const referencepath_sectionUserStates_propValidationError = validate$q(obj_sectionUserStates_prop, path_sectionUserStates_prop);
            if (referencepath_sectionUserStates_propValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutSectionUserStateRepresentation (at "' + path_sectionUserStates_prop + '")\n';
                message += referencepath_sectionUserStates_propValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
        const obj_layoutType = obj.layoutType;
        const path_layoutType = path + '.layoutType';
        if (typeof obj_layoutType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_layoutType + '" (at "' + path_layoutType + '")');
        }
        const obj_mode = obj.mode;
        const path_mode = path + '.mode';
        if (typeof obj_mode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_mode + '" (at "' + path_mode + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$j(config) {
    return keyPrefix + 'RecordLayoutUserStateRepresentation:' + config.recordTypeId + ':' + config.apiName + ':' + config.layoutType + ':' + config.mode;
}
function keyBuilderFromType$9(object) {
    const keyParams = {
        recordTypeId: object.recordTypeId,
        apiName: object.apiName,
        layoutType: object.layoutType,
        mode: object.mode
    };
    return keyBuilder$j(keyParams);
}
function normalize$a(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$i = function RecordLayoutUserStateRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'apiName',
            'recordTypeId',
            'layoutType',
            'mode'
        ],
        selections: [
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'sectionUserStates',
                kind: 'Object',
                opaque: true
            }
        ]
    };
};
function equals$c(existing, incoming) {
    if (JSONStringify$1(incoming) !== JSONStringify$1(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$i(input) {
    const input_sectionUserStates = input.sectionUserStates;
    const input_sectionUserStates_keys = Object.keys(input_sectionUserStates);
    const input_sectionUserStates_length = input_sectionUserStates_keys.length;
    for (let i = 0; i < input_sectionUserStates_length; i++) {
        const key = input_sectionUserStates_keys[i];
        const input_sectionUserStates_prop = input_sectionUserStates[key];
        deepFreeze$h(input_sectionUserStates_prop);
    }
    ObjectFreeze$1(input_sectionUserStates);
    ObjectFreeze$1(input);
}
const ingest$a = function RecordLayoutUserStateRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$r(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$9(input);
    let incomingRecord = normalize$a(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$i(input);
    if (existingRecord === undefined || equals$c(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

const TTL$3 = 900000;
function validate$s(obj, path = 'RecordUiRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_layoutUserStates = obj.layoutUserStates;
        const path_layoutUserStates = path + '.layoutUserStates';
        if (typeof obj_layoutUserStates !== 'object' || ArrayIsArray$1(obj_layoutUserStates) || obj_layoutUserStates === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_layoutUserStates + '" (at "' + path_layoutUserStates + '")');
        }
        const obj_layoutUserStates_keys = ObjectKeys$1(obj_layoutUserStates);
        for (let i = 0; i < obj_layoutUserStates_keys.length; i++) {
            const key = obj_layoutUserStates_keys[i];
            const obj_layoutUserStates_prop = obj_layoutUserStates[key];
            const path_layoutUserStates_prop = path_layoutUserStates + '["' + key + '"]';
            if (typeof obj_layoutUserStates_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_layoutUserStates_prop + '" (at "' + path_layoutUserStates_prop + '")');
            }
        }
        const obj_layouts = obj.layouts;
        const path_layouts = path + '.layouts';
        if (typeof obj_layouts !== 'object' || ArrayIsArray$1(obj_layouts) || obj_layouts === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_layouts + '" (at "' + path_layouts + '")');
        }
        const obj_layouts_keys = ObjectKeys$1(obj_layouts);
        for (let i = 0; i < obj_layouts_keys.length; i++) {
            const key = obj_layouts_keys[i];
            const obj_layouts_prop = obj_layouts[key];
            const path_layouts_prop = path_layouts + '["' + key + '"]';
            if (typeof obj_layouts_prop !== 'object' || ArrayIsArray$1(obj_layouts_prop) || obj_layouts_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop + '" (at "' + path_layouts_prop + '")');
            }
            const obj_layouts_prop_keys = ObjectKeys$1(obj_layouts_prop);
            for (let i = 0; i < obj_layouts_prop_keys.length; i++) {
                const key = obj_layouts_prop_keys[i];
                const obj_layouts_prop_prop = obj_layouts_prop[key];
                const path_layouts_prop_prop = path_layouts_prop + '["' + key + '"]';
                if (typeof obj_layouts_prop_prop !== 'object' || ArrayIsArray$1(obj_layouts_prop_prop) || obj_layouts_prop_prop === null) {
                    return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop + '" (at "' + path_layouts_prop_prop + '")');
                }
                const obj_layouts_prop_prop_keys = ObjectKeys$1(obj_layouts_prop_prop);
                for (let i = 0; i < obj_layouts_prop_prop_keys.length; i++) {
                    const key = obj_layouts_prop_prop_keys[i];
                    const obj_layouts_prop_prop_prop = obj_layouts_prop_prop[key];
                    const path_layouts_prop_prop_prop = path_layouts_prop_prop + '["' + key + '"]';
                    if (typeof obj_layouts_prop_prop_prop !== 'object' || ArrayIsArray$1(obj_layouts_prop_prop_prop) || obj_layouts_prop_prop_prop === null) {
                        return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop_prop + '" (at "' + path_layouts_prop_prop_prop + '")');
                    }
                    const obj_layouts_prop_prop_prop_keys = ObjectKeys$1(obj_layouts_prop_prop_prop);
                    for (let i = 0; i < obj_layouts_prop_prop_prop_keys.length; i++) {
                        const key = obj_layouts_prop_prop_prop_keys[i];
                        const obj_layouts_prop_prop_prop_prop = obj_layouts_prop_prop_prop[key];
                        const path_layouts_prop_prop_prop_prop = path_layouts_prop_prop_prop + '["' + key + '"]';
                        if (typeof obj_layouts_prop_prop_prop_prop !== 'object') {
                            return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop_prop_prop + '" (at "' + path_layouts_prop_prop_prop_prop + '")');
                        }
                    }
                }
            }
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object' || ArrayIsArray$1(obj_records) || obj_records === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        const obj_records_keys = ObjectKeys$1(obj_records);
        for (let i = 0; i < obj_records_keys.length; i++) {
            const key = obj_records_keys[i];
            const obj_records_prop = obj_records[key];
            const path_records_prop = path_records + '["' + key + '"]';
            if (typeof obj_records_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_prop + '" (at "' + path_records_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$b(input, existing, path, luvio, store, timestamp) {
    const input_layoutUserStates = input.layoutUserStates;
    const input_layoutUserStates_id = path.fullPath + '__layoutUserStates';
    const input_layoutUserStates_keys = Object.keys(input_layoutUserStates);
    const input_layoutUserStates_length = input_layoutUserStates_keys.length;
    for (let i = 0; i < input_layoutUserStates_length; i++) {
        const key = input_layoutUserStates_keys[i];
        const input_layoutUserStates_prop = input_layoutUserStates[key];
        const input_layoutUserStates_prop_id = input_layoutUserStates_id + '__' + key;
        input_layoutUserStates[key] = ingest$a(input_layoutUserStates_prop, {
            fullPath: input_layoutUserStates_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    const input_layouts = input.layouts;
    const input_layouts_id = path.fullPath + '__layouts';
    const input_layouts_keys = Object.keys(input_layouts);
    const input_layouts_length = input_layouts_keys.length;
    for (let i = 0; i < input_layouts_length; i++) {
        const key = input_layouts_keys[i];
        const input_layouts_prop = input_layouts[key];
        const input_layouts_prop_id = input_layouts_id + '__' + key;
        const input_layouts_prop_keys = Object.keys(input_layouts_prop);
        const input_layouts_prop_length = input_layouts_prop_keys.length;
        for (let i = 0; i < input_layouts_prop_length; i++) {
            const key = input_layouts_prop_keys[i];
            const input_layouts_prop_prop = input_layouts_prop[key];
            const input_layouts_prop_prop_id = input_layouts_prop_id + '__' + key;
            const input_layouts_prop_prop_keys = Object.keys(input_layouts_prop_prop);
            const input_layouts_prop_prop_length = input_layouts_prop_prop_keys.length;
            for (let i = 0; i < input_layouts_prop_prop_length; i++) {
                const key = input_layouts_prop_prop_keys[i];
                const input_layouts_prop_prop_prop = input_layouts_prop_prop[key];
                const input_layouts_prop_prop_prop_id = input_layouts_prop_prop_id + '__' + key;
                const input_layouts_prop_prop_prop_keys = Object.keys(input_layouts_prop_prop_prop);
                const input_layouts_prop_prop_prop_length = input_layouts_prop_prop_prop_keys.length;
                for (let i = 0; i < input_layouts_prop_prop_prop_length; i++) {
                    const key = input_layouts_prop_prop_prop_keys[i];
                    const input_layouts_prop_prop_prop_prop = input_layouts_prop_prop_prop[key];
                    const input_layouts_prop_prop_prop_prop_id = input_layouts_prop_prop_prop_id + '__' + key;
                    input_layouts_prop_prop_prop[key] = ingest$9(input_layouts_prop_prop_prop_prop, {
                        fullPath: input_layouts_prop_prop_prop_prop_id,
                        propertyName: key,
                        parent: {
                            data: input,
                            key: path.fullPath,
                            existing: existing,
                        }
                    }, luvio, store, timestamp);
                }
            }
        }
    }
    const input_objectInfos = input.objectInfos;
    const input_objectInfos_id = path.fullPath + '__objectInfos';
    const input_objectInfos_keys = Object.keys(input_objectInfos);
    const input_objectInfos_length = input_objectInfos_keys.length;
    for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$8(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    const input_records_keys = Object.keys(input_records);
    const input_records_length = input_records_keys.length;
    for (let i = 0; i < input_records_length; i++) {
        const key = input_records_keys[i];
        const input_records_prop = input_records[key];
        const input_records_prop_id = input_records_id + '__' + key;
        input_records[key] = ingest$4(input_records_prop, {
            fullPath: input_records_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
function equals$d(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_layoutUserStates = existing.layoutUserStates;
    const incoming_layoutUserStates = incoming.layoutUserStates;
    const equals_layoutUserStates_props = equalsObject(existing_layoutUserStates, incoming_layoutUserStates, (existing_layoutUserStates_prop, incoming_layoutUserStates_prop) => {
        if (!(existing_layoutUserStates_prop.__ref === incoming_layoutUserStates_prop.__ref)) {
            return false;
        }
    });
    if (equals_layoutUserStates_props === false) {
        return false;
    }
    const existing_layouts = existing.layouts;
    const incoming_layouts = incoming.layouts;
    const equals_layouts_props = equalsObject(existing_layouts, incoming_layouts, (existing_layouts_prop, incoming_layouts_prop) => {
        const equals_layouts_props = equalsObject(existing_layouts_prop, incoming_layouts_prop, (existing_layouts_prop_prop, incoming_layouts_prop_prop) => {
            const equals_layouts_props = equalsObject(existing_layouts_prop_prop, incoming_layouts_prop_prop, (existing_layouts_prop_prop_prop, incoming_layouts_prop_prop_prop) => {
                const equals_layouts_props = equalsObject(existing_layouts_prop_prop_prop, incoming_layouts_prop_prop_prop, (existing_layouts_prop_prop_prop_prop, incoming_layouts_prop_prop_prop_prop) => {
                    if (!(existing_layouts_prop_prop_prop_prop.__ref === incoming_layouts_prop_prop_prop_prop.__ref)) {
                        return false;
                    }
                });
                if (equals_layouts_props === false) {
                    return false;
                }
            });
            if (equals_layouts_props === false) {
                return false;
            }
        });
        if (equals_layouts_props === false) {
            return false;
        }
    });
    if (equals_layouts_props === false) {
        return false;
    }
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_props = equalsObject(existing_records, incoming_records, (existing_records_prop, incoming_records_prop) => {
        if (!(existing_records_prop.__ref === incoming_records_prop.__ref)) {
            return false;
        }
    });
    if (equals_records_props === false) {
        return false;
    }
    return true;
}
const ingest$b = function RecordUiRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$s(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$b(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$d(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function createResourceRequest$b(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/record-ui/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getRecordId18Array(value) {
    const valueArray = isArray(value) ? value : [value];
    const array = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getRecordId18(item);
        if (apiName === undefined) {
            return undefined;
        }
        push.call(array, apiName);
    }
    if (array.length === 0) {
        return undefined;
    }
    return dedupe(array).sort();
}

function coerceConfig$7(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const childRelationships = config.childRelationships;
    if (childRelationships !== undefined) {
        coercedConfig.childRelationships = childRelationships;
    }
    const formFactor = config.formFactor;
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const layoutTypes = toSortedStringArray(config.layoutTypes);
    if (layoutTypes !== undefined) {
        coercedConfig.layoutTypes = layoutTypes;
    }
    const modes = toSortedStringArray(config.modes);
    if (modes !== undefined) {
        coercedConfig.modes = modes;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const updateMru = config.updateMru;
    if (updateMru !== undefined) {
        coercedConfig.updateMru = updateMru;
    }
    return coercedConfig;
}
function typeCheckConfig$7(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_childRelationships = untrustedConfig.childRelationships;
    if (ArrayIsArray(untrustedConfig_childRelationships)) {
        const untrustedConfig_childRelationships_array = [];
        for (let i = 0, arrayLength = untrustedConfig_childRelationships.length; i < arrayLength; i++) {
            const untrustedConfig_childRelationships_item = untrustedConfig_childRelationships[i];
            if (typeof untrustedConfig_childRelationships_item === 'string') {
                untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);
            }
        }
        config.childRelationships = untrustedConfig_childRelationships_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_layoutTypes = untrustedConfig.layoutTypes;
    if (ArrayIsArray(untrustedConfig_layoutTypes)) {
        const untrustedConfig_layoutTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_layoutTypes.length; i < arrayLength; i++) {
            const untrustedConfig_layoutTypes_item = untrustedConfig_layoutTypes[i];
            if (typeof untrustedConfig_layoutTypes_item === 'string') {
                untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);
            }
        }
        config.layoutTypes = untrustedConfig_layoutTypes_array;
    }
    const untrustedConfig_modes = untrustedConfig.modes;
    if (ArrayIsArray(untrustedConfig_modes)) {
        const untrustedConfig_modes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_modes.length; i < arrayLength; i++) {
            const untrustedConfig_modes_item = untrustedConfig_modes[i];
            if (typeof untrustedConfig_modes_item === 'string') {
                untrustedConfig_modes_array.push(untrustedConfig_modes_item);
            }
        }
        config.modes = untrustedConfig_modes_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_updateMru = untrustedConfig.updateMru;
    if (typeof untrustedConfig_updateMru === 'boolean') {
        config.updateMru = untrustedConfig_updateMru;
    }
    return config;
}
function validateAdapterConfig$7(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$7(untrustedConfig);
    const config = typeCheckConfig$7(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const layoutSelections = select$h();
const objectInfoPathSelection = select$f();
const layoutUserStatePathSelector = select$i();
function buildRecordUiSelector(recordDefs, layoutTypes, modes, recordOptionalFields) {
    const layoutTypeSelections = [];
    for (let i = 0, len = layoutTypes.length; i < len; i += 1) {
        const layoutType = layoutTypes[i];
        const modeSelections = [];
        const sel = {
            kind: 'Object',
            name: layoutType,
            selections: modeSelections,
        };
        for (let m = 0; m < modes.length; m += 1) {
            const mode = modes[m];
            const modeSel = {
                kind: 'Link',
                name: mode,
                fragment: layoutSelections,
            };
            push.call(modeSelections, modeSel);
        }
        push.call(layoutTypeSelections, sel);
    }
    const recordLayoutSelections = [];
    const recordSelections = [];
    for (let i = 0, len = recordDefs.length; i < len; i += 1) {
        const { recordId, recordData } = recordDefs[i];
        push.call(recordLayoutSelections, {
            kind: 'Object',
            name: recordData.apiName,
            required: false,
            map: true,
            selections: layoutTypeSelections,
        });
        const optionalFields = recordOptionalFields[recordId];
        const fields = extractFields(recordData);
        push.call(recordSelections, {
            kind: 'Link',
            name: recordId,
            fragment: {
                kind: 'Fragment',
                selections: buildSelectionFromFields(fields, optionalFields),
                private: ['eTag', 'weakEtag'],
            },
        });
    }
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            {
                kind: 'Link',
                name: 'layoutUserStates',
                map: true,
                fragment: layoutUserStatePathSelector,
            },
            {
                kind: 'Object',
                name: 'layouts',
                selections: recordLayoutSelections,
            },
            {
                kind: 'Link',
                name: 'objectInfos',
                map: true,
                fragment: objectInfoPathSelection,
            },
            {
                name: 'records',
                kind: 'Object',
                selections: recordSelections,
            },
        ],
    };
}

function getMissingRecordLookupFields(record, objectInfo) {
    const lookupFields = {};
    const { apiName, fields: recordFields } = record;
    const { fields: objectInfoFields } = objectInfo;
    const objectInfoFieldNames = keys(objectInfoFields);
    for (let i = 0, len = objectInfoFieldNames.length; i < len; i += 1) {
        const fieldName = objectInfoFieldNames[i];
        const field = objectInfoFields[fieldName];
        const { relationshipName } = field;
        if (relationshipName === null) {
            continue;
        }
        const recordFieldValue = recordFields[relationshipName];
        // Only interested in record fields that are present and that are null
        if (recordFieldValue === undefined || recordFieldValue.value !== null) {
            continue;
        }
        // Include the Id field. Ex: Opportunity.Account.Id, Opportunity.relation1__r.Id
        const idFieldName = `${apiName}.${relationshipName}.Id`;
        lookupFields[idFieldName] = true;
        const nameField = `${apiName}.${relationshipName}.${getNameField(objectInfo, fieldName)}`;
        lookupFields[nameField] = true;
    }
    return keys(lookupFields);
}
function getRecordUiMissingRecordLookupFields(recordUi) {
    const { records, objectInfos } = recordUi;
    const recordLookupFields = {};
    const recordIds = keys(records);
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordData = records[recordId];
        const { apiName } = recordData;
        const objectInfo = objectInfos[apiName];
        recordLookupFields[recordId] = getMissingRecordLookupFields(recordData, objectInfo);
    }
    return recordLookupFields;
}

// Custom adapter config due to `unsupported` items
const GET_RECORDUI_ADAPTER_CONFIG = {
    displayName: 'getRecordUi',
    parameters: {
        required: ['recordIds', 'layoutTypes', 'modes'],
        optional: ['optionalFields'],
        unsupported: [
            'formFactor',
            'childRelationships',
            'pageSize',
            'updateMru',
        ],
    },
};
function buildCachedSelectorKey(key) {
    return `${key}__selector`;
}
function eachLayout(recordUi, cb) {
    const { layouts } = recordUi;
    const layoutApiNames = keys(layouts);
    for (let a = 0, len = layoutApiNames.length; a < len; a += 1) {
        const apiName = layoutApiNames[a];
        const apiNameData = layouts[apiName];
        const recordTypeIds = keys(apiNameData);
        for (let b = 0, recordTypeIdsLen = recordTypeIds.length; b < recordTypeIdsLen; b += 1) {
            const recordTypeId = recordTypeIds[b];
            const recordTypeData = apiNameData[recordTypeId];
            const layoutTypes = keys(recordTypeData);
            for (let c = 0, layoutTypesLen = layoutTypes.length; c < layoutTypesLen; c += 1) {
                const layoutType = layoutTypes[c];
                const layoutTypeData = recordTypeData[layoutType];
                const modes = keys(layoutTypeData);
                for (let d = 0, modesLen = modes.length; d < modesLen; d += 1) {
                    const mode = modes[d];
                    const layout = layoutTypeData[mode];
                    cb(apiName, recordTypeId, layout);
                }
            }
        }
    }
}
function collectRecordDefs(resp, recordIds) {
    const recordDefs = [];
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordData = resp.records[recordId];
        push.call(recordDefs, {
            recordId,
            recordData,
            recordTypeId: getRecordTypeId(recordData),
        });
    }
    return recordDefs;
}
function keyBuilder$k(recordIds, layoutTypes, modes, optionalFields) {
    const joinedRecordIds = recordIds.sort().join(',');
    const joinedOptionalFields = optionalFields.sort().join(',');
    const joinedLayoutTypes = layoutTypes.sort().join(',');
    const joinedModes = modes.sort().join(',');
    return `${keyPrefix}RecordUiRepresentation:${joinedRecordIds}:${joinedLayoutTypes}:${joinedModes}:${joinedOptionalFields}`;
}
function buildSnapshotRefresh$3(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$6(luvio, config),
    };
}
function buildInMemorySnapshot$8(luvio, config) {
    const { recordIds, layoutTypes, modes, optionalFields } = config;
    const key = keyBuilder$k(recordIds, layoutTypes, modes, optionalFields);
    const cachedSelectorKey = buildCachedSelectorKey(key);
    const cacheSel = luvio.storeLookup({
        recordId: cachedSelectorKey,
        node: {
            kind: 'Fragment',
            private: [],
            opaque: true,
        },
        variables: {},
    }, 
    // TODO - W-9051409 - today makeDurable environment needs a refresh set for
    // "resolveUnfulfilledSnapshot" override to work properly, but once this work
    // item is done we won't have "resolveUnfulfilledSnapshot" anymore and we
    // do not need to pass in a refresh here
    buildSnapshotRefresh$3(luvio, config));
    if (isFulfilledSnapshot(cacheSel)) {
        const cachedSelector = cacheSel.data;
        const cacheData = luvio.storeLookup(cachedSelector, buildSnapshotRefresh$3(luvio, config));
        // CACHE HIT or unfulfilled returns snapshot
        if (luvio.snapshotAvailable(cacheData) || isUnfulfilledSnapshot(cacheData)) {
            return cacheData;
        }
    }
    // if getting selector results in unfulfilled snapshot return that
    if (isUnfulfilledSnapshot(cacheSel)) {
        return cacheSel;
    }
    return null;
}
function markRecordUiNulledOutLookupFields(recordLookupFields, recordNodes) {
    for (let i = 0, len = recordNodes.length; i < len; i++) {
        const recordId = recordNodes[i].data.id;
        if (recordLookupFields[recordId] !== undefined) {
            markNulledOutRequiredFields(recordNodes[i], recordLookupFields[recordId]);
        }
    }
}
function markRecordUiOptionalFields(optionalFields, recordLookupFields, recordNodes) {
    for (let i = 0, len = recordNodes.length; i < len; i++) {
        const recordId = recordNodes[i].data.id;
        if (optionalFields.length > 0 || recordLookupFields[recordId] !== undefined) {
            markMissingOptionalFields(recordNodes[i], [
                ...optionalFields,
                ...recordLookupFields[recordId],
            ]);
        }
    }
}
function prepareRequest$2(luvio, config) {
    const { recordIds, layoutTypes, modes, optionalFields } = config;
    const key = keyBuilder$k(recordIds, layoutTypes, modes, optionalFields);
    const selectorKey = buildCachedSelectorKey(key);
    const resourceRequest = createResourceRequest$b({
        urlParams: {
            recordIds,
        },
        queryParams: {
            layoutTypes,
            modes,
            optionalFields: dedupe(optionalFields).sort(),
        },
    });
    return { key, selectorKey, resourceRequest };
}
function onResourceResponseSuccess$4(luvio, config, selectorKey, key, responseBody) {
    const { recordIds, layoutTypes, modes, optionalFields } = config;
    // TODO fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    eachLayout(responseBody, (apiName, recordTypeId, layout) => {
        if (layout.id === null) {
            return;
        }
        const layoutUserState = responseBody.layoutUserStates[layout.id];
        // Temporary hack since we can't match keys from getLayoutUserState response
        // to record ui's layout users states.
        if (layoutUserState === undefined) {
            return;
        }
        layoutUserState.apiName = apiName;
        layoutUserState.recordTypeId = recordTypeId;
        layoutUserState.mode = layout.mode;
        layoutUserState.layoutType = layout.layoutType;
    });
    const recordLookupFields = getRecordUiMissingRecordLookupFields(responseBody);
    const selPath = buildRecordUiSelector(collectRecordDefs(responseBody, recordIds), layoutTypes, modes, recordLookupFields);
    const sel = {
        recordId: key,
        node: selPath,
        variables: {},
    };
    luvio.storePublish(selectorKey, sel);
    luvio.storeIngest(key, ingest$b, responseBody);
    // During ingestion, only valid records are stored.
    const recordNodes = [];
    const validRecordIds = [];
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordKey = keyBuilder$2({ recordId });
        const node = luvio.getNode(recordKey);
        if (isGraphNode(node)) {
            recordNodes.push(node);
            validRecordIds.push(recordId);
        }
    }
    markRecordUiNulledOutLookupFields(recordLookupFields, recordNodes);
    markRecordUiOptionalFields(optionalFields, recordLookupFields, recordNodes);
    publishDependencies(luvio, validRecordIds, [key, selectorKey]);
    const snapshot = luvio.storeLookup(sel, buildSnapshotRefresh$3(luvio, config));
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$4(luvio, config, selectorKey, key, err) {
    const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$3(luvio, config));
    luvio.storeIngestError(key, errorSnapshot, TTL$3);
    luvio.storeBroadcast();
    const { status } = err;
    if (status === 404) {
        const sel = {
            recordId: key,
            node: {
                kind: 'Fragment',
                private: [],
                opaque: true,
            },
            variables: {},
        };
        luvio.storePublish(selectorKey, sel);
        return luvio.storeLookup(sel, buildSnapshotRefresh$3(luvio, config));
    }
    return errorSnapshot;
}
function isSelector(data) {
    return data.node !== undefined;
}
function resolveUnfulfilledSnapshot$6(luvio, config, snapshot) {
    const { resourceRequest, key, selectorKey } = prepareRequest$2(luvio, config);
    // In default environment resolving an unfulfilled snapshot is just hitting the network
    // with the given ResourceRequest (so record-ui in this case).  In durable environment
    // resolving an unfulfilled snapshot will first attempt to read the missing cache keys
    // from the given unfulfilled snapshot (a record-ui snapshot or selector snapshot in this
    // case) and build a fulfilled snapshot from that if those cache keys are present, otherwise
    // it hits the network with the given resource request.  Usually the ResourceRequest and the
    // unfulfilled snapshot are for the same response Type, but this adapter is special (it
    // stores its own selectors in the store), and so our use of resolveUnfulfilledSnapshot
    // is special (polymorphic response, could either be a record-ui representation or a
    // selector).
    return luvio.resolveUnfulfilledSnapshot(resourceRequest, snapshot).then((response) => {
        const { body } = response;
        // if the response is a selector then we can attempt to build a snapshot
        // with that selector
        if (isSelector(body)) {
            const dataSnapshot = luvio.storeLookup(body, buildSnapshotRefresh$3(luvio, config));
            if (luvio.snapshotAvailable(dataSnapshot)) {
                return dataSnapshot;
            }
            if (isUnfulfilledSnapshot(dataSnapshot)) {
                return resolveUnfulfilledSnapshot$6(luvio, config, dataSnapshot);
            }
            return buildNetworkSnapshot$6(luvio, config);
        }
        // otherwise it's a record-ui response
        return onResourceResponseSuccess$4(luvio, config, selectorKey, key, body);
    }, (err) => {
        return onResourceResponseError$4(luvio, config, selectorKey, key, err);
    });
}
function buildNetworkSnapshot$6(luvio, config) {
    const { key, resourceRequest, selectorKey } = prepareRequest$2(luvio, config);
    return luvio.dispatchResourceRequest(resourceRequest).then((response) => {
        return onResourceResponseSuccess$4(luvio, config, selectorKey, key, response.body);
    }, (err) => {
        return onResourceResponseError$4(luvio, config, selectorKey, key, err);
    });
}
function publishDependencies(luvio, recordIds, depKeys) {
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordDepKey = depenpendencyKeyBuilder({ recordId: recordIds[i] });
        const dependencies = create(null);
        for (let j = 0, len = depKeys.length; j < len; j++) {
            dependencies[depKeys[j]] = true;
        }
        const node = luvio.getNode(recordDepKey);
        if (isGraphNode(node)) {
            const recordDeps = node.retrieve();
            assign(dependencies, recordDeps);
        }
        luvio.storePublish(recordDepKey, dependencies);
    }
}
function coerceConfigWithDefaults(untrustedConfig) {
    const config = validateAdapterConfig$7(untrustedConfig, GET_RECORDUI_ADAPTER_CONFIG);
    if (config === null) {
        return null;
    }
    const { layoutTypes, modes } = config;
    // custom config validation
    if (layoutTypes === undefined || modes === undefined) {
        return null;
    }
    return {
        ...config,
        layoutTypes: layoutTypes,
        modes: modes,
        optionalFields: config.optionalFields === undefined ? [] : config.optionalFields,
    };
}
const factory$3 = (luvio) => function UiApi__getRecordUi(untrustedConfig) {
    // standard config validation and coercion
    const config = coerceConfigWithDefaults(untrustedConfig);
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$8(luvio, config);
    // if snapshot is null go right to network
    if (cacheSnapshot === null) {
        return buildNetworkSnapshot$6(luvio, config);
    }
    if (isUnfulfilledSnapshot(cacheSnapshot)) {
        return resolveUnfulfilledSnapshot$6(luvio, config, cacheSnapshot);
    }
    // if we got here then we can just return the in-memory snapshot
    return cacheSnapshot;
};

const DEFAULT_MODE = LayoutMode.View;
const layoutSelections$1 = select$h();
function buildSnapshotRefresh$4(luvio, config) {
    return {
        config,
        resolve: () => refresh(luvio, config),
    };
}
function refresh(luvio, config) {
    const { recordId, layoutTypes, modes: configModes, optionalFields: configOptionalFields, } = config;
    const modes = configModes === undefined ? [DEFAULT_MODE] : configModes;
    const optionalFields = configOptionalFields === undefined ? [] : configOptionalFields;
    const recordUiConfig = {
        recordIds: [recordId],
        layoutTypes,
        modes,
        optionalFields,
    };
    return buildNetworkSnapshot$6(luvio, recordUiConfig).then((snapshot) => {
        const refresh = buildSnapshotRefresh$4(luvio, config);
        if (isErrorSnapshot(snapshot)) {
            return luvio.errorSnapshot(snapshot.error, refresh);
        }
        if (isUnfulfilledSnapshot(snapshot)) {
            throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys(snapshot.missingPaths)}`);
        }
        const { data } = snapshot;
        if (data === undefined) {
            throw new Error(`RecordUi adapter resolved with a ${snapshot.state} snapshot with undefined data`);
        }
        const { layoutMap, objectInfo } = getLayoutMapAndObjectInfo(recordId, data);
        const fields = getFieldsFromLayoutMap(layoutMap, objectInfo);
        return buildInMemorySnapshot$1(luvio, {
            recordId,
            fields,
            modes,
        }, refresh);
    });
}
// Makes a request directly to /record-ui/{recordIds}
function fetchRecordLayout(luvio, refresh, recordId, layoutTypes, modes, optionalFields) {
    const recordUiConfig = {
        recordIds: [recordId],
        layoutTypes,
        modes,
        optionalFields,
    };
    const recordUiAdapter = factory$3(luvio);
    const recordUiSnapshotOrPromise = recordUiAdapter(recordUiConfig);
    if (isPromise$1(recordUiSnapshotOrPromise)) {
        return recordUiSnapshotOrPromise.then((snapshot) => {
            return processRecordUiRepresentation(luvio, refresh, recordId, modes, snapshot, optionalFields);
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        if (recordUiSnapshotOrPromise === null) {
            throw new Error('RecordUi adapter synchronously resolved with a null snapshot');
        }
    }
    return processRecordUiRepresentation(luvio, refresh, recordId, modes, recordUiSnapshotOrPromise, optionalFields);
}
function getLayoutMapAndObjectInfo(recordId, data) {
    const { objectInfos, layouts, records } = data;
    const record = records[recordId];
    const { apiName } = record;
    const objectInfo = objectInfos[apiName];
    const recordTypeId = getRecordTypeId(record);
    const layoutMap = layouts[apiName][recordTypeId];
    return {
        layoutMap,
        objectInfo,
    };
}
function processRecordUiRepresentation(luvio, refresh, recordId, modes, snapshot, optionalFields) {
    if (isErrorSnapshot(snapshot)) {
        return luvio.errorSnapshot(snapshot.error, refresh);
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys(snapshot.missingPaths)}`);
    }
    const { data } = snapshot;
    if (data === undefined) {
        throw new Error(`RecordUi adapter resolved with a ${snapshot.state} snapshot with undefined data`);
    }
    const { layoutMap, objectInfo } = getLayoutMapAndObjectInfo(recordId, data);
    return getRecord(luvio, refresh, recordId, layoutMap, objectInfo, optionalFields);
}
function isPromise$1(value) {
    // check for Thenable due to test frameworks using custom Promise impls
    return value !== null && value.then !== undefined;
}
function lookupObjectInfo(luvio, apiName) {
    const snapshot = buildInMemorySnapshot$7(luvio, { objectApiName: apiName });
    if (luvio.snapshotAvailable(snapshot)) {
        if (!isErrorSnapshot(snapshot) && snapshot.data !== undefined) {
            return snapshot.data;
        }
    }
    return null;
}
function lookupLayouts(luvio, apiName, recordTypeId, layoutTypes, modes) {
    const map = {};
    for (let i = 0; i < layoutTypes.length; i += 1) {
        const layoutType = layoutTypes[i];
        let layoutMap = map[layoutType];
        if (layoutMap === undefined) {
            layoutMap = map[layoutType] = {};
        }
        for (let m = 0; m < modes.length; m += 1) {
            const mode = modes[m];
            const key = keyBuilder$i({
                objectApiName: apiName,
                recordTypeId,
                layoutType,
                mode,
            });
            const snapshot = luvio.storeLookup({
                recordId: key,
                node: layoutSelections$1,
                variables: {},
            });
            // Cache hit
            if (luvio.snapshotAvailable(snapshot) && !isErrorSnapshot(snapshot)) {
                layoutMap[mode] = snapshot.data;
            }
            else {
                return null;
            }
        }
    }
    return map;
}
const recordLayoutFragmentSelector = [
    {
        name: 'apiName',
        kind: 'Scalar',
    },
    {
        name: 'recordTypeId',
        kind: 'Scalar',
    },
];
function getFieldsFromLayoutMap(layoutMap, objectInfo) {
    let fields = [];
    const layoutTypes = Object.keys(layoutMap);
    for (let i = 0, layoutTypesLen = layoutTypes.length; i < layoutTypesLen; i += 1) {
        const layoutType = layoutTypes[i];
        const modesMap = layoutMap[layoutType];
        const modes = Object.keys(modesMap);
        for (let m = 0, modesLen = modes.length; m < modesLen; m += 1) {
            const mode = modes[m];
            const modeKeys = getQualifiedFieldApiNamesFromLayout(modesMap[mode], objectInfo);
            fields = fields.concat(modeKeys);
        }
    }
    return dedupe(fields).sort();
}
function getRecord(luvio, refresh, recordId, layoutMap, objectInfo, configOptionalFields) {
    const fields = getFieldsFromLayoutMap(layoutMap, objectInfo);
    const optionalFields = configOptionalFields === undefined ? [] : dedupe(configOptionalFields).sort();
    // We know what fields we need so delegate to getRecordByFields
    // This should be a cache hit because we just fetched the record-ui
    const recordSnapshotOrPromise = getRecordByFields(luvio, {
        recordId,
        fields,
        optionalFields,
    });
    // attach a record layout refresh
    if (isPromise$1(recordSnapshotOrPromise)) {
        recordSnapshotOrPromise.then((snapshot) => {
            snapshot.refresh = refresh;
            return snapshot;
        });
    }
    else {
        recordSnapshotOrPromise.refresh = refresh;
    }
    return recordSnapshotOrPromise;
}
function getRecordLayoutType(luvio, config) {
    const { recordId, layoutTypes, modes: configModes, optionalFields } = config;
    const modes = configModes === undefined ? [DEFAULT_MODE] : configModes;
    const storeKey = keyBuilder$2({ recordId });
    const recordSnapshot = luvio.storeLookup({
        recordId: storeKey,
        node: {
            kind: 'Fragment',
            private: [],
            selections: recordLayoutFragmentSelector,
        },
        variables: {},
    });
    const refresh = buildSnapshotRefresh$4(luvio, config);
    // If we haven't seen the record then go to the server
    if (!luvio.snapshotAvailable(recordSnapshot) || recordSnapshot.data === undefined) {
        return fetchRecordLayout(luvio, refresh, recordId, layoutTypes, modes, optionalFields);
    }
    const record = recordSnapshot.data;
    const { apiName } = record;
    const objectInfo = lookupObjectInfo(luvio, apiName);
    // If we do not have object info in cache, call record-ui endpoint directly
    if (objectInfo === null) {
        return fetchRecordLayout(luvio, refresh, recordId, layoutTypes, modes, optionalFields);
    }
    const recordTypeId = getRecordTypeId(record);
    const layoutMap = lookupLayouts(luvio, apiName, recordTypeId, layoutTypes, modes);
    // It takes one xhr per layout to load so if there are missing layouts
    // give up and call record-ui endpoint directly
    if (layoutMap === null) {
        return fetchRecordLayout(luvio, refresh, recordId, layoutTypes, modes, optionalFields);
    }
    return getRecord(luvio, refresh, recordId, layoutMap, objectInfo, optionalFields);
}

// Custom adapter config due to `unsupported` items
const GET_RECORD_ADAPTER_CONFIG = {
    displayName: 'getRecord',
    parameters: {
        required: ['recordId'],
        optional: ['fields', 'layoutTypes', 'modes', 'optionalFields'],
        unsupported: [
            'childRelationships',
            'pageSize',
            'updateMru',
        ],
    },
};
function hasLayoutTypes(config) {
    return 'layoutTypes' in config;
}
function hasFieldsOrOptionalFields(config) {
    return 'fields' in config || 'optionalFields' in config;
}
function createResourceRequestFromRepresentation(representation, optionalFields) {
    const config = {
        urlParams: {
            recordId: representation.id,
        },
        queryParams: {
            optionalFields,
        },
    };
    return createResourceRequest$1(config);
}
// TODO: this should probably be code generated in RecordRepresentation
function coerceKeyParams(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    return coercedConfig;
}
const NOTIFY_CHANGE_NETWORK_KEY = 'notify-change-network';
const notifyChangeNetworkRejectInstrumentParamBuilder = () => {
    return {
        [NOTIFY_CHANGE_NETWORK_KEY]: 'error',
    };
};
const notifyChangeFactory = (luvio) => {
    return function getUiApiRecordsByRecordIdNotifyChange(configs) {
        for (let i = 0, len = configs.length; i < len; i++) {
            // build key from input
            const coercedConfig = coerceKeyParams(configs[i]);
            const key = keyBuilder$2(coercedConfig);
            // lookup GraphNode from store
            const node = luvio.getNode(key);
            if (node === null || node.type === 'Error') {
                continue;
            }
            // retrieve data (Representation) from GraphNode and use createResourceRequestFromRepresentation to build refresh resource request from Representation
            const representation = node.retrieve();
            const optionalFields = getTrackedFields(key, luvio.getNode(key));
            const refreshRequest = createResourceRequestFromRepresentation(representation, optionalFields);
            const existingWeakEtag = representation.weakEtag;
            const fieldTrie = convertFieldsToTrie([], false);
            const optionalFieldTrie = convertFieldsToTrie(optionalFields, true);
            // dispatch resource request, then ingest and broadcast
            luvio.dispatchResourceRequest(refreshRequest).then((response) => {
                const { body } = response;
                luvio.storeIngest(key, createFieldsIngestSuccess({
                    fields: fieldTrie,
                    optionalFields: optionalFieldTrie,
                    trackedFields: optionalFieldTrie,
                }), body);
                luvio.storeBroadcast();
                const notifyChangeNetworkResolveInstrumentParamBuilder = () => {
                    return {
                        [NOTIFY_CHANGE_NETWORK_KEY]: existingWeakEtag !== body.weakEtag,
                    };
                };
                luvio.instrument(notifyChangeNetworkResolveInstrumentParamBuilder);
            }, (error) => {
                const errorSnapshot = luvio.errorSnapshot(error);
                luvio.storeIngestError(key, errorSnapshot, TTL$1);
                luvio.storeBroadcast();
                luvio.instrument(notifyChangeNetworkRejectInstrumentParamBuilder);
            });
        }
    };
};
const factory$4 = (luvio) => function getRecord(untrustedConfig) {
    // standard config validation and coercion
    const config = validateAdapterConfig$1(untrustedConfig, GET_RECORD_ADAPTER_CONFIG);
    if (config === null) {
        return null;
    }
    if (hasLayoutTypes(config)) {
        return getRecordLayoutType(luvio, config);
    }
    else if (hasFieldsOrOptionalFields(config)) {
        return getRecordByFields(luvio, config);
    }
    return null;
};

function validate$t(obj, path = 'PlatformActionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionListContext = obj.actionListContext;
        const path_actionListContext = path + '.actionListContext';
        if (typeof obj_actionListContext !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionListContext + '" (at "' + path_actionListContext + '")');
        }
        const obj_actionTarget = obj.actionTarget;
        const path_actionTarget = path + '.actionTarget';
        let obj_actionTarget_union0 = null;
        const obj_actionTarget_union0_error = (() => {
            if (typeof obj_actionTarget !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_actionTarget + '" (at "' + path_actionTarget + '")');
            }
        })();
        if (obj_actionTarget_union0_error != null) {
            obj_actionTarget_union0 = obj_actionTarget_union0_error.message;
        }
        let obj_actionTarget_union1 = null;
        const obj_actionTarget_union1_error = (() => {
            if (obj_actionTarget !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_actionTarget + '" (at "' + path_actionTarget + '")');
            }
        })();
        if (obj_actionTarget_union1_error != null) {
            obj_actionTarget_union1 = obj_actionTarget_union1_error.message;
        }
        if (obj_actionTarget_union0 && obj_actionTarget_union1) {
            let message = 'Object doesn\'t match union (at "' + path_actionTarget + '")';
            message += '\n' + obj_actionTarget_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_actionTarget_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_actionTargetType = obj.actionTargetType;
        const path_actionTargetType = path + '.actionTargetType';
        let obj_actionTargetType_union0 = null;
        const obj_actionTargetType_union0_error = (() => {
            if (typeof obj_actionTargetType !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_actionTargetType + '" (at "' + path_actionTargetType + '")');
            }
        })();
        if (obj_actionTargetType_union0_error != null) {
            obj_actionTargetType_union0 = obj_actionTargetType_union0_error.message;
        }
        let obj_actionTargetType_union1 = null;
        const obj_actionTargetType_union1_error = (() => {
            if (obj_actionTargetType !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_actionTargetType + '" (at "' + path_actionTargetType + '")');
            }
        })();
        if (obj_actionTargetType_union1_error != null) {
            obj_actionTargetType_union1 = obj_actionTargetType_union1_error.message;
        }
        if (obj_actionTargetType_union0 && obj_actionTargetType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_actionTargetType + '")';
            message += '\n' + obj_actionTargetType_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_actionTargetType_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_externalId = obj.externalId;
        const path_externalId = path + '.externalId';
        if (typeof obj_externalId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_externalId + '" (at "' + path_externalId + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
            if (typeof obj_iconUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union0_error != null) {
            obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
            if (obj_iconUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union1_error != null) {
            obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
            message += '\n' + obj_iconUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_iconUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_isMassAction = obj.isMassAction;
        const path_isMassAction = path + '.isMassAction';
        if (typeof obj_isMassAction !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_isMassAction + '" (at "' + path_isMassAction + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_primaryColor = obj.primaryColor;
        const path_primaryColor = path + '.primaryColor';
        let obj_primaryColor_union0 = null;
        const obj_primaryColor_union0_error = (() => {
            if (typeof obj_primaryColor !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_primaryColor + '" (at "' + path_primaryColor + '")');
            }
        })();
        if (obj_primaryColor_union0_error != null) {
            obj_primaryColor_union0 = obj_primaryColor_union0_error.message;
        }
        let obj_primaryColor_union1 = null;
        const obj_primaryColor_union1_error = (() => {
            if (obj_primaryColor !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_primaryColor + '" (at "' + path_primaryColor + '")');
            }
        })();
        if (obj_primaryColor_union1_error != null) {
            obj_primaryColor_union1 = obj_primaryColor_union1_error.message;
        }
        if (obj_primaryColor_union0 && obj_primaryColor_union1) {
            let message = 'Object doesn\'t match union (at "' + path_primaryColor + '")';
            message += '\n' + obj_primaryColor_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_primaryColor_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedListRecordId = obj.relatedListRecordId;
        const path_relatedListRecordId = path + '.relatedListRecordId';
        let obj_relatedListRecordId_union0 = null;
        const obj_relatedListRecordId_union0_error = (() => {
            if (typeof obj_relatedListRecordId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relatedListRecordId + '" (at "' + path_relatedListRecordId + '")');
            }
        })();
        if (obj_relatedListRecordId_union0_error != null) {
            obj_relatedListRecordId_union0 = obj_relatedListRecordId_union0_error.message;
        }
        let obj_relatedListRecordId_union1 = null;
        const obj_relatedListRecordId_union1_error = (() => {
            if (obj_relatedListRecordId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relatedListRecordId + '" (at "' + path_relatedListRecordId + '")');
            }
        })();
        if (obj_relatedListRecordId_union1_error != null) {
            obj_relatedListRecordId_union1 = obj_relatedListRecordId_union1_error.message;
        }
        if (obj_relatedListRecordId_union0 && obj_relatedListRecordId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedListRecordId + '")';
            message += '\n' + obj_relatedListRecordId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relatedListRecordId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedSourceObject = obj.relatedSourceObject;
        const path_relatedSourceObject = path + '.relatedSourceObject';
        let obj_relatedSourceObject_union0 = null;
        const obj_relatedSourceObject_union0_error = (() => {
            if (typeof obj_relatedSourceObject !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relatedSourceObject + '" (at "' + path_relatedSourceObject + '")');
            }
        })();
        if (obj_relatedSourceObject_union0_error != null) {
            obj_relatedSourceObject_union0 = obj_relatedSourceObject_union0_error.message;
        }
        let obj_relatedSourceObject_union1 = null;
        const obj_relatedSourceObject_union1_error = (() => {
            if (obj_relatedSourceObject !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relatedSourceObject + '" (at "' + path_relatedSourceObject + '")');
            }
        })();
        if (obj_relatedSourceObject_union1_error != null) {
            obj_relatedSourceObject_union1 = obj_relatedSourceObject_union1_error.message;
        }
        if (obj_relatedSourceObject_union0 && obj_relatedSourceObject_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedSourceObject + '")';
            message += '\n' + obj_relatedSourceObject_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relatedSourceObject_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_section = obj.section;
        const path_section = path + '.section';
        let obj_section_union0 = null;
        const obj_section_union0_error = (() => {
            if (typeof obj_section !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_section + '" (at "' + path_section + '")');
            }
        })();
        if (obj_section_union0_error != null) {
            obj_section_union0 = obj_section_union0_error.message;
        }
        let obj_section_union1 = null;
        const obj_section_union1_error = (() => {
            if (obj_section !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_section + '" (at "' + path_section + '")');
            }
        })();
        if (obj_section_union1_error != null) {
            obj_section_union1 = obj_section_union1_error.message;
        }
        if (obj_section_union0 && obj_section_union1) {
            let message = 'Object doesn\'t match union (at "' + path_section + '")';
            message += '\n' + obj_section_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_section_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_sourceObject = obj.sourceObject;
        const path_sourceObject = path + '.sourceObject';
        if (typeof obj_sourceObject !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_sourceObject + '" (at "' + path_sourceObject + '")');
        }
        const obj_subtype = obj.subtype;
        const path_subtype = path + '.subtype';
        let obj_subtype_union0 = null;
        const obj_subtype_union0_error = (() => {
            if (typeof obj_subtype !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_subtype + '" (at "' + path_subtype + '")');
            }
        })();
        if (obj_subtype_union0_error != null) {
            obj_subtype_union0 = obj_subtype_union0_error.message;
        }
        let obj_subtype_union1 = null;
        const obj_subtype_union1_error = (() => {
            if (obj_subtype !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_subtype + '" (at "' + path_subtype + '")');
            }
        })();
        if (obj_subtype_union1_error != null) {
            obj_subtype_union1 = obj_subtype_union1_error.message;
        }
        if (obj_subtype_union0 && obj_subtype_union1) {
            let message = 'Object doesn\'t match union (at "' + path_subtype + '")';
            message += '\n' + obj_subtype_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_subtype_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_targetObject = obj.targetObject;
        const path_targetObject = path + '.targetObject';
        let obj_targetObject_union0 = null;
        const obj_targetObject_union0_error = (() => {
            if (typeof obj_targetObject !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_targetObject + '" (at "' + path_targetObject + '")');
            }
        })();
        if (obj_targetObject_union0_error != null) {
            obj_targetObject_union0 = obj_targetObject_union0_error.message;
        }
        let obj_targetObject_union1 = null;
        const obj_targetObject_union1_error = (() => {
            if (obj_targetObject !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_targetObject + '" (at "' + path_targetObject + '")');
            }
        })();
        if (obj_targetObject_union1_error != null) {
            obj_targetObject_union1 = obj_targetObject_union1_error.message;
        }
        if (obj_targetObject_union0 && obj_targetObject_union1) {
            let message = 'Object doesn\'t match union (at "' + path_targetObject + '")';
            message += '\n' + obj_targetObject_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_targetObject_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_targetUrl = obj.targetUrl;
        const path_targetUrl = path + '.targetUrl';
        let obj_targetUrl_union0 = null;
        const obj_targetUrl_union0_error = (() => {
            if (typeof obj_targetUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_targetUrl + '" (at "' + path_targetUrl + '")');
            }
        })();
        if (obj_targetUrl_union0_error != null) {
            obj_targetUrl_union0 = obj_targetUrl_union0_error.message;
        }
        let obj_targetUrl_union1 = null;
        const obj_targetUrl_union1_error = (() => {
            if (obj_targetUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_targetUrl + '" (at "' + path_targetUrl + '")');
            }
        })();
        if (obj_targetUrl_union1_error != null) {
            obj_targetUrl_union1 = obj_targetUrl_union1_error.message;
        }
        if (obj_targetUrl_union0 && obj_targetUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_targetUrl + '")';
            message += '\n' + obj_targetUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_targetUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$l(config) {
    return keyPrefix + 'PlatformActionRepresentation:' + config.externalId + ':' + (config.relatedSourceObject === null ? '' : config.relatedSourceObject) + ':' + (config.relatedListRecordId === null ? '' : config.relatedListRecordId);
}
function keyBuilderFromType$a(object) {
    const keyParams = {
        externalId: object.externalId,
        relatedSourceObject: object.relatedSourceObject,
        relatedListRecordId: object.relatedListRecordId
    };
    return keyBuilder$l(keyParams);
}
function normalize$c(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$j = function PlatformActionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'id'
        ],
        selections: [
            {
                name: 'actionListContext',
                kind: 'Scalar'
            },
            {
                name: 'actionTarget',
                kind: 'Scalar'
            },
            {
                name: 'actionTargetType',
                kind: 'Scalar'
            },
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'externalId',
                kind: 'Scalar'
            },
            {
                name: 'iconUrl',
                kind: 'Scalar'
            },
            {
                name: 'isMassAction',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'primaryColor',
                kind: 'Scalar'
            },
            {
                name: 'relatedListRecordId',
                kind: 'Scalar'
            },
            {
                name: 'relatedSourceObject',
                kind: 'Scalar'
            },
            {
                name: 'section',
                kind: 'Scalar'
            },
            {
                name: 'sourceObject',
                kind: 'Scalar'
            },
            {
                name: 'subtype',
                kind: 'Scalar'
            },
            {
                name: 'targetObject',
                kind: 'Scalar'
            },
            {
                name: 'targetUrl',
                kind: 'Scalar'
            },
            {
                name: 'type',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$e(existing, incoming) {
    const existing_actionListContext = existing.actionListContext;
    const incoming_actionListContext = incoming.actionListContext;
    if (!(existing_actionListContext === incoming_actionListContext)) {
        return false;
    }
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_externalId = existing.externalId;
    const incoming_externalId = incoming.externalId;
    if (!(existing_externalId === incoming_externalId)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_isMassAction = existing.isMassAction;
    const incoming_isMassAction = incoming.isMassAction;
    if (!(existing_isMassAction === incoming_isMassAction)) {
        return false;
    }
    const existing_label = existing.label;
    const incoming_label = incoming.label;
    if (!(existing_label === incoming_label)) {
        return false;
    }
    const existing_sourceObject = existing.sourceObject;
    const incoming_sourceObject = incoming.sourceObject;
    if (!(existing_sourceObject === incoming_sourceObject)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    const existing_actionTarget = existing.actionTarget;
    const incoming_actionTarget = incoming.actionTarget;
    if (!(existing_actionTarget === incoming_actionTarget)) {
        return false;
    }
    const existing_actionTargetType = existing.actionTargetType;
    const incoming_actionTargetType = incoming.actionTargetType;
    if (!(existing_actionTargetType === incoming_actionTargetType)) {
        return false;
    }
    const existing_iconUrl = existing.iconUrl;
    const incoming_iconUrl = incoming.iconUrl;
    if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
    }
    const existing_primaryColor = existing.primaryColor;
    const incoming_primaryColor = incoming.primaryColor;
    if (!(existing_primaryColor === incoming_primaryColor)) {
        return false;
    }
    const existing_relatedListRecordId = existing.relatedListRecordId;
    const incoming_relatedListRecordId = incoming.relatedListRecordId;
    if (!(existing_relatedListRecordId === incoming_relatedListRecordId)) {
        return false;
    }
    const existing_relatedSourceObject = existing.relatedSourceObject;
    const incoming_relatedSourceObject = incoming.relatedSourceObject;
    if (!(existing_relatedSourceObject === incoming_relatedSourceObject)) {
        return false;
    }
    const existing_section = existing.section;
    const incoming_section = incoming.section;
    if (!(existing_section === incoming_section)) {
        return false;
    }
    const existing_subtype = existing.subtype;
    const incoming_subtype = incoming.subtype;
    if (!(existing_subtype === incoming_subtype)) {
        return false;
    }
    const existing_targetObject = existing.targetObject;
    const incoming_targetObject = incoming.targetObject;
    if (!(existing_targetObject === incoming_targetObject)) {
        return false;
    }
    const existing_targetUrl = existing.targetUrl;
    const incoming_targetUrl = incoming.targetUrl;
    if (!(existing_targetUrl === incoming_targetUrl)) {
        return false;
    }
    return true;
}
const ingest$c = function PlatformActionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$t(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$a(input);
    let incomingRecord = normalize$c(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$e(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$u(obj, path = 'EntityActionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actions = obj.actions;
        const path_actions = path + '.actions';
        if (!ArrayIsArray$1(obj_actions)) {
            return new TypeError('Expected "array" but received "' + typeof obj_actions + '" (at "' + path_actions + '")');
        }
        for (let i = 0; i < obj_actions.length; i++) {
            const obj_actions_item = obj_actions[i];
            const path_actions_item = path_actions + '[' + i + ']';
            if (typeof obj_actions_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_actions_item + '" (at "' + path_actions_item + '")');
            }
        }
        const obj_links = obj.links;
        const path_links = path + '.links';
        if (!ArrayIsArray$1(obj_links)) {
            return new TypeError('Expected "array" but received "' + typeof obj_links + '" (at "' + path_links + '")');
        }
        for (let i = 0; i < obj_links.length; i++) {
            const obj_links_item = obj_links[i];
            const path_links_item = path_links + '[' + i + ']';
            if (typeof obj_links_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_links_item + '" (at "' + path_links_item + '")');
            }
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$m(config) {
    return keyPrefix + 'EntityActionRepresentation:' + config.url;
}
function keyBuilderFromType$b(object) {
    const keyParams = {
        url: object.url
    };
    return keyBuilder$m(keyParams);
}
function normalize$d(input, existing, path, luvio, store, timestamp) {
    const input_actions = input.actions;
    const input_actions_id = path.fullPath + '__actions';
    for (let i = 0; i < input_actions.length; i++) {
        const input_actions_item = input_actions[i];
        let input_actions_item_id = input_actions_id + '__' + i;
        input_actions[i] = ingest$c(input_actions_item, {
            fullPath: input_actions_item_id,
            propertyName: i,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store);
    }
    return input;
}
const select$k = function EntityActionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'links',
            'url'
        ],
        selections: [
            {
                name: 'actions',
                kind: 'Link',
                plural: true,
                fragment: select$j()
            }
        ]
    };
};
function equals$f(existing, incoming) {
    const existing_url = existing.url;
    const incoming_url = incoming.url;
    if (!(existing_url === incoming_url)) {
        return false;
    }
    const existing_actions = existing.actions;
    const incoming_actions = incoming.actions;
    const equals_actions_items = equalsArray(existing_actions, incoming_actions, (existing_actions_item, incoming_actions_item) => {
        if (!(existing_actions_item.__ref === incoming_actions_item.__ref)) {
            return false;
        }
    });
    if (equals_actions_items === false) {
        return false;
    }
    const existing_links = existing.links;
    const incoming_links = incoming.links;
    const equals_links_items = equalsArray(existing_links, incoming_links, (existing_links_item, incoming_links_item) => {
        if (!(existing_links_item === incoming_links_item)) {
            return false;
        }
    });
    if (equals_links_items === false) {
        return false;
    }
    return true;
}
const ingest$d = function EntityActionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$u(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$b(input);
    let incomingRecord = normalize$d(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$f(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

const TTL$4 = 300000;
function validate$v(obj, path = 'ActionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actions = obj.actions;
        const path_actions = path + '.actions';
        if (typeof obj_actions !== 'object' || ArrayIsArray$1(obj_actions) || obj_actions === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_actions + '" (at "' + path_actions + '")');
        }
        const obj_actions_keys = ObjectKeys$1(obj_actions);
        for (let i = 0; i < obj_actions_keys.length; i++) {
            const key = obj_actions_keys[i];
            const obj_actions_prop = obj_actions[key];
            const path_actions_prop = path_actions + '["' + key + '"]';
            if (typeof obj_actions_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_actions_prop + '" (at "' + path_actions_prop + '")');
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$e(input, existing, path, luvio, store, timestamp) {
    const input_actions = input.actions;
    const input_actions_id = path.fullPath + '__actions';
    const input_actions_keys = Object.keys(input_actions);
    const input_actions_length = input_actions_keys.length;
    for (let i = 0; i < input_actions_length; i++) {
        const key = input_actions_keys[i];
        const input_actions_prop = input_actions[key];
        const input_actions_prop_id = input_actions_id + '__' + key;
        input_actions[key] = ingest$d(input_actions_prop, {
            fullPath: input_actions_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store);
    }
    return input;
}
const select$l = function ActionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag',
            'url'
        ],
        selections: [
            {
                name: 'actions',
                kind: 'Link',
                map: true,
                fragment: select$k()
            }
        ]
    };
};
function equals$g(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_url = existing.url;
    const incoming_url = incoming.url;
    if (!(existing_url === incoming_url)) {
        return false;
    }
    const existing_actions = existing.actions;
    const incoming_actions = incoming.actions;
    const equals_actions_props = equalsObject(existing_actions, incoming_actions, (existing_actions_prop, incoming_actions_prop) => {
        if (!(existing_actions_prop.__ref === incoming_actions_prop.__ref)) {
            return false;
        }
    });
    if (equals_actions_props === false) {
        return false;
    }
    return true;
}
const ingest$e = function ActionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$v(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$e(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$g(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function select$m(luvio, params) {
    return select$l();
}
function keyBuilder$n(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'apiNames:' + params.queryParams.apiNames + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'retrievalMode:' + params.queryParams.retrievalMode + ',' + 'sections:' + params.queryParams.sections + ')';
}
function ingestSuccess$4(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$n(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$m(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$5(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$n(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$c(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/global',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
    };
}

function toSortedStringArrayAllowEmpty(value) {
    const valueArray = isArray(value) ? value : [value];
    if (valueArray.length === 0) {
        return valueArray;
    }
    return toSortedStringArray(valueArray);
}

var FormFactor;
(function (FormFactor) {
    FormFactor["Large"] = "Large";
    FormFactor["Medium"] = "Medium";
    FormFactor["Small"] = "Small";
})(FormFactor || (FormFactor = {}));

function coerceFormFactor(form) {
    if (form === FormFactor.Large || form === FormFactor.Medium || form === FormFactor.Small) {
        return form;
    }
    return undefined;
}

const getGlobalActions_ConfigPropertyNames = {
    displayName: 'getGlobalActions',
    parameters: {
        required: [],
        optional: ['actionTypes', 'apiNames', 'formFactor', 'retrievalMode', 'sections']
    }
};
function createResourceParams$7(config) {
    return {
        queryParams: {
            actionTypes: config.actionTypes, apiNames: config.apiNames, formFactor: config.formFactor, retrievalMode: config.retrievalMode, sections: config.sections
        }
    };
}
function coerceConfig$8(config) {
    const coercedConfig = {};
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const apiNames = toSortedStringArrayAllowEmpty(config.apiNames);
    if (apiNames !== undefined) {
        coercedConfig.apiNames = apiNames;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const retrievalMode = config.retrievalMode;
    if (retrievalMode !== undefined) {
        coercedConfig.retrievalMode = retrievalMode;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$o(luvio, config) {
    const resourceParams = createResourceParams$7(config);
    return keyBuilder$n(resourceParams);
}
function typeCheckConfig$8(untrustedConfig) {
    const config = {};
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_apiNames = untrustedConfig.apiNames;
    if (ArrayIsArray(untrustedConfig_apiNames)) {
        const untrustedConfig_apiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_apiNames.length; i < arrayLength; i++) {
            const untrustedConfig_apiNames_item = untrustedConfig_apiNames[i];
            if (typeof untrustedConfig_apiNames_item === 'string') {
                untrustedConfig_apiNames_array.push(untrustedConfig_apiNames_item);
            }
        }
        config.apiNames = untrustedConfig_apiNames_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_retrievalMode = untrustedConfig.retrievalMode;
    if (typeof untrustedConfig_retrievalMode === 'string') {
        config.retrievalMode = untrustedConfig_retrievalMode;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$8(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$8(untrustedConfig);
    const config = typeCheckConfig$8(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$4(luvio, config) {
    const resourceParams = createResourceParams$7(config);
    return select$m();
}
function buildInMemorySnapshot$9(luvio, config) {
    const selector = {
        recordId: keyBuilder$o(luvio, config),
        node: adapterFragment$4(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$7(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$5(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$4(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$7(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$5(luvio, config, resourceParams, response) {
    const snapshot = ingestError$5(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$7(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$7(luvio, config, override) {
    const resourceParams = createResourceParams$7(config);
    const request = createResourceRequest$c(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$5(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$5(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$7(luvio, config, snapshot) {
    const resourceParams = createResourceParams$7(config);
    const request = createResourceRequest$c(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$5(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$5(luvio, config, resourceParams, response);
    });
}
const getGlobalActionsAdapterFactory = (luvio) => function uiApi__getGlobalActions(untrustedConfig) {
    const config = validateAdapterConfig$8(untrustedConfig, getGlobalActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$9(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$7(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$7(luvio, config);
};

function select$n(luvio, params) {
    return select$l();
}
function keyBuilder$p(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'objectApiNames:' + params.urlParams.objectApiNames + ')';
}
function ingestSuccess$5(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$p(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$n(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$6(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$p(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$d(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/lookup/' + config.urlParams.objectApiNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getObjectApiNamesArray(value) {
    const valueArray = isArray(value) ? value : [value];
    const array = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getObjectApiName(item);
        if (apiName === undefined) {
            return undefined;
        }
        push.call(array, apiName);
    }
    if (array.length === 0) {
        return undefined;
    }
    return dedupe(array);
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getSortedObjectApiNamesArray(value) {
    const unsortedArray = getObjectApiNamesArray(value);
    return unsortedArray === undefined ? undefined : unsortedArray.sort();
}

const getLookupActions_ConfigPropertyNames = {
    displayName: 'getLookupActions',
    parameters: {
        required: ['objectApiNames'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$8(config) {
    return {
        urlParams: {
            objectApiNames: config.objectApiNames
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$9(config) {
    const coercedConfig = {};
    const objectApiNames = getSortedObjectApiNamesArray(config.objectApiNames);
    if (objectApiNames !== undefined) {
        coercedConfig.objectApiNames = objectApiNames;
    }
    const actionTypes = toSortedStringArray(config.actionTypes);
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$q(luvio, config) {
    const resourceParams = createResourceParams$8(config);
    return keyBuilder$p(resourceParams);
}
function typeCheckConfig$9(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiNames = untrustedConfig.objectApiNames;
    if (ArrayIsArray(untrustedConfig_objectApiNames)) {
        const untrustedConfig_objectApiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_objectApiNames.length; i < arrayLength; i++) {
            const untrustedConfig_objectApiNames_item = untrustedConfig_objectApiNames[i];
            if (typeof untrustedConfig_objectApiNames_item === 'string') {
                untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);
            }
        }
        config.objectApiNames = untrustedConfig_objectApiNames_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$9(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$9(untrustedConfig);
    const config = typeCheckConfig$9(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$5(luvio, config) {
    const resourceParams = createResourceParams$8(config);
    return select$n();
}
function buildInMemorySnapshot$a(luvio, config) {
    const selector = {
        recordId: keyBuilder$q(luvio, config),
        node: adapterFragment$5(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$8(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$6(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$5(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$8(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$6(luvio, config, resourceParams, response) {
    const snapshot = ingestError$6(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$8(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$8(luvio, config, override) {
    const resourceParams = createResourceParams$8(config);
    const request = createResourceRequest$d(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$6(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$6(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$8(luvio, config, snapshot) {
    const resourceParams = createResourceParams$8(config);
    const request = createResourceRequest$d(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$6(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$6(luvio, config, resourceParams, response);
    });
}
const getLookupActionsAdapterFactory = (luvio) => function uiApi__getLookupActions(untrustedConfig) {
    const config = validateAdapterConfig$9(untrustedConfig, getLookupActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$a(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$8(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$8(luvio, config);
};

function select$o(luvio, params) {
    return select$l();
}
function keyBuilder$r(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
}
function ingestSuccess$6(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$r(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$o(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$7(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$r(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$e(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/object/' + config.urlParams.objectApiName + '/record-create',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getObjectCreateActions_ConfigPropertyNames = {
    displayName: 'getObjectCreateActions',
    parameters: {
        required: ['objectApiName'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$9(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$a(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$s(luvio, config) {
    const resourceParams = createResourceParams$9(config);
    return keyBuilder$r(resourceParams);
}
function typeCheckConfig$a(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$a(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$a(untrustedConfig);
    const config = typeCheckConfig$a(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$6(luvio, config) {
    const resourceParams = createResourceParams$9(config);
    return select$o();
}
function buildInMemorySnapshot$b(luvio, config) {
    const selector = {
        recordId: keyBuilder$s(luvio, config),
        node: adapterFragment$6(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$9(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$7(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$6(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$9(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$7(luvio, config, resourceParams, response) {
    const snapshot = ingestError$7(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$9(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$9(luvio, config, override) {
    const resourceParams = createResourceParams$9(config);
    const request = createResourceRequest$e(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$7(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$7(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$9(luvio, config, snapshot) {
    const resourceParams = createResourceParams$9(config);
    const request = createResourceRequest$e(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$7(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$7(luvio, config, resourceParams, response);
    });
}
const getObjectCreateActionsAdapterFactory = (luvio) => function uiApi__getObjectCreateActions(untrustedConfig) {
    const config = validateAdapterConfig$a(untrustedConfig, getObjectCreateActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$b(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$9(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$9(luvio, config);
};

const TTL$5 = 900000;
function validate$w(obj, path = 'QuickActionDefaultsRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionApiName = obj.actionApiName;
        const path_actionApiName = path + '.actionApiName';
        if (typeof obj_actionApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionApiName + '" (at "' + path_actionApiName + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$t(config) {
    return keyPrefix + 'QuickActionDefaultsRepresentation:' + config.actionApiName;
}
function keyBuilderFromType$c(object) {
    const keyParams = {
        actionApiName: object.actionApiName
    };
    return keyBuilder$t(keyParams);
}
function dynamicNormalize$1(ingestParams) {
    return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
            const key = input_fields_keys[i];
            const input_fields_prop = input_fields[key];
            const input_fields_prop_id = input_fields_id + '__' + key;
            input_fields[key] = ingestParams.fields(input_fields_prop, {
                fullPath: input_fields_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        return input;
    };
}
const dynamicSelect$1 = function dynamicQuickActionDefaultsRepresentationSelect(params) {
    const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$8()
    } : params.fields;
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'actionApiName',
                kind: 'Scalar'
            },
            fieldsPathSelection,
            {
                name: 'objectApiName',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$h(existing, incoming) {
    const existing_actionApiName = existing.actionApiName;
    const incoming_actionApiName = incoming.actionApiName;
    if (!(existing_actionApiName === incoming_actionApiName)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    return true;
}

function merge$2(existing, incoming) {
    if (existing === undefined) {
        return incoming;
    }
    // Merge QuickActionDefaultsRepresentation field values together
    return {
        ...incoming,
        fields: {
            ...existing.fields,
            ...incoming.fields,
        },
    };
}
const dynamicIngest = (ingestParams) => {
    return function QuickActionDefaultsRepresentationIngest(input, path, luvio, store, timestamp) {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$w(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = keyBuilderFromType$c(input);
        let incomingRecord = dynamicNormalize$1(ingestParams)(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        }, luvio, store, timestamp);
        const existingRecord = store.records[key];
        incomingRecord = merge$2(existingRecord, incomingRecord);
        if (existingRecord === undefined || equals$h(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        luvio.storeSetExpiration(key, timestamp + 900000);
        return createLink(key);
    };
};

function createFieldsIngest(params) {
    const { fields, optionalFields, trackedFields, recordConflictMap } = params;
    const ingest = dynamicIngest({
        fields: createFieldsIngestion(fields, optionalFields, recordConflictMap)
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields(fields) {
    return dynamicSelect$1({
        fields: createPathSelection('fields', fields)
    });
}

function createFieldsIngestSuccess$1(params) {
    const { trackedFields } = params;
    const recordConflictMap = {};
    const ingest = createFieldsIngest({
        ...params,
        recordConflictMap,
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$1(luvio, params) {
    const optionalFields = params.queryParams.optionalFields || [];
    const fields = [];
    const trie = convertRecordFieldsArrayToTrie(fields, optionalFields);
    return selectFields(trie);
}

function keyBuilder$u(params) {
    return keyBuilder$t({
        actionApiName: params.urlParams.actionApiName
    });
}
function ingestError$8(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$u(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$5);
    return errorSnapshot;
}
function createResourceRequest$f(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/record-defaults/' + config.urlParams.actionApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function adapterFragment$7(luvio, config) {
    const resourceParams = createResourceParams$a(config);
    return selectFields$1(luvio, resourceParams);
}
function buildNetworkSnapshot$a(luvio, config, override) {
    const resourceParams = createResourceParams$a(config);
    const request = createResourceRequest$f(resourceParams);
    const key = keyBuilder$v(luvio, config);
    const optionalFieldsTrie = convertFieldsToTrie(getTrackedFields(key, luvio.getNode(key), config.optionalFields));
    const fieldsTrie = BLANK_RECORD_FIELDS_TRIE;
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        const ingest = createFieldsIngestSuccess$1({
            fields: fieldsTrie,
            optionalFields: optionalFieldsTrie,
            trackedFields: optionalFieldsTrie,
        });
        luvio.storeIngest(key, ingest, response.body);
        const snapshot = buildInMemorySnapshot$c(luvio, config);
        if (process.env.NODE_ENV !== 'production') {
            if (snapshot.state !== 'Fulfilled') {
                throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
        }
        luvio.storeBroadcast();
        return snapshot;
    }, (response) => {
        return onResourceResponseError$8(luvio, config, resourceParams, response);
    });
}
const resolveUnfulfilledSnapshot$a = (luvio, config, snapshot) => {
    const resourceParams = createResourceParams$a(config);
    const request = createResourceRequest$f(resourceParams);
    const key = keyBuilder$v(luvio, config);
    const optionalFieldsTrie = convertFieldsToTrie(getTrackedFields(key, luvio.getNode(key), config.optionalFields));
    const fieldsTrie = BLANK_RECORD_FIELDS_TRIE;
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        const ingest = createFieldsIngestSuccess$1({
            fields: fieldsTrie,
            optionalFields: optionalFieldsTrie,
            trackedFields: optionalFieldsTrie,
        });
        luvio.storeIngest(key, ingest, response.body);
        const snapshot = buildInMemorySnapshot$c(luvio, config);
        if (process.env.NODE_ENV !== 'production') {
            if (snapshot.state !== 'Fulfilled') {
                throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
        }
        luvio.storeBroadcast();
        return snapshot;
    }, (response) => {
        return onResourceResponseError$8(luvio, config, resourceParams, response);
    });
};

const getQuickActionDefaults_ConfigPropertyNames = {
    displayName: 'getQuickActionDefaults',
    parameters: {
        required: ['actionApiName'],
        optional: ['optionalFields', 'parentRecordId']
    }
};
function createResourceParams$a(config) {
    return {
        urlParams: {
            actionApiName: config.actionApiName
        },
        queryParams: {
            optionalFields: config.optionalFields, parentRecordId: config.parentRecordId
        }
    };
}
function coerceConfig$b(config) {
    const coercedConfig = {};
    const actionApiName = getObjectApiName(config.actionApiName);
    if (actionApiName !== undefined) {
        coercedConfig.actionApiName = actionApiName;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const parentRecordId = config.parentRecordId;
    if (parentRecordId !== undefined) {
        coercedConfig.parentRecordId = parentRecordId;
    }
    return coercedConfig;
}
function keyBuilder$v(luvio, config) {
    const resourceParams = createResourceParams$a(config);
    return keyBuilder$u(resourceParams);
}
function typeCheckConfig$b(untrustedConfig) {
    const config = {};
    const untrustedConfig_actionApiName = untrustedConfig.actionApiName;
    if (typeof untrustedConfig_actionApiName === 'string') {
        config.actionApiName = untrustedConfig_actionApiName;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    return config;
}
function validateAdapterConfig$b(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$b(untrustedConfig);
    const config = typeCheckConfig$b(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$c(luvio, config) {
    const selector = {
        recordId: keyBuilder$v(luvio, config),
        node: adapterFragment$7(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$a(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseError$8(luvio, config, resourceParams, response) {
    const snapshot = ingestError$8(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$a(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
const getQuickActionDefaultsAdapterFactory = (luvio) => function uiApi__getQuickActionDefaults(untrustedConfig) {
    const config = validateAdapterConfig$b(untrustedConfig, getQuickActionDefaults_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$c(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$a(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$a(luvio, config);
};

function select$p(luvio, params) {
    return select$l();
}
function keyBuilder$w(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'apiNames:' + params.queryParams.apiNames + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'retrievalMode:' + params.queryParams.retrievalMode + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
}
function ingestSuccess$7(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$w(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$p(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$9(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$w(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$g(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const oneOfConfigPropertiesIdentifier$1 = [
    'sections',
    'apiNames'
];
const getRecordActions_ConfigPropertyNames = {
    displayName: 'getRecordActions',
    parameters: {
        required: ['recordIds'],
        optional: ['actionTypes', 'apiNames', 'formFactor', 'retrievalMode', 'sections']
    }
};
function createResourceParams$b(config) {
    return {
        urlParams: {
            recordIds: config.recordIds
        },
        queryParams: {
            actionTypes: config.actionTypes, apiNames: config.apiNames, formFactor: config.formFactor, retrievalMode: config.retrievalMode, sections: config.sections
        }
    };
}
function coerceConfig$c(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const apiNames = toSortedStringArrayAllowEmpty(config.apiNames);
    if (apiNames !== undefined) {
        coercedConfig.apiNames = apiNames;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const retrievalMode = config.retrievalMode;
    if (retrievalMode !== undefined) {
        coercedConfig.retrievalMode = retrievalMode;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$x(luvio, config) {
    const resourceParams = createResourceParams$b(config);
    return keyBuilder$w(resourceParams);
}
function typeCheckConfig$c(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_apiNames = untrustedConfig.apiNames;
    if (ArrayIsArray(untrustedConfig_apiNames)) {
        const untrustedConfig_apiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_apiNames.length; i < arrayLength; i++) {
            const untrustedConfig_apiNames_item = untrustedConfig_apiNames[i];
            if (typeof untrustedConfig_apiNames_item === 'string') {
                untrustedConfig_apiNames_array.push(untrustedConfig_apiNames_item);
            }
        }
        config.apiNames = untrustedConfig_apiNames_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_retrievalMode = untrustedConfig.retrievalMode;
    if (typeof untrustedConfig_retrievalMode === 'string') {
        config.retrievalMode = untrustedConfig_retrievalMode;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$c(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier$1);
    }
    const coercedConfig = coerceConfig$c(untrustedConfig);
    const config = typeCheckConfig$c(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    if (config.sections === undefined &&
        config.apiNames === undefined) {
        return null;
    }
    return config;
}
function adapterFragment$8(luvio, config) {
    const resourceParams = createResourceParams$b(config);
    return select$p();
}
function buildInMemorySnapshot$d(luvio, config) {
    const selector = {
        recordId: keyBuilder$x(luvio, config),
        node: adapterFragment$8(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$b(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$8(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$7(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$b(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$9(luvio, config, resourceParams, response) {
    const snapshot = ingestError$9(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$b(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$b(luvio, config, override) {
    const resourceParams = createResourceParams$b(config);
    const request = createResourceRequest$g(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$8(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$9(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$b(luvio, config, snapshot) {
    const resourceParams = createResourceParams$b(config);
    const request = createResourceRequest$g(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$8(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$9(luvio, config, resourceParams, response);
    });
}
const getRecordActionsAdapterFactory = (luvio) => function uiApi__getRecordActions(untrustedConfig) {
    const config = validateAdapterConfig$c(untrustedConfig, getRecordActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$d(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$b(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$b(luvio, config);
};

function select$q(luvio, params) {
    return select$l();
}
function keyBuilder$y(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
}
function ingestSuccess$8(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$y(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$q(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$a(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$y(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$h(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/record-edit',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRecordEditActions_ConfigPropertyNames = {
    displayName: 'getRecordEditActions',
    parameters: {
        required: ['recordIds'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$c(config) {
    return {
        urlParams: {
            recordIds: config.recordIds
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$d(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$z(luvio, config) {
    const resourceParams = createResourceParams$c(config);
    return keyBuilder$y(resourceParams);
}
function typeCheckConfig$d(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$d(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$d(untrustedConfig);
    const config = typeCheckConfig$d(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$9(luvio, config) {
    const resourceParams = createResourceParams$c(config);
    return select$q();
}
function buildInMemorySnapshot$e(luvio, config) {
    const selector = {
        recordId: keyBuilder$z(luvio, config),
        node: adapterFragment$9(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$c(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$9(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$8(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$c(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$a(luvio, config, resourceParams, response) {
    const snapshot = ingestError$a(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$c(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$c(luvio, config, override) {
    const resourceParams = createResourceParams$c(config);
    const request = createResourceRequest$h(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$9(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$a(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$c(luvio, config, snapshot) {
    const resourceParams = createResourceParams$c(config);
    const request = createResourceRequest$h(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$9(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$a(luvio, config, resourceParams, response);
    });
}
const getRecordEditActionsAdapterFactory = (luvio) => function uiApi__getRecordEditActions(untrustedConfig) {
    const config = validateAdapterConfig$d(untrustedConfig, getRecordEditActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$e(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$c(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$c(luvio, config);
};

function select$r(luvio, params) {
    return select$l();
}
function keyBuilder$A(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListId:' + params.urlParams.relatedListId + ')';
}
function ingestSuccess$9(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$A(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$r(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$b(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$A(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$i(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const nonCachedErrors$1 = ObjectCreate(null);
function createChildResourceParams$1(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListIds.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListIds[index];
        childConfigs.push({
            urlParams: {
                recordIds: resourceParams.urlParams.recordIds,
                relatedListId: item
            },
            queryParams: {
                actionTypes: resourceParams.queryParams.actionTypes,
                formFactor: resourceParams.queryParams.formFactor,
                sections: resourceParams.queryParams.sections
            }
        });
    }
    return childConfigs;
}
function selectChildResourceParams$1(luvio, childResources) {
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$A(childResource);
                const childFragment = select$r();
                const isMissingDataBeforeChildRead = reader.isMissingData;
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                reader.seenIds[childKey] = true;
                switch (childSnapshot.state) {
                    case 'Stale':
                        reader.markStale();
                    // Stale needs envelope bodies filled in so don't break
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        // if child snapshot doesn't have any data then
                        // that means the child record key is missing
                        if (childSnapshot.data === undefined) {
                            if (reader.baseSnapshot === undefined) {
                                // not a rebuild, mark as missing and move on
                                reader.markMissingLink(childKey);
                                break;
                            }
                            // On rebuilds we have to check if there is a non-cached
                            // error that we know about.  If we don't do this then
                            // rebuilds will go into endless refresh loop if a child
                            // has non-cached errors (since the top-level composite
                            // snapshot will look like an Unfulfilled snapshot
                            // instead of an error snapshot).
                            const nonCachedError = nonCachedErrors$1[childKey];
                            if (nonCachedError === undefined || nonCachedError.expiration < reader.timestamp) {
                                reader.markMissingLink(childKey);
                            }
                            else {
                                // if this child error was the only reason the reader
                                // is marked as missing then we want to undo that
                                if (isMissingDataBeforeChildRead === false) {
                                    reader.unMarkMissing();
                                }
                                // put status code and body into reader path
                                const { response: nonCachedBody, status: nonCachedStatus } = nonCachedError;
                                reader.enterPath(envelopeStatusCodePath);
                                reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                                reader.exitPath();
                                reader.enterPath(envelopeBodyPath);
                                reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                                reader.exitPath();
                            }
                        }
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function select$s(luvio, resourceParams) {
    const childResources = createChildResourceParams$1(resourceParams);
    return selectChildResourceParams$1(luvio, childResources);
}
function keyBuilder$B(params) {
    return keyPrefix + 'ActionBatchRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListIds:' + params.urlParams.relatedListIds + ')';
}
function ingestSuccessChildResourceParams$1(luvio, childResourceParamsArray, childEnvelopes) {
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    let snapshotState = 'Fulfilled';
    const now = Date.now();
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$A(childResourceParams);
        const result = childEnvelopes[index];
        const { statusCode: childStatusCode, result: childBody } = result;
        if (childStatusCode === 200) {
            const childResponse = {
                status: 200,
                body: childBody,
                ok: true,
                statusText: 'OK',
                headers: undefined,
            };
            const childSnapshot = ingestSuccess$9(luvio, childResourceParams, childResponse);
            if (childSnapshot.state === "Stale") {
                snapshotState = "Stale";
            }
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: 200,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        else {
            const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$b(luvio, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [childKey]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
            nonCachedErrors$1[childKey] = { expiration: now + TTL$4, response: childBody, status: childStatusCode };
        }
        else {
            delete nonCachedErrors$1[childKey];
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    return { childSnapshotData: ObjectFreeze(childSnapshotData), seenRecords, snapshotState };
}
function ingestSuccess$a(luvio, resourceParams, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$1(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const key = keyBuilder$B(resourceParams);
    const { childSnapshotData, seenRecords, snapshotState } = ingestSuccessChildResourceParams$1(luvio, childResourceParamsArray, childEnvelopes);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$s(luvio, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$c(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$B(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$j(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list/batch/' + config.urlParams.relatedListIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRelatedListsActions_ConfigPropertyNames = {
    displayName: 'getRelatedListsActions',
    parameters: {
        required: ['recordIds', 'relatedListIds'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$d(config) {
    return {
        urlParams: {
            recordIds: config.recordIds, relatedListIds: config.relatedListIds
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$e(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const relatedListIds = toSortedStringArray(config.relatedListIds);
    if (relatedListIds !== undefined) {
        coercedConfig.relatedListIds = relatedListIds;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$C(luvio, config) {
    const resourceParams = createResourceParams$d(config);
    return keyBuilder$B(resourceParams);
}
function typeCheckConfig$e(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_relatedListIds = untrustedConfig.relatedListIds;
    if (ArrayIsArray(untrustedConfig_relatedListIds)) {
        const untrustedConfig_relatedListIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListIds.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListIds_item = untrustedConfig_relatedListIds[i];
            if (typeof untrustedConfig_relatedListIds_item === 'string') {
                untrustedConfig_relatedListIds_array.push(untrustedConfig_relatedListIds_item);
            }
        }
        config.relatedListIds = untrustedConfig_relatedListIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$e(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$e(untrustedConfig);
    const config = typeCheckConfig$e(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$a(luvio, config) {
    const resourceParams = createResourceParams$d(config);
    return select$s(luvio, resourceParams);
}
function buildInMemorySnapshot$f(luvio, config) {
    const selector = {
        recordId: keyBuilder$C(luvio, config),
        node: adapterFragment$a(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$a(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$a(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$b(luvio, config, resourceParams, response) {
    const snapshot = ingestError$c(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$d(luvio, config, override) {
    const resourceParams = createResourceParams$d(config);
    const request = createResourceRequest$j(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$a(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$b(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$d(luvio, config, snapshot) {
    const resourceParams = createResourceParams$d(config);
    const request = createResourceRequest$j(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$a(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$b(luvio, config, resourceParams, response);
    });
}
const getRelatedListsActionsAdapterFactory = (luvio) => function uiApi__getRelatedListsActions(untrustedConfig) {
    const config = validateAdapterConfig$e(untrustedConfig, getRelatedListsActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$f(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$d(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$d(luvio, config);
};

const getRelatedListActions_ConfigPropertyNames = {
    displayName: 'getRelatedListActions',
    parameters: {
        required: ['recordIds', 'relatedListId'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$e(config) {
    return {
        urlParams: {
            recordIds: config.recordIds, relatedListId: config.relatedListId
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$f(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const relatedListId = config.relatedListId;
    if (relatedListId !== undefined) {
        coercedConfig.relatedListId = relatedListId;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$D(luvio, config) {
    const resourceParams = createResourceParams$e(config);
    return keyBuilder$A(resourceParams);
}
function typeCheckConfig$f(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$f(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$f(untrustedConfig);
    const config = typeCheckConfig$f(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$b(luvio, config) {
    const resourceParams = createResourceParams$e(config);
    return select$r();
}
function buildInMemorySnapshot$g(luvio, config) {
    const selector = {
        recordId: keyBuilder$D(luvio, config),
        node: adapterFragment$b(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$b(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$9(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$c(luvio, config, resourceParams, response) {
    const snapshot = ingestError$b(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$e(luvio, config, override) {
    const resourceParams = createResourceParams$e(config);
    const request = createResourceRequest$i(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$b(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$c(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$e(luvio, config, snapshot) {
    const resourceParams = createResourceParams$e(config);
    const request = createResourceRequest$i(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$b(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$c(luvio, config, resourceParams, response);
    });
}
const getRelatedListActionsAdapterFactory = (luvio) => function uiApi__getRelatedListActions(untrustedConfig) {
    const config = validateAdapterConfig$f(untrustedConfig, getRelatedListActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$g(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$e(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$e(luvio, config);
};

function select$t(luvio, params) {
    return select$l();
}
function keyBuilder$E(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListRecordIds:' + params.urlParams.relatedListRecordIds + ')';
}
function ingestSuccess$b(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$E(resourceParams);
    luvio.storeIngest(key, ingest$e, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$t(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$d(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$E(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$4);
    return errorSnapshot;
}
function createResourceRequest$k(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list-record/' + config.urlParams.relatedListRecordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRelatedListRecordActions_ConfigPropertyNames = {
    displayName: 'getRelatedListRecordActions',
    parameters: {
        required: ['recordIds', 'relatedListRecordIds'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$f(config) {
    return {
        urlParams: {
            recordIds: config.recordIds, relatedListRecordIds: config.relatedListRecordIds
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$g(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const relatedListRecordIds = getRecordId18Array(config.relatedListRecordIds);
    if (relatedListRecordIds !== undefined) {
        coercedConfig.relatedListRecordIds = relatedListRecordIds;
    }
    const actionTypes = toSortedStringArray(config.actionTypes);
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function keyBuilder$F(luvio, config) {
    const resourceParams = createResourceParams$f(config);
    return keyBuilder$E(resourceParams);
}
function typeCheckConfig$g(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_relatedListRecordIds = untrustedConfig.relatedListRecordIds;
    if (ArrayIsArray(untrustedConfig_relatedListRecordIds)) {
        const untrustedConfig_relatedListRecordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListRecordIds.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListRecordIds_item = untrustedConfig_relatedListRecordIds[i];
            if (typeof untrustedConfig_relatedListRecordIds_item === 'string') {
                untrustedConfig_relatedListRecordIds_array.push(untrustedConfig_relatedListRecordIds_item);
            }
        }
        config.relatedListRecordIds = untrustedConfig_relatedListRecordIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$g(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$g(untrustedConfig);
    const config = typeCheckConfig$g(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$c(luvio, config) {
    const resourceParams = createResourceParams$f(config);
    return select$t();
}
function buildInMemorySnapshot$h(luvio, config) {
    const selector = {
        recordId: keyBuilder$F(luvio, config),
        node: adapterFragment$c(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$c(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$b(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$d(luvio, config, resourceParams, response) {
    const snapshot = ingestError$d(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$f(luvio, config, override) {
    const resourceParams = createResourceParams$f(config);
    const request = createResourceRequest$k(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$c(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$d(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$f(luvio, config, snapshot) {
    const resourceParams = createResourceParams$f(config);
    const request = createResourceRequest$k(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$c(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$d(luvio, config, resourceParams, response);
    });
}
const getRelatedListRecordActionsAdapterFactory = (luvio) => function uiApi__getRelatedListRecordActions(untrustedConfig) {
    const config = validateAdapterConfig$g(untrustedConfig, getRelatedListRecordActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$h(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$f(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$f(luvio, config);
};

function validate$x(obj, path = 'PageReferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_attributes = obj.attributes;
        const path_attributes = path + '.attributes';
        if (typeof obj_attributes !== 'object' || ArrayIsArray$1(obj_attributes) || obj_attributes === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_attributes + '" (at "' + path_attributes + '")');
        }
        const obj_attributes_keys = ObjectKeys$1(obj_attributes);
        for (let i = 0; i < obj_attributes_keys.length; i++) {
            const key = obj_attributes_keys[i];
            const obj_attributes_prop = obj_attributes[key];
        }
        const obj_state = obj.state;
        const path_state = path + '.state';
        if (typeof obj_state !== 'object' || ArrayIsArray$1(obj_state) || obj_state === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_state + '" (at "' + path_state + '")');
        }
        const obj_state_keys = ObjectKeys$1(obj_state);
        for (let i = 0; i < obj_state_keys.length; i++) {
            const key = obj_state_keys[i];
            const obj_state_prop = obj_state[key];
            const path_state_prop = path_state + '["' + key + '"]';
            if (typeof obj_state_prop !== 'object' || ArrayIsArray$1(obj_state_prop) || obj_state_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_state_prop + '" (at "' + path_state_prop + '")');
            }
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$f(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$u = function PageReferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        opaque: true
    };
};
function equals$i(existing, incoming) {
    if (JSONStringify$1(incoming) !== JSONStringify$1(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$j(input) {
    const input_attributes = input.attributes;
    const input_attributes_keys = Object.keys(input_attributes);
    const input_attributes_length = input_attributes_keys.length;
    for (let i = 0; i < input_attributes_length; i++) {
        const key = input_attributes_keys[i];
        const input_attributes_prop = input_attributes[key];
        deepFreeze(input_attributes_prop);
    }
    ObjectFreeze$1(input_attributes);
    const input_state = input.state;
    const input_state_keys = Object.keys(input_state);
    const input_state_length = input_state_keys.length;
    for (let i = 0; i < input_state_length; i++) {
        const key = input_state_keys[i];
        const input_state_prop = input_state[key];
        ObjectFreeze$1(input_state_prop);
    }
    ObjectFreeze$1(input_state);
    ObjectFreeze$1(input);
}
const ingest$f = function PageReferenceRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$x(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$f(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$j(input);
    if (existingRecord === undefined || equals$i(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$y(obj, path = 'NavItemRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_availableInClassic = obj.availableInClassic;
        const path_availableInClassic = path + '.availableInClassic';
        if (typeof obj_availableInClassic !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_availableInClassic + '" (at "' + path_availableInClassic + '")');
        }
        const obj_availableInLightning = obj.availableInLightning;
        const path_availableInLightning = path + '.availableInLightning';
        if (typeof obj_availableInLightning !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_availableInLightning + '" (at "' + path_availableInLightning + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_content = obj.content;
        const path_content = path + '.content';
        let obj_content_union0 = null;
        const obj_content_union0_error = (() => {
            if (typeof obj_content !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_content + '" (at "' + path_content + '")');
            }
        })();
        if (obj_content_union0_error != null) {
            obj_content_union0 = obj_content_union0_error.message;
        }
        let obj_content_union1 = null;
        const obj_content_union1_error = (() => {
            if (obj_content !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_content + '" (at "' + path_content + '")');
            }
        })();
        if (obj_content_union1_error != null) {
            obj_content_union1 = obj_content_union1_error.message;
        }
        if (obj_content_union0 && obj_content_union1) {
            let message = 'Object doesn\'t match union (at "' + path_content + '")';
            message += '\n' + obj_content_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_content_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_developerName = obj.developerName;
        const path_developerName = path + '.developerName';
        if (typeof obj_developerName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_developerName + '" (at "' + path_developerName + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        if (typeof obj_iconUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_itemType = obj.itemType;
        const path_itemType = path + '.itemType';
        if (typeof obj_itemType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_itemType + '" (at "' + path_itemType + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_objectLabel = obj.objectLabel;
        const path_objectLabel = path + '.objectLabel';
        let obj_objectLabel_union0 = null;
        const obj_objectLabel_union0_error = (() => {
            if (typeof obj_objectLabel !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectLabel + '" (at "' + path_objectLabel + '")');
            }
        })();
        if (obj_objectLabel_union0_error != null) {
            obj_objectLabel_union0 = obj_objectLabel_union0_error.message;
        }
        let obj_objectLabel_union1 = null;
        const obj_objectLabel_union1_error = (() => {
            if (obj_objectLabel !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_objectLabel + '" (at "' + path_objectLabel + '")');
            }
        })();
        if (obj_objectLabel_union1_error != null) {
            obj_objectLabel_union1 = obj_objectLabel_union1_error.message;
        }
        if (obj_objectLabel_union0 && obj_objectLabel_union1) {
            let message = 'Object doesn\'t match union (at "' + path_objectLabel + '")';
            message += '\n' + obj_objectLabel_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_objectLabel_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectLabelPlural = obj.objectLabelPlural;
        const path_objectLabelPlural = path + '.objectLabelPlural';
        let obj_objectLabelPlural_union0 = null;
        const obj_objectLabelPlural_union0_error = (() => {
            if (typeof obj_objectLabelPlural !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectLabelPlural + '" (at "' + path_objectLabelPlural + '")');
            }
        })();
        if (obj_objectLabelPlural_union0_error != null) {
            obj_objectLabelPlural_union0 = obj_objectLabelPlural_union0_error.message;
        }
        let obj_objectLabelPlural_union1 = null;
        const obj_objectLabelPlural_union1_error = (() => {
            if (obj_objectLabelPlural !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_objectLabelPlural + '" (at "' + path_objectLabelPlural + '")');
            }
        })();
        if (obj_objectLabelPlural_union1_error != null) {
            obj_objectLabelPlural_union1 = obj_objectLabelPlural_union1_error.message;
        }
        if (obj_objectLabelPlural_union0 && obj_objectLabelPlural_union1) {
            let message = 'Object doesn\'t match union (at "' + path_objectLabelPlural + '")';
            message += '\n' + obj_objectLabelPlural_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_objectLabelPlural_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_pageReference = obj.pageReference;
        const path_pageReference = path + '.pageReference';
        let obj_pageReference_union0 = null;
        const obj_pageReference_union0_error = (() => {
            if (typeof obj_pageReference !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_pageReference + '" (at "' + path_pageReference + '")');
            }
        })();
        if (obj_pageReference_union0_error != null) {
            obj_pageReference_union0 = obj_pageReference_union0_error.message;
        }
        let obj_pageReference_union1 = null;
        const obj_pageReference_union1_error = (() => {
            if (obj_pageReference !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_pageReference + '" (at "' + path_pageReference + '")');
            }
        })();
        if (obj_pageReference_union1_error != null) {
            obj_pageReference_union1 = obj_pageReference_union1_error.message;
        }
        if (obj_pageReference_union0 && obj_pageReference_union1) {
            let message = 'Object doesn\'t match union (at "' + path_pageReference + '")';
            message += '\n' + obj_pageReference_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_pageReference_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_standardType = obj.standardType;
        const path_standardType = path + '.standardType';
        let obj_standardType_union0 = null;
        const obj_standardType_union0_error = (() => {
            if (typeof obj_standardType !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_standardType + '" (at "' + path_standardType + '")');
            }
        })();
        if (obj_standardType_union0_error != null) {
            obj_standardType_union0 = obj_standardType_union0_error.message;
        }
        let obj_standardType_union1 = null;
        const obj_standardType_union1_error = (() => {
            if (obj_standardType !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_standardType + '" (at "' + path_standardType + '")');
            }
        })();
        if (obj_standardType_union1_error != null) {
            obj_standardType_union1 = obj_standardType_union1_error.message;
        }
        if (obj_standardType_union0 && obj_standardType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_standardType + '")';
            message += '\n' + obj_standardType_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_standardType_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$G(config) {
    return keyPrefix + 'NavItemRepresentation:' + config.developerName;
}
function keyBuilderFromType$d(object) {
    const keyParams = {
        developerName: object.developerName
    };
    return keyBuilder$G(keyParams);
}
function normalize$g(input, existing, path, luvio, store, timestamp) {
    const input_pageReference = input.pageReference;
    const input_pageReference_id = path.fullPath + '__pageReference';
    if (input_pageReference !== null && typeof input_pageReference === 'object') {
        input.pageReference = ingest$f(input_pageReference, {
            fullPath: input_pageReference_id,
            propertyName: 'pageReference',
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store);
    }
    return input;
}
const select$v = function NavItemRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'availableInClassic',
                kind: 'Scalar'
            },
            {
                name: 'availableInLightning',
                kind: 'Scalar'
            },
            {
                name: 'color',
                kind: 'Scalar'
            },
            {
                name: 'content',
                kind: 'Scalar'
            },
            {
                name: 'custom',
                kind: 'Scalar'
            },
            {
                name: 'developerName',
                kind: 'Scalar'
            },
            {
                name: 'iconUrl',
                kind: 'Scalar'
            },
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'itemType',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'objectApiName',
                kind: 'Scalar'
            },
            {
                name: 'objectLabel',
                kind: 'Scalar'
            },
            {
                name: 'objectLabelPlural',
                kind: 'Scalar'
            },
            {
                name: 'pageReference',
                kind: 'Link',
                nullable: true,
                fragment: select$u()
            },
            {
                name: 'standardType',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$j(existing, incoming) {
    const existing_availableInClassic = existing.availableInClassic;
    const incoming_availableInClassic = incoming.availableInClassic;
    if (!(existing_availableInClassic === incoming_availableInClassic)) {
        return false;
    }
    const existing_availableInLightning = existing.availableInLightning;
    const incoming_availableInLightning = incoming.availableInLightning;
    if (!(existing_availableInLightning === incoming_availableInLightning)) {
        return false;
    }
    const existing_custom = existing.custom;
    const incoming_custom = incoming.custom;
    if (!(existing_custom === incoming_custom)) {
        return false;
    }
    const existing_color = existing.color;
    const incoming_color = incoming.color;
    if (!(existing_color === incoming_color)) {
        return false;
    }
    const existing_developerName = existing.developerName;
    const incoming_developerName = incoming.developerName;
    if (!(existing_developerName === incoming_developerName)) {
        return false;
    }
    const existing_iconUrl = existing.iconUrl;
    const incoming_iconUrl = incoming.iconUrl;
    if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
    }
    const existing_itemType = existing.itemType;
    const incoming_itemType = incoming.itemType;
    if (!(existing_itemType === incoming_itemType)) {
        return false;
    }
    const existing_label = existing.label;
    const incoming_label = incoming.label;
    if (!(existing_label === incoming_label)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_content = existing.content;
    const incoming_content = incoming.content;
    if (!(existing_content === incoming_content)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_objectLabel = existing.objectLabel;
    const incoming_objectLabel = incoming.objectLabel;
    if (!(existing_objectLabel === incoming_objectLabel)) {
        return false;
    }
    const existing_objectLabelPlural = existing.objectLabelPlural;
    const incoming_objectLabelPlural = incoming.objectLabelPlural;
    if (!(existing_objectLabelPlural === incoming_objectLabelPlural)) {
        return false;
    }
    const existing_pageReference = existing.pageReference;
    const incoming_pageReference = incoming.pageReference;
    if (!(existing_pageReference === incoming_pageReference
        || (existing_pageReference != null &&
            incoming_pageReference != null &&
            existing_pageReference.__ref != null &&
            incoming_pageReference.__ref != null &&
            existing_pageReference.__ref === incoming_pageReference.__ref))) {
        return false;
    }
    const existing_standardType = existing.standardType;
    const incoming_standardType = incoming.standardType;
    if (!(existing_standardType === incoming_standardType)) {
        return false;
    }
    return true;
}
const ingest$g = function NavItemRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$y(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$d(input);
    let incomingRecord = normalize$g(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$j(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 120000);
    return createLink(key);
};

function validate$B(obj, path = 'DuplicateRuleFilterItemRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_field = obj.field;
        const path_field = path + '.field';
        if (typeof obj_field !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_field + '" (at "' + path_field + '")');
        }
        const obj_operation = obj.operation;
        const path_operation = path + '.operation';
        if (typeof obj_operation !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operation + '" (at "' + path_operation + '")');
        }
        const obj_sortOrder = obj.sortOrder;
        const path_sortOrder = path + '.sortOrder';
        if (typeof obj_sortOrder !== 'number' || (typeof obj_sortOrder === 'number' && Math.floor(obj_sortOrder) !== obj_sortOrder)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_sortOrder + '" (at "' + path_sortOrder + '")');
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$A = function DuplicateRuleFilterItemRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'field',
                kind: 'Scalar'
            },
            {
                name: 'operation',
                kind: 'Scalar'
            },
            {
                name: 'sortOrder',
                kind: 'Scalar'
            },
            {
                name: 'value',
                kind: 'Scalar'
            }
        ]
    };
};

function validate$C(obj, path = 'DuplicateRuleFilterRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_booleanFilter = obj.booleanFilter;
        const path_booleanFilter = path + '.booleanFilter';
        if (typeof obj_booleanFilter !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_booleanFilter + '" (at "' + path_booleanFilter + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterItems = obj.filterItems;
        const path_filterItems = path + '.filterItems';
        if (!ArrayIsArray$1(obj_filterItems)) {
            return new TypeError('Expected "array" but received "' + typeof obj_filterItems + '" (at "' + path_filterItems + '")');
        }
        for (let i = 0; i < obj_filterItems.length; i++) {
            const obj_filterItems_item = obj_filterItems[i];
            const path_filterItems_item = path_filterItems + '[' + i + ']';
            const referencepath_filterItems_itemValidationError = validate$B(obj_filterItems_item, path_filterItems_item);
            if (referencepath_filterItems_itemValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateRuleFilterItemRepresentation (at "' + path_filterItems_item + '")\n';
                message += referencepath_filterItems_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_ruleCritera = obj.ruleCritera;
        const path_ruleCritera = path + '.ruleCritera';
        if (typeof obj_ruleCritera !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_ruleCritera + '" (at "' + path_ruleCritera + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$B = function DuplicateRuleFilterRepresentationSelect() {
    const { selections: DuplicateRuleFilterItemRepresentation__selections, opaque: DuplicateRuleFilterItemRepresentation__opaque, } = select$A();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'booleanFilter',
                kind: 'Scalar'
            },
            {
                name: 'filterItems',
                kind: 'Object',
                plural: true,
                selections: DuplicateRuleFilterItemRepresentation__selections
            },
            {
                name: 'ruleCritera',
                kind: 'Scalar'
            }
        ]
    };
};

function validate$D(obj, path = 'MatchRuleRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_matchEngine = obj.matchEngine;
        const path_matchEngine = path + '.matchEngine';
        if (typeof obj_matchEngine !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_matchEngine + '" (at "' + path_matchEngine + '")');
        }
        const obj_matchFields = obj.matchFields;
        const path_matchFields = path + '.matchFields';
        if (!ArrayIsArray$1(obj_matchFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_matchFields + '" (at "' + path_matchFields + '")');
        }
        for (let i = 0; i < obj_matchFields.length; i++) {
            const obj_matchFields_item = obj_matchFields[i];
            const path_matchFields_item = path_matchFields + '[' + i + ']';
            if (typeof obj_matchFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_matchFields_item + '" (at "' + path_matchFields_item + '")');
            }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$C = function MatchRuleRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'matchEngine',
                kind: 'Scalar'
            },
            {
                name: 'matchFields',
                kind: 'Scalar',
                plural: true
            },
            {
                name: 'name',
                kind: 'Scalar'
            },
            {
                name: 'objectApiName',
                kind: 'Scalar'
            }
        ]
    };
};

function validate$E(obj, path = 'DuplicateRuleRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionOnInsert = obj.actionOnInsert;
        const path_actionOnInsert = path + '.actionOnInsert';
        if (typeof obj_actionOnInsert !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionOnInsert + '" (at "' + path_actionOnInsert + '")');
        }
        const obj_actionOnUpdate = obj.actionOnUpdate;
        const path_actionOnUpdate = path + '.actionOnUpdate';
        if (typeof obj_actionOnUpdate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionOnUpdate + '" (at "' + path_actionOnUpdate + '")');
        }
        const obj_active = obj.active;
        const path_active = path + '.active';
        if (typeof obj_active !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_active + '" (at "' + path_active + '")');
        }
        const obj_duplicateRuleFilters = obj.duplicateRuleFilters;
        const path_duplicateRuleFilters = path + '.duplicateRuleFilters';
        if (!ArrayIsArray$1(obj_duplicateRuleFilters)) {
            return new TypeError('Expected "array" but received "' + typeof obj_duplicateRuleFilters + '" (at "' + path_duplicateRuleFilters + '")');
        }
        for (let i = 0; i < obj_duplicateRuleFilters.length; i++) {
            const obj_duplicateRuleFilters_item = obj_duplicateRuleFilters[i];
            const path_duplicateRuleFilters_item = path_duplicateRuleFilters + '[' + i + ']';
            const referencepath_duplicateRuleFilters_itemValidationError = validate$C(obj_duplicateRuleFilters_item, path_duplicateRuleFilters_item);
            if (referencepath_duplicateRuleFilters_itemValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateRuleFilterRepresentation (at "' + path_duplicateRuleFilters_item + '")\n';
                message += referencepath_duplicateRuleFilters_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_matchRules = obj.matchRules;
        const path_matchRules = path + '.matchRules';
        if (!ArrayIsArray$1(obj_matchRules)) {
            return new TypeError('Expected "array" but received "' + typeof obj_matchRules + '" (at "' + path_matchRules + '")');
        }
        for (let i = 0; i < obj_matchRules.length; i++) {
            const obj_matchRules_item = obj_matchRules[i];
            const path_matchRules_item = path_matchRules + '[' + i + ']';
            const referencepath_matchRules_itemValidationError = validate$D(obj_matchRules_item, path_matchRules_item);
            if (referencepath_matchRules_itemValidationError !== null) {
                let message = 'Object doesn\'t match MatchRuleRepresentation (at "' + path_matchRules_item + '")\n';
                message += referencepath_matchRules_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_operationsOnInsert = obj.operationsOnInsert;
        const path_operationsOnInsert = path + '.operationsOnInsert';
        if (!ArrayIsArray$1(obj_operationsOnInsert)) {
            return new TypeError('Expected "array" but received "' + typeof obj_operationsOnInsert + '" (at "' + path_operationsOnInsert + '")');
        }
        for (let i = 0; i < obj_operationsOnInsert.length; i++) {
            const obj_operationsOnInsert_item = obj_operationsOnInsert[i];
            const path_operationsOnInsert_item = path_operationsOnInsert + '[' + i + ']';
            if (typeof obj_operationsOnInsert_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_operationsOnInsert_item + '" (at "' + path_operationsOnInsert_item + '")');
            }
        }
        const obj_operationsOnUpdate = obj.operationsOnUpdate;
        const path_operationsOnUpdate = path + '.operationsOnUpdate';
        if (!ArrayIsArray$1(obj_operationsOnUpdate)) {
            return new TypeError('Expected "array" but received "' + typeof obj_operationsOnUpdate + '" (at "' + path_operationsOnUpdate + '")');
        }
        for (let i = 0; i < obj_operationsOnUpdate.length; i++) {
            const obj_operationsOnUpdate_item = obj_operationsOnUpdate[i];
            const path_operationsOnUpdate_item = path_operationsOnUpdate + '[' + i + ']';
            if (typeof obj_operationsOnUpdate_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_operationsOnUpdate_item + '" (at "' + path_operationsOnUpdate_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$D = function DuplicateRuleRepresentationSelect() {
    const { selections: DuplicateRuleFilterRepresentation__selections, opaque: DuplicateRuleFilterRepresentation__opaque, } = select$B();
    const { selections: MatchRuleRepresentation__selections, opaque: MatchRuleRepresentation__opaque, } = select$C();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'actionOnInsert',
                kind: 'Scalar'
            },
            {
                name: 'actionOnUpdate',
                kind: 'Scalar'
            },
            {
                name: 'active',
                kind: 'Scalar'
            },
            {
                name: 'duplicateRuleFilters',
                kind: 'Object',
                plural: true,
                selections: DuplicateRuleFilterRepresentation__selections
            },
            {
                name: 'matchRules',
                kind: 'Object',
                plural: true,
                selections: MatchRuleRepresentation__selections
            },
            {
                name: 'name',
                kind: 'Scalar'
            },
            {
                name: 'operationsOnInsert',
                kind: 'Scalar',
                plural: true
            },
            {
                name: 'operationsOnUpdate',
                kind: 'Scalar',
                plural: true
            }
        ]
    };
};

const TTL$6 = 900000;
function validate$F(obj, path = 'DuplicatesConfigurationRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_dedupeEnabled = obj.dedupeEnabled;
        const path_dedupeEnabled = path + '.dedupeEnabled';
        if (typeof obj_dedupeEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_dedupeEnabled + '" (at "' + path_dedupeEnabled + '")');
        }
        const obj_dedupeFields = obj.dedupeFields;
        const path_dedupeFields = path + '.dedupeFields';
        if (!ArrayIsArray$1(obj_dedupeFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_dedupeFields + '" (at "' + path_dedupeFields + '")');
        }
        for (let i = 0; i < obj_dedupeFields.length; i++) {
            const obj_dedupeFields_item = obj_dedupeFields[i];
            const path_dedupeFields_item = path_dedupeFields + '[' + i + ']';
            if (typeof obj_dedupeFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_dedupeFields_item + '" (at "' + path_dedupeFields_item + '")');
            }
        }
        const obj_duplicateRules = obj.duplicateRules;
        const path_duplicateRules = path + '.duplicateRules';
        if (!ArrayIsArray$1(obj_duplicateRules)) {
            return new TypeError('Expected "array" but received "' + typeof obj_duplicateRules + '" (at "' + path_duplicateRules + '")');
        }
        for (let i = 0; i < obj_duplicateRules.length; i++) {
            const obj_duplicateRules_item = obj_duplicateRules[i];
            const path_duplicateRules_item = path_duplicateRules + '[' + i + ']';
            const referencepath_duplicateRules_itemValidationError = validate$E(obj_duplicateRules_item, path_duplicateRules_item);
            if (referencepath_duplicateRules_itemValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateRuleRepresentation (at "' + path_duplicateRules_item + '")\n';
                message += referencepath_duplicateRules_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_predupeEnabled = obj.predupeEnabled;
        const path_predupeEnabled = path + '.predupeEnabled';
        if (typeof obj_predupeEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_predupeEnabled + '" (at "' + path_predupeEnabled + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$j(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$E = function DuplicatesConfigurationRepresentationSelect() {
    const { selections: DuplicateRuleRepresentation__selections, opaque: DuplicateRuleRepresentation__opaque, } = select$D();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'dedupeEnabled',
                kind: 'Scalar'
            },
            {
                name: 'dedupeFields',
                kind: 'Scalar',
                plural: true
            },
            {
                name: 'duplicateRules',
                kind: 'Object',
                plural: true,
                selections: DuplicateRuleRepresentation__selections
            },
            {
                name: 'predupeEnabled',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$m(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
const ingest$j = function DuplicatesConfigurationRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$F(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$j(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$m(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function select$F(luvio, params) {
    return select$E();
}
function keyBuilder$L(params) {
    return keyPrefix + 'DuplicatesConfigurationRepresentation(' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
}
function ingestSuccess$e(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$L(resourceParams);
    luvio.storeIngest(key, ingest$j, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$F(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$g(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$L(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$6);
    return errorSnapshot;
}
function createResourceRequest$n(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/duplicates/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getDuplicateConfiguration_ConfigPropertyNames = {
    displayName: 'getDuplicateConfiguration',
    parameters: {
        required: ['objectApiName'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$i(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function keyBuilder$M(luvio, config) {
    const resourceParams = createResourceParams$i(config);
    return keyBuilder$L(resourceParams);
}
function typeCheckConfig$j(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$j(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$j(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$f(luvio, config) {
    const resourceParams = createResourceParams$i(config);
    return select$F();
}
function buildInMemorySnapshot$k(luvio, config) {
    const selector = {
        recordId: keyBuilder$M(luvio, config),
        node: adapterFragment$f(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$f(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$e(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$g(luvio, config, resourceParams, response) {
    const snapshot = ingestError$g(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$i(luvio, config, override) {
    const resourceParams = createResourceParams$i(config);
    const request = createResourceRequest$n(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$f(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$g(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$i(luvio, config, snapshot) {
    const resourceParams = createResourceParams$i(config);
    const request = createResourceRequest$n(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$f(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$g(luvio, config, resourceParams, response);
    });
}
const getDuplicateConfigurationAdapterFactory = (luvio) => function uiApi__getDuplicateConfiguration(untrustedConfig) {
    const config = validateAdapterConfig$j(untrustedConfig, getDuplicateConfiguration_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$k(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$i(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$i(luvio, config);
};

function select$G(luvio, params) {
    return select$5();
}
function keyBuilder$N(params) {
    return keyBuilder$1({
        objectApiName: params.urlParams.objectApiName,
        listViewApiName: params.urlParams.listViewApiName,
        type: "listView"
    });
}
function ingestSuccess$f(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$N(resourceParams);
    luvio.storeIngest(key, ingest$1, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$G(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$h(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$N(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL);
    return errorSnapshot;
}
function createResourceRequest$o(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/list-info/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const getListInfoByName_ConfigPropertyNames = {
    displayName: 'getListInfoByName',
    parameters: {
        required: ['listViewApiName', 'objectApiName'],
        optional: []
    }
};
function createResourceParams$j(config) {
    return {
        urlParams: {
            listViewApiName: config.listViewApiName, objectApiName: config.objectApiName
        }
    };
}
function keyBuilder$O(luvio, config) {
    const resourceParams = createResourceParams$j(config);
    return keyBuilder$N(resourceParams);
}
function typeCheckConfig$k(untrustedConfig) {
    const config = {};
    const untrustedConfig_listViewApiName = untrustedConfig.listViewApiName;
    if (typeof untrustedConfig_listViewApiName === 'string') {
        config.listViewApiName = untrustedConfig_listViewApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    return config;
}
function validateAdapterConfig$k(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$k(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$g(luvio, config) {
    const resourceParams = createResourceParams$j(config);
    return select$G();
}
function buildInMemorySnapshot$l(luvio, config) {
    const selector = {
        recordId: keyBuilder$O(luvio, config),
        node: adapterFragment$g(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$g(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$f(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$h(luvio, config, resourceParams, response) {
    const snapshot = ingestError$h(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$j(luvio, config, override) {
    const resourceParams = createResourceParams$j(config);
    const request = createResourceRequest$o(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$g(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$h(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$j(luvio, config, snapshot) {
    const resourceParams = createResourceParams$j(config);
    const request = createResourceRequest$o(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$g(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$h(luvio, config, resourceParams, response);
    });
}
const getListInfoByNameAdapterFactory = (luvio) => function uiApi__getListInfoByName(untrustedConfig) {
    const config = validateAdapterConfig$k(untrustedConfig, getListInfoByName_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$l(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$j(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$j(luvio, config);
};

const TTL$7 = 120000;
function validate$G(obj, path = 'NavItemsRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_navItems = obj.navItems;
        const path_navItems = path + '.navItems';
        if (!ArrayIsArray$1(obj_navItems)) {
            return new TypeError('Expected "array" but received "' + typeof obj_navItems + '" (at "' + path_navItems + '")');
        }
        for (let i = 0; i < obj_navItems.length; i++) {
            const obj_navItems_item = obj_navItems[i];
            const path_navItems_item = path_navItems + '[' + i + ']';
            if (typeof obj_navItems_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_navItems_item + '" (at "' + path_navItems_item + '")');
            }
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$k(input, existing, path, luvio, store, timestamp) {
    const input_navItems = input.navItems;
    const input_navItems_id = path.fullPath + '__navItems';
    for (let i = 0; i < input_navItems.length; i++) {
        const input_navItems_item = input_navItems[i];
        let input_navItems_item_id = input_navItems_id + '__' + i;
        input_navItems[i] = ingest$g(input_navItems_item, {
            fullPath: input_navItems_item_id,
            propertyName: i,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
const select$H = function NavItemsRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag',
            'currentPageUrl'
        ],
        selections: [
            {
                name: 'navItems',
                kind: 'Link',
                plural: true,
                fragment: select$v()
            },
            {
                name: 'nextPageUrl',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$n(existing, incoming) {
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_navItems = existing.navItems;
    const incoming_navItems = incoming.navItems;
    const equals_navItems_items = equalsArray(existing_navItems, incoming_navItems, (existing_navItems_item, incoming_navItems_item) => {
        if (!(existing_navItems_item.__ref === incoming_navItems_item.__ref)) {
            return false;
        }
    });
    if (equals_navItems_items === false) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    return true;
}
const ingest$k = function NavItemsRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$G(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$k(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$n(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 120000);
    return createLink(key);
};

function select$I(luvio, params) {
    return select$H();
}
function keyBuilder$P(params) {
    return keyPrefix + 'NavItemsRepresentation(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'navItemNames:' + params.queryParams.navItemNames + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ')';
}
function ingestSuccess$g(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$P(resourceParams);
    luvio.storeIngest(key, ingest$k, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$I(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$i(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$P(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$7);
    return errorSnapshot;
}
function createResourceRequest$p(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/nav-items',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
    };
}

const getNavItems_ConfigPropertyNames = {
    displayName: 'getNavItems',
    parameters: {
        required: [],
        optional: ['formFactor', 'navItemNames', 'page', 'pageSize']
    }
};
function createResourceParams$k(config) {
    return {
        queryParams: {
            formFactor: config.formFactor, navItemNames: config.navItemNames, page: config.page, pageSize: config.pageSize
        }
    };
}
function coerceConfig$h(config) {
    const coercedConfig = {};
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const navItemNames = config.navItemNames;
    if (navItemNames !== undefined) {
        coercedConfig.navItemNames = navItemNames;
    }
    const page = config.page;
    if (page !== undefined) {
        coercedConfig.page = page;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    return coercedConfig;
}
function keyBuilder$Q(luvio, config) {
    const resourceParams = createResourceParams$k(config);
    return keyBuilder$P(resourceParams);
}
function typeCheckConfig$l(untrustedConfig) {
    const config = {};
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_navItemNames = untrustedConfig.navItemNames;
    if (ArrayIsArray(untrustedConfig_navItemNames)) {
        const untrustedConfig_navItemNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_navItemNames.length; i < arrayLength; i++) {
            const untrustedConfig_navItemNames_item = untrustedConfig_navItemNames[i];
            if (typeof untrustedConfig_navItemNames_item === 'string') {
                untrustedConfig_navItemNames_array.push(untrustedConfig_navItemNames_item);
            }
        }
        config.navItemNames = untrustedConfig_navItemNames_array;
    }
    const untrustedConfig_page = untrustedConfig.page;
    if (typeof untrustedConfig_page === 'number' && Math.floor(untrustedConfig_page) === untrustedConfig_page) {
        config.page = untrustedConfig_page;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    return config;
}
function validateAdapterConfig$l(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$h(untrustedConfig);
    const config = typeCheckConfig$l(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$h(luvio, config) {
    const resourceParams = createResourceParams$k(config);
    return select$I();
}
function buildInMemorySnapshot$m(luvio, config) {
    const selector = {
        recordId: keyBuilder$Q(luvio, config),
        node: adapterFragment$h(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$k(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$h(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$g(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$k(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$i(luvio, config, resourceParams, response) {
    const snapshot = ingestError$i(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$k(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$k(luvio, config, override) {
    const resourceParams = createResourceParams$k(config);
    const request = createResourceRequest$p(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$h(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$i(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$k(luvio, config, snapshot) {
    const resourceParams = createResourceParams$k(config);
    const request = createResourceRequest$p(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$h(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$i(luvio, config, resourceParams, response);
    });
}
const getNavItemsAdapterFactory = (luvio) => function uiApi__getNavItems(untrustedConfig) {
    const config = validateAdapterConfig$l(untrustedConfig, getNavItems_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$m(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$k(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$k(luvio, config);
};

const nonCachedErrors$2 = ObjectCreate(null);
function createChildResourceParams$2(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.objectApiNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.objectApiNames[index];
        childConfigs.push({
            urlParams: {
                objectApiName: item
            }
        });
    }
    return childConfigs;
}
function selectChildResourceParams$2(luvio, childResources) {
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$g(childResource);
                const childFragment = select$g();
                const isMissingDataBeforeChildRead = reader.isMissingData;
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                reader.seenIds[childKey] = true;
                switch (childSnapshot.state) {
                    case 'Stale':
                        reader.markStale();
                    // Stale needs envelope bodies filled in so don't break
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        // if child snapshot doesn't have any data then
                        // that means the child record key is missing
                        if (childSnapshot.data === undefined) {
                            if (reader.baseSnapshot === undefined) {
                                // not a rebuild, mark as missing and move on
                                reader.markMissingLink(childKey);
                                break;
                            }
                            // On rebuilds we have to check if there is a non-cached
                            // error that we know about.  If we don't do this then
                            // rebuilds will go into endless refresh loop if a child
                            // has non-cached errors (since the top-level composite
                            // snapshot will look like an Unfulfilled snapshot
                            // instead of an error snapshot).
                            const nonCachedError = nonCachedErrors$2[childKey];
                            if (nonCachedError === undefined || nonCachedError.expiration < reader.timestamp) {
                                reader.markMissingLink(childKey);
                            }
                            else {
                                // if this child error was the only reason the reader
                                // is marked as missing then we want to undo that
                                if (isMissingDataBeforeChildRead === false) {
                                    reader.unMarkMissing();
                                }
                                // put status code and body into reader path
                                const { response: nonCachedBody, status: nonCachedStatus } = nonCachedError;
                                reader.enterPath(envelopeStatusCodePath);
                                reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                                reader.exitPath();
                                reader.enterPath(envelopeBodyPath);
                                reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                                reader.exitPath();
                            }
                        }
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function select$J(luvio, resourceParams) {
    const childResources = createChildResourceParams$2(resourceParams);
    return selectChildResourceParams$2(luvio, childResources);
}
function keyBuilder$R(params) {
    return keyPrefix + 'SimplifiedBatchRepresentation(' + 'objectApiNames:' + params.urlParams.objectApiNames + ')';
}
function ingestSuccessChildResourceParams$2(luvio, childResourceParamsArray, childEnvelopes) {
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    let snapshotState = 'Fulfilled';
    const now = Date.now();
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$g(childResourceParams);
        const result = childEnvelopes[index];
        const { statusCode: childStatusCode, result: childBody } = result;
        if (childStatusCode === 200) {
            const childResponse = {
                status: 200,
                body: childBody,
                ok: true,
                statusText: 'OK',
                headers: undefined,
            };
            const childSnapshot = ingestSuccess$3(luvio, childResourceParams, childResponse);
            if (childSnapshot.state === "Stale") {
                snapshotState = "Stale";
            }
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: 200,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        else {
            const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$4(luvio, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [childKey]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
            nonCachedErrors$2[childKey] = { expiration: now + TTL$2, response: childBody, status: childStatusCode };
        }
        else {
            delete nonCachedErrors$2[childKey];
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    return { childSnapshotData: ObjectFreeze(childSnapshotData), seenRecords, snapshotState };
}
function ingestSuccess$h(luvio, resourceParams, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$2(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const key = keyBuilder$R(resourceParams);
    const { childSnapshotData, seenRecords, snapshotState } = ingestSuccessChildResourceParams$2(luvio, childResourceParamsArray, childEnvelopes);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$J(luvio, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$j(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$R(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$q(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/object-info/batch/' + config.urlParams.objectApiNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const getObjectInfos_ConfigPropertyNames = {
    displayName: 'getObjectInfos',
    parameters: {
        required: ['objectApiNames'],
        optional: []
    }
};
function createResourceParams$l(config) {
    return {
        urlParams: {
            objectApiNames: config.objectApiNames
        }
    };
}
function coerceConfig$i(config) {
    const coercedConfig = {};
    const objectApiNames = getObjectApiNamesArray(config.objectApiNames);
    if (objectApiNames !== undefined) {
        coercedConfig.objectApiNames = objectApiNames;
    }
    return coercedConfig;
}
function keyBuilder$S(luvio, config) {
    const resourceParams = createResourceParams$l(config);
    return keyBuilder$R(resourceParams);
}
function typeCheckConfig$m(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiNames = untrustedConfig.objectApiNames;
    if (ArrayIsArray(untrustedConfig_objectApiNames)) {
        const untrustedConfig_objectApiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_objectApiNames.length; i < arrayLength; i++) {
            const untrustedConfig_objectApiNames_item = untrustedConfig_objectApiNames[i];
            if (typeof untrustedConfig_objectApiNames_item === 'string') {
                untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);
            }
        }
        config.objectApiNames = untrustedConfig_objectApiNames_array;
    }
    return config;
}
function validateAdapterConfig$m(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$i(untrustedConfig);
    const config = typeCheckConfig$m(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$i(luvio, config) {
    const resourceParams = createResourceParams$l(config);
    return select$J(luvio, resourceParams);
}
function buildInMemorySnapshot$n(luvio, config) {
    const selector = {
        recordId: keyBuilder$S(luvio, config),
        node: adapterFragment$i(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$i(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$h(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$j(luvio, config, resourceParams, response) {
    const snapshot = ingestError$j(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$l(luvio, config, override) {
    const resourceParams = createResourceParams$l(config);
    const request = createResourceRequest$q(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$i(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$j(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$l(luvio, config, snapshot) {
    const resourceParams = createResourceParams$l(config);
    const request = createResourceRequest$q(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$i(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$j(luvio, config, resourceParams, response);
    });
}
const getObjectInfosAdapterFactory = (luvio) => function uiApi__getObjectInfos(untrustedConfig) {
    const config = validateAdapterConfig$m(untrustedConfig, getObjectInfos_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$n(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$l(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$l(luvio, config);
};

const select$K = function LeadStatusPicklistValueAttributesRepresentationSelect() {
    const { selections: AbstractPicklistValueAttributesRepresentationSelections } = select$N();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractPicklistValueAttributesRepresentationSelections,
            {
                name: 'converted',
                kind: 'Scalar'
            }
        ]
    };
};

const select$L = function CaseStatusPicklistValueAttributesRepresentationSelect() {
    const { selections: AbstractPicklistValueAttributesRepresentationSelections } = select$N();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractPicklistValueAttributesRepresentationSelections,
            {
                name: 'closed',
                kind: 'Scalar'
            }
        ]
    };
};

const select$M = function OpportunityStagePicklistValueAttributesRepresentationSelect() {
    const { selections: AbstractPicklistValueAttributesRepresentationSelections } = select$N();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractPicklistValueAttributesRepresentationSelections,
            {
                name: 'closed',
                kind: 'Scalar'
            },
            {
                name: 'defaultProbability',
                kind: 'Scalar'
            },
            {
                name: 'forecastCategoryName',
                kind: 'Scalar'
            },
            {
                name: 'won',
                kind: 'Scalar'
            }
        ]
    };
};

var DiscriminatorValues$1;
(function (DiscriminatorValues) {
    DiscriminatorValues["LeadStatus"] = "LeadStatus";
    DiscriminatorValues["CaseStatus"] = "CaseStatus";
    DiscriminatorValues["OpportunityStage"] = "OpportunityStage";
})(DiscriminatorValues$1 || (DiscriminatorValues$1 = {}));
function validate$H(obj, path = 'AbstractPicklistValueAttributesRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_picklistAtrributesValueType = obj.picklistAtrributesValueType;
        const path_picklistAtrributesValueType = path + '.picklistAtrributesValueType';
        if (typeof obj_picklistAtrributesValueType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_picklistAtrributesValueType + '" (at "' + path_picklistAtrributesValueType + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const selectChildren = function AbstractPicklistValueAttributesRepresentationSelectChildren() {
    const leadStatusPicklistValueAttributesRepresentationSelections = select$K();
    const caseStatusPicklistValueAttributesRepresentationSelections = select$L();
    const opportunityStagePicklistValueAttributesRepresentationSelections = select$M();
    return {
        kind: 'Fragment',
        union: true,
        discriminator: 'picklistAtrributesValueType',
        unionSelections: {
            [DiscriminatorValues$1.LeadStatus]: leadStatusPicklistValueAttributesRepresentationSelections,
            [DiscriminatorValues$1.CaseStatus]: caseStatusPicklistValueAttributesRepresentationSelections,
            [DiscriminatorValues$1.OpportunityStage]: opportunityStagePicklistValueAttributesRepresentationSelections
        }
    };
};
const select$N = function AbstractPicklistValueAttributesRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'picklistAtrributesValueType',
                kind: 'Scalar'
            }
        ]
    };
};

function validate$I(obj, path = 'PicklistValueRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_attributes = obj.attributes;
        const path_attributes = path + '.attributes';
        let obj_attributes_union0 = null;
        const obj_attributes_union0_error = (() => {
            const referencepath_attributesValidationError = validate$H(obj_attributes, path_attributes);
            if (referencepath_attributesValidationError !== null) {
                let message = 'Object doesn\'t match AbstractPicklistValueAttributesRepresentation (at "' + path_attributes + '")\n';
                message += referencepath_attributesValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_attributes_union0_error != null) {
            obj_attributes_union0 = obj_attributes_union0_error.message;
        }
        let obj_attributes_union1 = null;
        const obj_attributes_union1_error = (() => {
            if (obj_attributes !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_attributes + '" (at "' + path_attributes + '")');
            }
        })();
        if (obj_attributes_union1_error != null) {
            obj_attributes_union1 = obj_attributes_union1_error.message;
        }
        if (obj_attributes_union0 && obj_attributes_union1) {
            let message = 'Object doesn\'t match union (at "' + path_attributes + '")';
            message += '\n' + obj_attributes_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_attributes_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_validFor = obj.validFor;
        const path_validFor = path + '.validFor';
        if (!ArrayIsArray$1(obj_validFor)) {
            return new TypeError('Expected "array" but received "' + typeof obj_validFor + '" (at "' + path_validFor + '")');
        }
        for (let i = 0; i < obj_validFor.length; i++) {
            const obj_validFor_item = obj_validFor[i];
            const path_validFor_item = path_validFor + '[' + i + ']';
            if (typeof obj_validFor_item !== 'number' || (typeof obj_validFor_item === 'number' && Math.floor(obj_validFor_item) !== obj_validFor_item)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_validFor_item + '" (at "' + path_validFor_item + '")');
            }
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$O = function PicklistValueRepresentationSelect() {
    const AbstractPicklistValueAttributesRepresentation__unionSelections = selectChildren();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                kind: 'Object',
                name: 'attributes',
                discriminator: AbstractPicklistValueAttributesRepresentation__unionSelections.discriminator,
                union: true,
                nullable: true,
                unionSelections: AbstractPicklistValueAttributesRepresentation__unionSelections.unionSelections
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'validFor',
                kind: 'Scalar',
                plural: true
            },
            {
                name: 'value',
                kind: 'Scalar'
            }
        ]
    };
};

function validate$J(obj, path = 'PicklistValuesRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_controllerValues = obj.controllerValues;
        const path_controllerValues = path + '.controllerValues';
        if (typeof obj_controllerValues !== 'object' || ArrayIsArray$1(obj_controllerValues) || obj_controllerValues === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_controllerValues + '" (at "' + path_controllerValues + '")');
        }
        const obj_controllerValues_keys = ObjectKeys$1(obj_controllerValues);
        for (let i = 0; i < obj_controllerValues_keys.length; i++) {
            const key = obj_controllerValues_keys[i];
            const obj_controllerValues_prop = obj_controllerValues[key];
            const path_controllerValues_prop = path_controllerValues + '["' + key + '"]';
            if (typeof obj_controllerValues_prop !== 'number' || (typeof obj_controllerValues_prop === 'number' && Math.floor(obj_controllerValues_prop) !== obj_controllerValues_prop)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_controllerValues_prop + '" (at "' + path_controllerValues_prop + '")');
            }
        }
        const obj_defaultValue = obj.defaultValue;
        const path_defaultValue = path + '.defaultValue';
        let obj_defaultValue_union0 = null;
        const obj_defaultValue_union0_error = (() => {
            const referencepath_defaultValueValidationError = validate$I(obj_defaultValue, path_defaultValue);
            if (referencepath_defaultValueValidationError !== null) {
                let message = 'Object doesn\'t match PicklistValueRepresentation (at "' + path_defaultValue + '")\n';
                message += referencepath_defaultValueValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_defaultValue_union0_error != null) {
            obj_defaultValue_union0 = obj_defaultValue_union0_error.message;
        }
        let obj_defaultValue_union1 = null;
        const obj_defaultValue_union1_error = (() => {
            if (obj_defaultValue !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_defaultValue + '" (at "' + path_defaultValue + '")');
            }
        })();
        if (obj_defaultValue_union1_error != null) {
            obj_defaultValue_union1 = obj_defaultValue_union1_error.message;
        }
        if (obj_defaultValue_union0 && obj_defaultValue_union1) {
            let message = 'Object doesn\'t match union (at "' + path_defaultValue + '")';
            message += '\n' + obj_defaultValue_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_defaultValue_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray$1(obj_values)) {
            return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
            const obj_values_item = obj_values[i];
            const path_values_item = path_values + '[' + i + ']';
            const referencepath_values_itemValidationError = validate$I(obj_values_item, path_values_item);
            if (referencepath_values_itemValidationError !== null) {
                let message = 'Object doesn\'t match PicklistValueRepresentation (at "' + path_values_item + '")\n';
                message += referencepath_values_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$T(config) {
    return keyPrefix + 'PicklistValuesRepresentation:' + config.id;
}
function keyBuilderFromType$e(object) {
    const keyParams = {
        id: object.url
    };
    return keyBuilder$T(keyParams);
}
function normalize$l(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$P = function PicklistValuesRepresentationSelect() {
    const { selections: PicklistValueRepresentation__selections, opaque: PicklistValueRepresentation__opaque, } = select$O();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'controllerValues',
                kind: 'Scalar',
                map: true
            },
            {
                name: 'defaultValue',
                kind: 'Object',
                nullable: true,
                selections: PicklistValueRepresentation__selections
            },
            {
                name: 'url',
                kind: 'Scalar'
            },
            {
                name: 'values',
                kind: 'Object',
                plural: true,
                selections: PicklistValueRepresentation__selections
            }
        ]
    };
};
function equals$o(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
const ingest$l = function PicklistValuesRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$J(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$e(input);
    let incomingRecord = normalize$l(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$o(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

const TTL$8 = 300000;
function validate$K(obj, path = 'PicklistValuesCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_picklistFieldValues = obj.picklistFieldValues;
        const path_picklistFieldValues = path + '.picklistFieldValues';
        if (typeof obj_picklistFieldValues !== 'object' || ArrayIsArray$1(obj_picklistFieldValues) || obj_picklistFieldValues === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_picklistFieldValues + '" (at "' + path_picklistFieldValues + '")');
        }
        const obj_picklistFieldValues_keys = ObjectKeys$1(obj_picklistFieldValues);
        for (let i = 0; i < obj_picklistFieldValues_keys.length; i++) {
            const key = obj_picklistFieldValues_keys[i];
            const obj_picklistFieldValues_prop = obj_picklistFieldValues[key];
            const path_picklistFieldValues_prop = path_picklistFieldValues + '["' + key + '"]';
            if (typeof obj_picklistFieldValues_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_picklistFieldValues_prop + '" (at "' + path_picklistFieldValues_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$m(input, existing, path, luvio, store, timestamp) {
    const input_picklistFieldValues = input.picklistFieldValues;
    const input_picklistFieldValues_id = path.fullPath + '__picklistFieldValues';
    const input_picklistFieldValues_keys = Object.keys(input_picklistFieldValues);
    const input_picklistFieldValues_length = input_picklistFieldValues_keys.length;
    for (let i = 0; i < input_picklistFieldValues_length; i++) {
        const key = input_picklistFieldValues_keys[i];
        const input_picklistFieldValues_prop = input_picklistFieldValues[key];
        const input_picklistFieldValues_prop_id = input_picklistFieldValues_id + '__' + key;
        input_picklistFieldValues[key] = ingest$l(input_picklistFieldValues_prop, {
            fullPath: input_picklistFieldValues_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
const select$Q = function PicklistValuesCollectionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'picklistFieldValues',
                kind: 'Link',
                map: true,
                fragment: select$P()
            }
        ]
    };
};
function equals$p(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_picklistFieldValues = existing.picklistFieldValues;
    const incoming_picklistFieldValues = incoming.picklistFieldValues;
    const equals_picklistFieldValues_props = equalsObject(existing_picklistFieldValues, incoming_picklistFieldValues, (existing_picklistFieldValues_prop, incoming_picklistFieldValues_prop) => {
        if (!(existing_picklistFieldValues_prop.__ref === incoming_picklistFieldValues_prop.__ref)) {
            return false;
        }
    });
    if (equals_picklistFieldValues_props === false) {
        return false;
    }
    return true;
}
const ingest$m = function PicklistValuesCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$K(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$m(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$p(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function select$R(luvio, params) {
    return select$Q();
}
function keyBuilder$U(params) {
    return keyPrefix + 'PicklistValuesCollectionRepresentation(' + 'objectApiName:' + params.urlParams.objectApiName + ',' + 'recordTypeId:' + params.urlParams.recordTypeId + ')';
}
function ingestSuccess$i(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$U(resourceParams);
    luvio.storeIngest(key, ingest$m, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$R(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$k(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$U(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$8);
    return errorSnapshot;
}
function createResourceRequest$r(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '/picklist-values/' + config.urlParams.recordTypeId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const getPicklistValuesByRecordType_ConfigPropertyNames = {
    displayName: 'getPicklistValuesByRecordType',
    parameters: {
        required: ['objectApiName', 'recordTypeId'],
        optional: []
    }
};
function createResourceParams$m(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$j(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function keyBuilder$V(luvio, config) {
    const resourceParams = createResourceParams$m(config);
    return keyBuilder$U(resourceParams);
}
function typeCheckConfig$n(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$n(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$j(untrustedConfig);
    const config = typeCheckConfig$n(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$j(luvio, config) {
    const resourceParams = createResourceParams$m(config);
    return select$R();
}
function buildInMemorySnapshot$o(luvio, config) {
    const selector = {
        recordId: keyBuilder$V(luvio, config),
        node: adapterFragment$j(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$j(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$i(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$k(luvio, config, resourceParams, response) {
    const snapshot = ingestError$k(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$m(luvio, config, override) {
    const resourceParams = createResourceParams$m(config);
    const request = createResourceRequest$r(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$j(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$k(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$m(luvio, config, snapshot) {
    const resourceParams = createResourceParams$m(config);
    const request = createResourceRequest$r(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$j(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$k(luvio, config, resourceParams, response);
    });
}
const getPicklistValuesByRecordTypeAdapterFactory = (luvio) => function uiApi__getPicklistValuesByRecordType(untrustedConfig) {
    const config = validateAdapterConfig$n(untrustedConfig, getPicklistValuesByRecordType_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$o(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$m(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$m(luvio, config);
};

function validate$L(obj, path = 'MatchResultInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_recordIds = obj.recordIds;
        const path_recordIds = path + '.recordIds';
        if (!ArrayIsArray$1(obj_recordIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_recordIds + '" (at "' + path_recordIds + '")');
        }
        for (let i = 0; i < obj_recordIds.length; i++) {
            const obj_recordIds_item = obj_recordIds[i];
            const path_recordIds_item = path_recordIds + '[' + i + ']';
            if (typeof obj_recordIds_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordIds_item + '" (at "' + path_recordIds_item + '")');
            }
        }
        const obj_rule = obj.rule;
        const path_rule = path + '.rule';
        if (typeof obj_rule !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_rule + '" (at "' + path_rule + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$k(input) {
    const input_recordIds = input.recordIds;
    ObjectFreeze$1(input_recordIds);
    ObjectFreeze$1(input);
}

function validate$M(obj, path = 'DuplicateResultInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_allowSave = obj.allowSave;
        const path_allowSave = path + '.allowSave';
        if (typeof obj_allowSave !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_allowSave + '" (at "' + path_allowSave + '")');
        }
        const obj_matchResultInfo = obj.matchResultInfo;
        const path_matchResultInfo = path + '.matchResultInfo';
        const referencepath_matchResultInfoValidationError = validate$L(obj_matchResultInfo, path_matchResultInfo);
        if (referencepath_matchResultInfoValidationError !== null) {
            let message = 'Object doesn\'t match MatchResultInfoRepresentation (at "' + path_matchResultInfo + '")\n';
            message += referencepath_matchResultInfoValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_rule = obj.rule;
        const path_rule = path + '.rule';
        if (typeof obj_rule !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_rule + '" (at "' + path_rule + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$l(input) {
    const input_matchResultInfo = input.matchResultInfo;
    deepFreeze$k(input_matchResultInfo);
    ObjectFreeze$1(input);
}

function validate$N(obj, path = 'MatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_duplicateResultInfos = obj.duplicateResultInfos;
        const path_duplicateResultInfos = path + '.duplicateResultInfos';
        if (typeof obj_duplicateResultInfos !== 'object' || ArrayIsArray$1(obj_duplicateResultInfos) || obj_duplicateResultInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_duplicateResultInfos + '" (at "' + path_duplicateResultInfos + '")');
        }
        const obj_duplicateResultInfos_keys = ObjectKeys$1(obj_duplicateResultInfos);
        for (let i = 0; i < obj_duplicateResultInfos_keys.length; i++) {
            const key = obj_duplicateResultInfos_keys[i];
            const obj_duplicateResultInfos_prop = obj_duplicateResultInfos[key];
            const path_duplicateResultInfos_prop = path_duplicateResultInfos + '["' + key + '"]';
            const referencepath_duplicateResultInfos_propValidationError = validate$M(obj_duplicateResultInfos_prop, path_duplicateResultInfos_prop);
            if (referencepath_duplicateResultInfos_propValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateResultInfoRepresentation (at "' + path_duplicateResultInfos_prop + '")\n';
                message += referencepath_duplicateResultInfos_propValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_recordIds = obj.recordIds;
        const path_recordIds = path + '.recordIds';
        if (!ArrayIsArray$1(obj_recordIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_recordIds + '" (at "' + path_recordIds + '")');
        }
        for (let i = 0; i < obj_recordIds.length; i++) {
            const obj_recordIds_item = obj_recordIds[i];
            const path_recordIds_item = path_recordIds + '[' + i + ']';
            if (typeof obj_recordIds_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordIds_item + '" (at "' + path_recordIds_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$m(input) {
    const input_duplicateResultInfos = input.duplicateResultInfos;
    const input_duplicateResultInfos_keys = Object.keys(input_duplicateResultInfos);
    const input_duplicateResultInfos_length = input_duplicateResultInfos_keys.length;
    for (let i = 0; i < input_duplicateResultInfos_length; i++) {
        const key = input_duplicateResultInfos_keys[i];
        const input_duplicateResultInfos_prop = input_duplicateResultInfos[key];
        deepFreeze$l(input_duplicateResultInfos_prop);
    }
    ObjectFreeze$1(input_duplicateResultInfos);
    const input_recordIds = input.recordIds;
    ObjectFreeze$1(input_recordIds);
    ObjectFreeze$1(input);
}

const TTL$9 = 30000;
function validate$O(obj, path = 'DuplicatesRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_allowSave = obj.allowSave;
        const path_allowSave = path + '.allowSave';
        if (typeof obj_allowSave !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_allowSave + '" (at "' + path_allowSave + '")');
        }
        const obj_duplicateError = obj.duplicateError;
        const path_duplicateError = path + '.duplicateError';
        if (typeof obj_duplicateError !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_duplicateError + '" (at "' + path_duplicateError + '")');
        }
        const obj_duplicateRules = obj.duplicateRules;
        const path_duplicateRules = path + '.duplicateRules';
        if (!ArrayIsArray$1(obj_duplicateRules)) {
            return new TypeError('Expected "array" but received "' + typeof obj_duplicateRules + '" (at "' + path_duplicateRules + '")');
        }
        for (let i = 0; i < obj_duplicateRules.length; i++) {
            const obj_duplicateRules_item = obj_duplicateRules[i];
            const path_duplicateRules_item = path_duplicateRules + '[' + i + ']';
            if (typeof obj_duplicateRules_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_duplicateRules_item + '" (at "' + path_duplicateRules_item + '")');
            }
        }
        const obj_matches = obj.matches;
        const path_matches = path + '.matches';
        if (!ArrayIsArray$1(obj_matches)) {
            return new TypeError('Expected "array" but received "' + typeof obj_matches + '" (at "' + path_matches + '")');
        }
        for (let i = 0; i < obj_matches.length; i++) {
            const obj_matches_item = obj_matches[i];
            const path_matches_item = path_matches + '[' + i + ']';
            const referencepath_matches_itemValidationError = validate$N(obj_matches_item, path_matches_item);
            if (referencepath_matches_itemValidationError !== null) {
                let message = 'Object doesn\'t match MatchRepresentation (at "' + path_matches_item + '")\n';
                message += referencepath_matches_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$n(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$S = function DuplicatesRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        opaque: true
    };
};
function equals$q(existing, incoming) {
    if (JSONStringify$1(incoming) !== JSONStringify$1(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$n(input) {
    const input_duplicateRules = input.duplicateRules;
    ObjectFreeze$1(input_duplicateRules);
    const input_matches = input.matches;
    for (let i = 0; i < input_matches.length; i++) {
        const input_matches_item = input_matches[i];
        deepFreeze$m(input_matches_item);
    }
    ObjectFreeze$1(input_matches);
    ObjectFreeze$1(input);
}
const ingest$n = function DuplicatesRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$O(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$n(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$n(input);
    if (existingRecord === undefined || equals$q(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 30000);
    return createLink(key);
};

function select$T(luvio, params) {
    return select$S();
}
function keyBuilder$W(params) {
    return keyPrefix + 'DuplicatesRepresentation(' + (params.body.allowSaveOnDuplicate === undefined ? 'allowSaveOnDuplicate' : 'allowSaveOnDuplicate:' + params.body.allowSaveOnDuplicate) + '::' + (params.body.apiName === undefined ? 'apiName' : 'apiName:' + params.body.apiName) + '::' + stableJSONStringify(params.body.fields) + ')';
}
function ingestSuccess$j(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$W(resourceParams);
    luvio.storeIngest(key, ingest$n, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$T(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$l(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$W(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$9);
    return errorSnapshot;
}
function createResourceRequest$s(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/predupe',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        headers,
    };
}

const getDuplicates_ConfigPropertyNames = {
    displayName: 'getDuplicates',
    parameters: {
        required: ['fields'],
        optional: ['allowSaveOnDuplicate', 'apiName']
    }
};
function createResourceParams$n(config) {
    return {
        body: {
            allowSaveOnDuplicate: config.allowSaveOnDuplicate, apiName: config.apiName, fields: config.fields
        }
    };
}
function keyBuilder$X(luvio, config) {
    const resourceParams = createResourceParams$n(config);
    return keyBuilder$W(resourceParams);
}
function typeCheckConfig$o(untrustedConfig) {
    const config = {};
    const untrustedConfig_allowSaveOnDuplicate = untrustedConfig.allowSaveOnDuplicate;
    if (typeof untrustedConfig_allowSaveOnDuplicate === 'boolean') {
        config.allowSaveOnDuplicate = untrustedConfig_allowSaveOnDuplicate;
    }
    const untrustedConfig_apiName = untrustedConfig.apiName;
    if (typeof untrustedConfig_apiName === 'string') {
        config.apiName = untrustedConfig_apiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
            const key = untrustedConfig_fields_keys[i];
            const untrustedConfig_fields_prop = untrustedConfig_fields[key];
            if (typeof untrustedConfig_fields_prop === 'string') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'number') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (untrustedConfig_fields_prop === null) {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'boolean') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
        }
        if (Object.keys(untrustedConfig_fields_object).length >= 0) {
            config.fields = untrustedConfig_fields_object;
        }
    }
    return config;
}
function validateAdapterConfig$o(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$o(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$k(luvio, config) {
    const resourceParams = createResourceParams$n(config);
    return select$T();
}
function buildInMemorySnapshot$p(luvio, config) {
    const selector = {
        recordId: keyBuilder$X(luvio, config),
        node: adapterFragment$k(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$n(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$k(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$j(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$n(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$l(luvio, config, resourceParams, response) {
    const snapshot = ingestError$l(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$n(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$n(luvio, config, override) {
    const resourceParams = createResourceParams$n(config);
    const request = createResourceRequest$s(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$k(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$l(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$n(luvio, config, snapshot) {
    const resourceParams = createResourceParams$n(config);
    const request = createResourceRequest$s(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$k(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$l(luvio, config, resourceParams, response);
    });
}
const getDuplicatesAdapterFactory = (luvio) => function uiApi__getDuplicates(untrustedConfig) {
    const config = validateAdapterConfig$o(untrustedConfig, getDuplicates_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$p(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$n(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$n(luvio, config);
};

function validate$P(obj, path = 'RelatedListReferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_inContextOfRecordId = obj.inContextOfRecordId;
        const path_inContextOfRecordId = path + '.inContextOfRecordId';
        let obj_inContextOfRecordId_union0 = null;
        const obj_inContextOfRecordId_union0_error = (() => {
            if (typeof obj_inContextOfRecordId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_inContextOfRecordId + '" (at "' + path_inContextOfRecordId + '")');
            }
        })();
        if (obj_inContextOfRecordId_union0_error != null) {
            obj_inContextOfRecordId_union0 = obj_inContextOfRecordId_union0_error.message;
        }
        let obj_inContextOfRecordId_union1 = null;
        const obj_inContextOfRecordId_union1_error = (() => {
            if (obj_inContextOfRecordId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_inContextOfRecordId + '" (at "' + path_inContextOfRecordId + '")');
            }
        })();
        if (obj_inContextOfRecordId_union1_error != null) {
            obj_inContextOfRecordId_union1 = obj_inContextOfRecordId_union1_error.message;
        }
        if (obj_inContextOfRecordId_union0 && obj_inContextOfRecordId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_inContextOfRecordId + '")';
            message += '\n' + obj_inContextOfRecordId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_inContextOfRecordId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listViewApiName = obj.listViewApiName;
        const path_listViewApiName = path + '.listViewApiName';
        let obj_listViewApiName_union0 = null;
        const obj_listViewApiName_union0_error = (() => {
            if (typeof obj_listViewApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union0_error != null) {
            obj_listViewApiName_union0 = obj_listViewApiName_union0_error.message;
        }
        let obj_listViewApiName_union1 = null;
        const obj_listViewApiName_union1_error = (() => {
            if (obj_listViewApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union1_error != null) {
            obj_listViewApiName_union1 = obj_listViewApiName_union1_error.message;
        }
        if (obj_listViewApiName_union0 && obj_listViewApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_listViewApiName + '")';
            message += '\n' + obj_listViewApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_listViewApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        let obj_objectApiName_union0 = null;
        const obj_objectApiName_union0_error = (() => {
            if (typeof obj_objectApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
            }
        })();
        if (obj_objectApiName_union0_error != null) {
            obj_objectApiName_union0 = obj_objectApiName_union0_error.message;
        }
        let obj_objectApiName_union1 = null;
        const obj_objectApiName_union1_error = (() => {
            if (obj_objectApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
            }
        })();
        if (obj_objectApiName_union1_error != null) {
            obj_objectApiName_union1 = obj_objectApiName_union1_error.message;
        }
        if (obj_objectApiName_union0 && obj_objectApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_objectApiName + '")';
            message += '\n' + obj_objectApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_objectApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_parentObjectApiName = obj.parentObjectApiName;
        const path_parentObjectApiName = path + '.parentObjectApiName';
        if (typeof obj_parentObjectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentObjectApiName + '" (at "' + path_parentObjectApiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$U = function RelatedListReferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'inContextOfRecordId',
                kind: 'Scalar'
            },
            {
                name: 'listViewApiName',
                kind: 'Scalar'
            },
            {
                name: 'objectApiName',
                kind: 'Scalar'
            },
            {
                name: 'parentObjectApiName',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'relatedListId',
                kind: 'Scalar'
            },
            {
                name: 'type',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$r(existing, incoming) {
    const existing_parentObjectApiName = existing.parentObjectApiName;
    const incoming_parentObjectApiName = incoming.parentObjectApiName;
    if (!(existing_parentObjectApiName === incoming_parentObjectApiName)) {
        return false;
    }
    const existing_relatedListId = existing.relatedListId;
    const incoming_relatedListId = incoming.relatedListId;
    if (!(existing_relatedListId === incoming_relatedListId)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_inContextOfRecordId = existing.inContextOfRecordId;
    const incoming_inContextOfRecordId = incoming.inContextOfRecordId;
    if (!(existing_inContextOfRecordId === incoming_inContextOfRecordId)) {
        return false;
    }
    const existing_listViewApiName = existing.listViewApiName;
    const incoming_listViewApiName = incoming.listViewApiName;
    if (!(existing_listViewApiName === incoming_listViewApiName)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
function deepFreeze$o(input) {
    ObjectFreeze$1(input);
}

function validate$Q(obj, path = 'RelatedListRecordCountRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        let obj_count_union0 = null;
        const obj_count_union0_error = (() => {
            if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
            }
        })();
        if (obj_count_union0_error != null) {
            obj_count_union0 = obj_count_union0_error.message;
        }
        let obj_count_union1 = null;
        const obj_count_union1_error = (() => {
            if (obj_count !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_count + '" (at "' + path_count + '")');
            }
        })();
        if (obj_count_union1_error != null) {
            obj_count_union1 = obj_count_union1_error.message;
        }
        if (obj_count_union0 && obj_count_union1) {
            let message = 'Object doesn\'t match union (at "' + path_count + '")';
            message += '\n' + obj_count_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_count_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_hasMore = obj.hasMore;
        const path_hasMore = path + '.hasMore';
        if (typeof obj_hasMore !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasMore + '" (at "' + path_hasMore + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$P(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
            message += referencepath_listReferenceValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$Y(config) {
    return keyPrefix + 'RelatedListRecordCountRepresentation:' + (config.parentRecordId === null ? '' : config.parentRecordId) + ':' + config.relatedListName;
}
function keyBuilderFromType$f(object) {
    const keyParams = {
        parentRecordId: object.listReference.inContextOfRecordId,
        relatedListName: object.listReference.relatedListId
    };
    return keyBuilder$Y(keyParams);
}
function normalize$o(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$V = function RelatedListRecordCountRepresentationSelect() {
    const { selections: RelatedListReferenceRepresentation__selections, opaque: RelatedListReferenceRepresentation__opaque, } = select$U();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'count',
                kind: 'Scalar'
            },
            {
                name: 'hasMore',
                kind: 'Scalar'
            },
            {
                name: 'listReference',
                kind: 'Object',
                selections: RelatedListReferenceRepresentation__selections
            }
        ]
    };
};
function equals$s(existing, incoming) {
    const existing_hasMore = existing.hasMore;
    const incoming_hasMore = incoming.hasMore;
    if (!(existing_hasMore === incoming_hasMore)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_listReference = existing.listReference;
    const incoming_listReference = incoming.listReference;
    if (!(equals$r(existing_listReference, incoming_listReference))) {
        return false;
    }
    return true;
}
const ingest$o = function RelatedListRecordCountRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$Q(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$f(input);
    let incomingRecord = normalize$o(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$s(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function select$W(luvio, params) {
    return select$V();
}
function keyBuilder$Z(params) {
    return keyBuilder$Y({
        parentRecordId: params.urlParams.parentRecordId,
        relatedListName: params.urlParams.relatedListName
    });
}
function ingestSuccess$k(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$Z(resourceParams);
    luvio.storeIngest(key, ingest$o, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$W(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$m(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$Z(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$t(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-count/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const nonCachedErrors$3 = ObjectCreate(null);
function createChildResourceParams$3(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListNames[index];
        childConfigs.push({
            urlParams: {
                parentRecordId: resourceParams.urlParams.parentRecordId,
                relatedListName: item
            },
            queryParams: {
                maxCount: resourceParams.queryParams.maxCount
            }
        });
    }
    return childConfigs;
}
function selectChildResourceParams$3(luvio, childResources) {
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$Z(childResource);
                const childFragment = select$W();
                const isMissingDataBeforeChildRead = reader.isMissingData;
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                reader.seenIds[childKey] = true;
                switch (childSnapshot.state) {
                    case 'Stale':
                        reader.markStale();
                    // Stale needs envelope bodies filled in so don't break
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        // if child snapshot doesn't have any data then
                        // that means the child record key is missing
                        if (childSnapshot.data === undefined) {
                            if (reader.baseSnapshot === undefined) {
                                // not a rebuild, mark as missing and move on
                                reader.markMissingLink(childKey);
                                break;
                            }
                            // On rebuilds we have to check if there is a non-cached
                            // error that we know about.  If we don't do this then
                            // rebuilds will go into endless refresh loop if a child
                            // has non-cached errors (since the top-level composite
                            // snapshot will look like an Unfulfilled snapshot
                            // instead of an error snapshot).
                            const nonCachedError = nonCachedErrors$3[childKey];
                            if (nonCachedError === undefined) {
                                reader.markMissingLink(childKey);
                            }
                            else {
                                // if this child error was the only reason the reader
                                // is marked as missing then we want to undo that
                                if (isMissingDataBeforeChildRead === false) {
                                    reader.unMarkMissing();
                                }
                                // put status code and body into reader path
                                const { response: nonCachedBody, status: nonCachedStatus } = nonCachedError;
                                reader.enterPath(envelopeStatusCodePath);
                                reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                                reader.exitPath();
                                reader.enterPath(envelopeBodyPath);
                                reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                                reader.exitPath();
                            }
                        }
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function select$X(luvio, resourceParams) {
    const childResources = createChildResourceParams$3(resourceParams);
    return selectChildResourceParams$3(luvio, childResources);
}
function keyBuilder$_(params) {
    return keyPrefix + 'BatchRelatedListCountRepresentation(' + 'maxCount:' + params.queryParams.maxCount + ',' + 'parentRecordId:' + params.urlParams.parentRecordId + ',' + 'relatedListNames:' + params.urlParams.relatedListNames + ')';
}
function ingestSuccessChildResourceParams$3(luvio, childResourceParamsArray, childEnvelopes) {
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    let snapshotState = 'Fulfilled';
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$Z(childResourceParams);
        const result = childEnvelopes[index];
        const { statusCode: childStatusCode, result: childBody } = result;
        if (childStatusCode === 200) {
            const childResponse = {
                status: 200,
                body: childBody,
                ok: true,
                statusText: 'OK',
                headers: undefined,
            };
            const childSnapshot = ingestSuccess$k(luvio, childResourceParams, childResponse);
            if (childSnapshot.state === "Stale") {
                snapshotState = "Stale";
            }
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: 200,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        else {
            const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$m(luvio, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [childKey]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
            nonCachedErrors$3[childKey] = { response: childBody, status: childStatusCode };
        }
        else {
            delete nonCachedErrors$3[childKey];
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    return { childSnapshotData: ObjectFreeze(childSnapshotData), seenRecords, snapshotState };
}
function ingestSuccess$l(luvio, resourceParams, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$3(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const key = keyBuilder$_(resourceParams);
    const { childSnapshotData, seenRecords, snapshotState } = ingestSuccessChildResourceParams$3(luvio, childResourceParamsArray, childEnvelopes);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$X(luvio, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$n(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$_(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$u(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-count/batch/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRelatedListsCount_ConfigPropertyNames = {
    displayName: 'getRelatedListsCount',
    parameters: {
        required: ['parentRecordId', 'relatedListNames'],
        optional: ['maxCount']
    }
};
function createResourceParams$o(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListNames: config.relatedListNames
        },
        queryParams: {
            maxCount: config.maxCount
        }
    };
}
function coerceConfig$k(config) {
    const coercedConfig = {};
    const parentRecordId = config.parentRecordId;
    if (parentRecordId !== undefined) {
        coercedConfig.parentRecordId = parentRecordId;
    }
    const relatedListNames = getFieldApiNamesArray(config.relatedListNames);
    if (relatedListNames !== undefined) {
        coercedConfig.relatedListNames = relatedListNames;
    }
    const maxCount = config.maxCount;
    if (maxCount !== undefined) {
        coercedConfig.maxCount = maxCount;
    }
    return coercedConfig;
}
function keyBuilder$$(luvio, config) {
    const resourceParams = createResourceParams$o(config);
    return keyBuilder$_(resourceParams);
}
function typeCheckConfig$p(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedListNames = untrustedConfig.relatedListNames;
    if (ArrayIsArray(untrustedConfig_relatedListNames)) {
        const untrustedConfig_relatedListNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListNames.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListNames_item = untrustedConfig_relatedListNames[i];
            if (typeof untrustedConfig_relatedListNames_item === 'string') {
                untrustedConfig_relatedListNames_array.push(untrustedConfig_relatedListNames_item);
            }
        }
        config.relatedListNames = untrustedConfig_relatedListNames_array;
    }
    const untrustedConfig_maxCount = untrustedConfig.maxCount;
    if (typeof untrustedConfig_maxCount === 'number' && Math.floor(untrustedConfig_maxCount) === untrustedConfig_maxCount) {
        config.maxCount = untrustedConfig_maxCount;
    }
    return config;
}
function validateAdapterConfig$p(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$k(untrustedConfig);
    const config = typeCheckConfig$p(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$l(luvio, config) {
    const resourceParams = createResourceParams$o(config);
    return select$X(luvio, resourceParams);
}
function buildInMemorySnapshot$q(luvio, config) {
    const selector = {
        recordId: keyBuilder$$(luvio, config),
        node: adapterFragment$l(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$l(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$l(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$m(luvio, config, resourceParams, response) {
    const snapshot = ingestError$n(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$o(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$o(luvio, config, override) {
    const resourceParams = createResourceParams$o(config);
    const request = createResourceRequest$u(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$l(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$m(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$o(luvio, config, snapshot) {
    const resourceParams = createResourceParams$o(config);
    const request = createResourceRequest$u(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$l(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$m(luvio, config, resourceParams, response);
    });
}
const getRelatedListsCountAdapterFactory = (luvio) => function uiApi__getRelatedListsCount(untrustedConfig) {
    const config = validateAdapterConfig$p(untrustedConfig, getRelatedListsCount_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$q(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$o(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$o(luvio, config);
};

const getRelatedListCount_ConfigPropertyNames = {
    displayName: 'getRelatedListCount',
    parameters: {
        required: ['parentRecordId', 'relatedListName'],
        optional: ['maxCount']
    }
};
function createResourceParams$p(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListName: config.relatedListName
        },
        queryParams: {
            maxCount: config.maxCount
        }
    };
}
function keyBuilder$10(luvio, config) {
    const resourceParams = createResourceParams$p(config);
    return keyBuilder$Z(resourceParams);
}
function typeCheckConfig$q(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedListName = untrustedConfig.relatedListName;
    if (typeof untrustedConfig_relatedListName === 'string') {
        config.relatedListName = untrustedConfig_relatedListName;
    }
    const untrustedConfig_maxCount = untrustedConfig.maxCount;
    if (typeof untrustedConfig_maxCount === 'number' && Math.floor(untrustedConfig_maxCount) === untrustedConfig_maxCount) {
        config.maxCount = untrustedConfig_maxCount;
    }
    return config;
}
function validateAdapterConfig$q(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$q(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$m(luvio, config) {
    const resourceParams = createResourceParams$p(config);
    return select$W();
}
function buildInMemorySnapshot$r(luvio, config) {
    const selector = {
        recordId: keyBuilder$10(luvio, config),
        node: adapterFragment$m(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$m(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$k(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$n(luvio, config, resourceParams, response) {
    const snapshot = ingestError$m(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$p(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$p(luvio, config, override) {
    const resourceParams = createResourceParams$p(config);
    const request = createResourceRequest$t(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$m(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$n(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$p(luvio, config, snapshot) {
    const resourceParams = createResourceParams$p(config);
    const request = createResourceRequest$t(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$m(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$n(luvio, config, resourceParams, response);
    });
}
const getRelatedListCountAdapterFactory = (luvio) => function uiApi__getRelatedListCount(untrustedConfig) {
    const config = validateAdapterConfig$q(untrustedConfig, getRelatedListCount_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$r(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$p(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$p(luvio, config);
};

function validate$R(obj, path = 'RelatedListColumnRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_lookupId = obj.lookupId;
        const path_lookupId = path + '.lookupId';
        let obj_lookupId_union0 = null;
        const obj_lookupId_union0_error = (() => {
            if (typeof obj_lookupId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
            }
        })();
        if (obj_lookupId_union0_error != null) {
            obj_lookupId_union0 = obj_lookupId_union0_error.message;
        }
        let obj_lookupId_union1 = null;
        const obj_lookupId_union1_error = (() => {
            if (obj_lookupId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
            }
        })();
        if (obj_lookupId_union1_error != null) {
            obj_lookupId_union1 = obj_lookupId_union1_error.message;
        }
        if (obj_lookupId_union0 && obj_lookupId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lookupId + '")';
            message += '\n' + obj_lookupId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lookupId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$p(input) {
    ObjectFreeze$1(input);
}

const TTL$a = 900000;
function validate$S(obj, path = 'RelatedListInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_cloneable = obj.cloneable;
        const path_cloneable = path + '.cloneable';
        if (typeof obj_cloneable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_cloneable + '" (at "' + path_cloneable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_displayColumns = obj.displayColumns;
        const path_displayColumns = path + '.displayColumns';
        if (!ArrayIsArray$1(obj_displayColumns)) {
            return new TypeError('Expected "array" but received "' + typeof obj_displayColumns + '" (at "' + path_displayColumns + '")');
        }
        for (let i = 0; i < obj_displayColumns.length; i++) {
            const obj_displayColumns_item = obj_displayColumns[i];
            const path_displayColumns_item = path_displayColumns + '[' + i + ']';
            const referencepath_displayColumns_itemValidationError = validate$R(obj_displayColumns_item, path_displayColumns_item);
            if (referencepath_displayColumns_itemValidationError !== null) {
                let message = 'Object doesn\'t match RelatedListColumnRepresentation (at "' + path_displayColumns_item + '")\n';
                message += referencepath_displayColumns_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_filterLogicString = obj.filterLogicString;
        const path_filterLogicString = path + '.filterLogicString';
        if (typeof obj_filterLogicString !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
        }
        const obj_filteredByInfo = obj.filteredByInfo;
        const path_filteredByInfo = path + '.filteredByInfo';
        if (!ArrayIsArray$1(obj_filteredByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_filteredByInfo + '" (at "' + path_filteredByInfo + '")');
        }
        for (let i = 0; i < obj_filteredByInfo.length; i++) {
            const obj_filteredByInfo_item = obj_filteredByInfo[i];
            const path_filteredByInfo_item = path_filteredByInfo + '[' + i + ']';
            const referencepath_filteredByInfo_itemValidationError = validate$1(obj_filteredByInfo_item, path_filteredByInfo_item);
            if (referencepath_filteredByInfo_itemValidationError !== null) {
                let message = 'Object doesn\'t match ListFilterByInfoRepresentation (at "' + path_filteredByInfo_item + '")\n';
                message += referencepath_filteredByInfo_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$P(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
            message += referencepath_listReferenceValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiNames = obj.objectApiNames;
        const path_objectApiNames = path + '.objectApiNames';
        if (!ArrayIsArray$1(obj_objectApiNames)) {
            return new TypeError('Expected "array" but received "' + typeof obj_objectApiNames + '" (at "' + path_objectApiNames + '")');
        }
        for (let i = 0; i < obj_objectApiNames.length; i++) {
            const obj_objectApiNames_item = obj_objectApiNames[i];
            const path_objectApiNames_item = path_objectApiNames + '[' + i + ']';
            if (typeof obj_objectApiNames_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectApiNames_item + '" (at "' + path_objectApiNames_item + '")');
            }
        }
        const obj_orderedByInfo = obj.orderedByInfo;
        const path_orderedByInfo = path + '.orderedByInfo';
        if (!ArrayIsArray$1(obj_orderedByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_orderedByInfo + '" (at "' + path_orderedByInfo + '")');
        }
        for (let i = 0; i < obj_orderedByInfo.length; i++) {
            const obj_orderedByInfo_item = obj_orderedByInfo[i];
            const path_orderedByInfo_item = path_orderedByInfo + '[' + i + ']';
            const referencepath_orderedByInfo_itemValidationError = validate$2(obj_orderedByInfo_item, path_orderedByInfo_item);
            if (referencepath_orderedByInfo_itemValidationError !== null) {
                let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedByInfo_item + '")\n';
                message += referencepath_orderedByInfo_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
        const obj_userPreferences = obj.userPreferences;
        const path_userPreferences = path + '.userPreferences';
        const referencepath_userPreferencesValidationError = validate$3(obj_userPreferences, path_userPreferences);
        if (referencepath_userPreferencesValidationError !== null) {
            let message = 'Object doesn\'t match ListUserPreferenceRepresentation (at "' + path_userPreferences + '")\n';
            message += referencepath_userPreferencesValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_visibility = obj.visibility;
        const path_visibility = path + '.visibility';
        if (typeof obj_visibility !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_visibility + '" (at "' + path_visibility + '")');
        }
        const obj_visibilityEditable = obj.visibilityEditable;
        const path_visibilityEditable = path + '.visibilityEditable';
        if (typeof obj_visibilityEditable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_visibilityEditable + '" (at "' + path_visibilityEditable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$11(config) {
    return keyPrefix + 'RelatedListInfoRepresentation:' + config.parentObjectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId) + ':' + config.relatedListId;
}
function keyBuilderFromType$g(object) {
    const keyParams = {
        parentObjectApiName: object.listReference.parentObjectApiName,
        recordTypeId: object.listReference.recordTypeId,
        relatedListId: object.listReference.relatedListId
    };
    return keyBuilder$11(keyParams);
}
function normalize$p(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$Y = function RelatedListInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'cloneable',
                kind: 'Scalar'
            },
            {
                name: 'createable',
                kind: 'Scalar'
            },
            {
                name: 'deletable',
                kind: 'Scalar'
            },
            {
                name: 'displayColumns',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'fieldApiName',
                kind: 'Scalar'
            },
            {
                name: 'filterLogicString',
                kind: 'Scalar'
            },
            {
                name: 'filteredByInfo',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'listReference',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'objectApiNames',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'orderedByInfo',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'updateable',
                kind: 'Scalar'
            },
            {
                name: 'userPreferences',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'visibility',
                kind: 'Scalar'
            },
            {
                name: 'visibilityEditable',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$t(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$q(input) {
    const input_displayColumns = input.displayColumns;
    for (let i = 0; i < input_displayColumns.length; i++) {
        const input_displayColumns_item = input_displayColumns[i];
        deepFreeze$p(input_displayColumns_item);
    }
    ObjectFreeze$1(input_displayColumns);
    const input_filteredByInfo = input.filteredByInfo;
    for (let i = 0; i < input_filteredByInfo.length; i++) {
        const input_filteredByInfo_item = input_filteredByInfo[i];
        deepFreeze$1(input_filteredByInfo_item);
    }
    ObjectFreeze$1(input_filteredByInfo);
    const input_listReference = input.listReference;
    deepFreeze$o(input_listReference);
    const input_objectApiNames = input.objectApiNames;
    ObjectFreeze$1(input_objectApiNames);
    const input_orderedByInfo = input.orderedByInfo;
    for (let i = 0; i < input_orderedByInfo.length; i++) {
        const input_orderedByInfo_item = input_orderedByInfo[i];
        deepFreeze$2(input_orderedByInfo_item);
    }
    ObjectFreeze$1(input_orderedByInfo);
    const input_userPreferences = input.userPreferences;
    deepFreeze$3(input_userPreferences);
    ObjectFreeze$1(input);
}
const ingest$p = function RelatedListInfoRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$S(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$g(input);
    let incomingRecord = normalize$p(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$q(input);
    if (existingRecord === undefined || equals$t(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function select$Z(luvio, params) {
    return select$Y();
}
function keyBuilder$12(params) {
    return keyBuilder$11({
        parentObjectApiName: params.urlParams.parentObjectApiName,
        relatedListId: params.urlParams.relatedListId,
        recordTypeId: params.queryParams.recordTypeId || null
    });
}
function ingestSuccess$m(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$12(resourceParams);
    luvio.storeIngest(key, ingest$p, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$Z(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$o(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$12(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$a);
    return errorSnapshot;
}
function createResourceRequest$v(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const nonCachedErrors$4 = ObjectCreate(null);
function createChildResourceParams$4(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListNames[index];
        childConfigs.push({
            urlParams: {
                parentObjectApiName: resourceParams.urlParams.parentObjectApiName,
                relatedListId: item
            },
            queryParams: {
                recordTypeId: resourceParams.queryParams.recordTypeId
            }
        });
    }
    return childConfigs;
}
function selectChildResourceParams$4(luvio, childResources) {
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$12(childResource);
                const childFragment = select$Z();
                const isMissingDataBeforeChildRead = reader.isMissingData;
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                reader.seenIds[childKey] = true;
                switch (childSnapshot.state) {
                    case 'Stale':
                        reader.markStale();
                    // Stale needs envelope bodies filled in so don't break
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        // if child snapshot doesn't have any data then
                        // that means the child record key is missing
                        if (childSnapshot.data === undefined) {
                            if (reader.baseSnapshot === undefined) {
                                // not a rebuild, mark as missing and move on
                                reader.markMissingLink(childKey);
                                break;
                            }
                            // On rebuilds we have to check if there is a non-cached
                            // error that we know about.  If we don't do this then
                            // rebuilds will go into endless refresh loop if a child
                            // has non-cached errors (since the top-level composite
                            // snapshot will look like an Unfulfilled snapshot
                            // instead of an error snapshot).
                            const nonCachedError = nonCachedErrors$4[childKey];
                            if (nonCachedError === undefined || nonCachedError.expiration < reader.timestamp) {
                                reader.markMissingLink(childKey);
                            }
                            else {
                                // if this child error was the only reason the reader
                                // is marked as missing then we want to undo that
                                if (isMissingDataBeforeChildRead === false) {
                                    reader.unMarkMissing();
                                }
                                // put status code and body into reader path
                                const { response: nonCachedBody, status: nonCachedStatus } = nonCachedError;
                                reader.enterPath(envelopeStatusCodePath);
                                reader.assignScalar(envelopeStatusCodePath, childSink, nonCachedStatus);
                                reader.exitPath();
                                reader.enterPath(envelopeBodyPath);
                                reader.assignNonScalar(childSink, envelopeBodyPath, nonCachedBody);
                                reader.exitPath();
                            }
                        }
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function select$_(luvio, resourceParams) {
    const childResources = createChildResourceParams$4(resourceParams);
    return selectChildResourceParams$4(luvio, childResources);
}
function keyBuilder$13(params) {
    return keyPrefix + 'RelatedListInfoBatchRepresentation(' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'parentObjectApiName:' + params.urlParams.parentObjectApiName + ',' + 'relatedListNames:' + params.urlParams.relatedListNames + ')';
}
function ingestSuccessChildResourceParams$4(luvio, childResourceParamsArray, childEnvelopes) {
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    let snapshotState = 'Fulfilled';
    const now = Date.now();
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const childKey = keyBuilder$12(childResourceParams);
        const result = childEnvelopes[index];
        const { statusCode: childStatusCode, result: childBody } = result;
        if (childStatusCode === 200) {
            const childResponse = {
                status: 200,
                body: childBody,
                ok: true,
                statusText: 'OK',
                headers: undefined,
            };
            const childSnapshot = ingestSuccess$m(luvio, childResourceParams, childResponse);
            if (childSnapshot.state === "Stale") {
                snapshotState = "Stale";
            }
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: 200,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        else {
            const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$o(luvio, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [childKey]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            ArrayPrototypePush.call(childSnapshotDataResponses, childValue);
        }
        // track non-cached responses so rebuilds work properly
        if (childStatusCode !== 404 && childStatusCode !== 200) {
            nonCachedErrors$4[childKey] = { expiration: now + TTL$a, response: childBody, status: childStatusCode };
        }
        else {
            delete nonCachedErrors$4[childKey];
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    return { childSnapshotData: ObjectFreeze(childSnapshotData), seenRecords, snapshotState };
}
function ingestSuccess$n(luvio, resourceParams, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$4(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const key = keyBuilder$13(resourceParams);
    const { childSnapshotData, seenRecords, snapshotState } = ingestSuccessChildResourceParams$4(luvio, childResourceParamsArray, childEnvelopes);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotState,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$_(luvio, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$p(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$13(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$w(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-info/batch/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRelatedListInfoBatch_ConfigPropertyNames = {
    displayName: 'getRelatedListInfoBatch',
    parameters: {
        required: ['parentObjectApiName', 'relatedListNames'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$q(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName, relatedListNames: config.relatedListNames
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function keyBuilder$14(luvio, config) {
    const resourceParams = createResourceParams$q(config);
    return keyBuilder$13(resourceParams);
}
function typeCheckConfig$r(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_relatedListNames = untrustedConfig.relatedListNames;
    if (ArrayIsArray(untrustedConfig_relatedListNames)) {
        const untrustedConfig_relatedListNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListNames.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListNames_item = untrustedConfig_relatedListNames[i];
            if (typeof untrustedConfig_relatedListNames_item === 'string') {
                untrustedConfig_relatedListNames_array.push(untrustedConfig_relatedListNames_item);
            }
        }
        config.relatedListNames = untrustedConfig_relatedListNames_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$r(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$r(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$n(luvio, config) {
    const resourceParams = createResourceParams$q(config);
    return select$_(luvio, resourceParams);
}
function buildInMemorySnapshot$s(luvio, config) {
    const selector = {
        recordId: keyBuilder$14(luvio, config),
        node: adapterFragment$n(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$n(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$n(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$o(luvio, config, resourceParams, response) {
    const snapshot = ingestError$p(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$q(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$q(luvio, config, override) {
    const resourceParams = createResourceParams$q(config);
    const request = createResourceRequest$w(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$n(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$o(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$q(luvio, config, snapshot) {
    const resourceParams = createResourceParams$q(config);
    const request = createResourceRequest$w(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$n(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$o(luvio, config, resourceParams, response);
    });
}
const getRelatedListInfoBatchAdapterFactory = (luvio) => function uiApi__getRelatedListInfoBatch(untrustedConfig) {
    const config = validateAdapterConfig$r(untrustedConfig, getRelatedListInfoBatch_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$s(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$q(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$q(luvio, config);
};

function validate$T(obj, path = 'RelatedListSummaryInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_entityLabel = obj.entityLabel;
        const path_entityLabel = path + '.entityLabel';
        if (typeof obj_entityLabel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_entityLabel + '" (at "' + path_entityLabel + '")');
        }
        const obj_entityPluralLabel = obj.entityPluralLabel;
        const path_entityPluralLabel = path + '.entityPluralLabel';
        if (typeof obj_entityPluralLabel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_entityPluralLabel + '" (at "' + path_entityPluralLabel + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
            if (typeof obj_keyPrefix !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union0_error != null) {
            obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
            if (obj_keyPrefix !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union1_error != null) {
            obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
            let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
            message += '\n' + obj_keyPrefix_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_keyPrefix_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_parentFieldApiName = obj.parentFieldApiName;
        const path_parentFieldApiName = path + '.parentFieldApiName';
        if (typeof obj_parentFieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentFieldApiName + '" (at "' + path_parentFieldApiName + '")');
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        const obj_relatedListInfoUrl = obj.relatedListInfoUrl;
        const path_relatedListInfoUrl = path + '.relatedListInfoUrl';
        let obj_relatedListInfoUrl_union0 = null;
        const obj_relatedListInfoUrl_union0_error = (() => {
            if (typeof obj_relatedListInfoUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relatedListInfoUrl + '" (at "' + path_relatedListInfoUrl + '")');
            }
        })();
        if (obj_relatedListInfoUrl_union0_error != null) {
            obj_relatedListInfoUrl_union0 = obj_relatedListInfoUrl_union0_error.message;
        }
        let obj_relatedListInfoUrl_union1 = null;
        const obj_relatedListInfoUrl_union1_error = (() => {
            if (obj_relatedListInfoUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relatedListInfoUrl + '" (at "' + path_relatedListInfoUrl + '")');
            }
        })();
        if (obj_relatedListInfoUrl_union1_error != null) {
            obj_relatedListInfoUrl_union1 = obj_relatedListInfoUrl_union1_error.message;
        }
        if (obj_relatedListInfoUrl_union0 && obj_relatedListInfoUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedListInfoUrl + '")';
            message += '\n' + obj_relatedListInfoUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relatedListInfoUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_themeInfo = obj.themeInfo;
        const path_themeInfo = path + '.themeInfo';
        let obj_themeInfo_union0 = null;
        const obj_themeInfo_union0_error = (() => {
            const referencepath_themeInfoValidationError = validate$i(obj_themeInfo, path_themeInfo);
            if (referencepath_themeInfoValidationError !== null) {
                let message = 'Object doesn\'t match ThemeInfoRepresentation (at "' + path_themeInfo + '")\n';
                message += referencepath_themeInfoValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_themeInfo_union0_error != null) {
            obj_themeInfo_union0 = obj_themeInfo_union0_error.message;
        }
        let obj_themeInfo_union1 = null;
        const obj_themeInfo_union1_error = (() => {
            if (obj_themeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_themeInfo + '" (at "' + path_themeInfo + '")');
            }
        })();
        if (obj_themeInfo_union1_error != null) {
            obj_themeInfo_union1 = obj_themeInfo_union1_error.message;
        }
        if (obj_themeInfo_union0 && obj_themeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_themeInfo + '")';
            message += '\n' + obj_themeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_themeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_uiApiEnabledLayout = obj.uiApiEnabledLayout;
        const path_uiApiEnabledLayout = path + '.uiApiEnabledLayout';
        if (typeof obj_uiApiEnabledLayout !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_uiApiEnabledLayout + '" (at "' + path_uiApiEnabledLayout + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$r(input) {
    const input_themeInfo = input.themeInfo;
    if (input_themeInfo !== null && typeof input_themeInfo === 'object') {
        deepFreeze$9(input_themeInfo);
    }
    ObjectFreeze$1(input);
}

function validate$U(obj, path = 'RelatedListSummaryInfoCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_parentObjectApiName = obj.parentObjectApiName;
        const path_parentObjectApiName = path + '.parentObjectApiName';
        if (typeof obj_parentObjectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentObjectApiName + '" (at "' + path_parentObjectApiName + '")');
        }
        const obj_parentRecordTypeId = obj.parentRecordTypeId;
        const path_parentRecordTypeId = path + '.parentRecordTypeId';
        let obj_parentRecordTypeId_union0 = null;
        const obj_parentRecordTypeId_union0_error = (() => {
            if (typeof obj_parentRecordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_parentRecordTypeId + '" (at "' + path_parentRecordTypeId + '")');
            }
        })();
        if (obj_parentRecordTypeId_union0_error != null) {
            obj_parentRecordTypeId_union0 = obj_parentRecordTypeId_union0_error.message;
        }
        let obj_parentRecordTypeId_union1 = null;
        const obj_parentRecordTypeId_union1_error = (() => {
            if (obj_parentRecordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_parentRecordTypeId + '" (at "' + path_parentRecordTypeId + '")');
            }
        })();
        if (obj_parentRecordTypeId_union1_error != null) {
            obj_parentRecordTypeId_union1 = obj_parentRecordTypeId_union1_error.message;
        }
        if (obj_parentRecordTypeId_union0 && obj_parentRecordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_parentRecordTypeId + '")';
            message += '\n' + obj_parentRecordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_parentRecordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedLists = obj.relatedLists;
        const path_relatedLists = path + '.relatedLists';
        if (!ArrayIsArray$1(obj_relatedLists)) {
            return new TypeError('Expected "array" but received "' + typeof obj_relatedLists + '" (at "' + path_relatedLists + '")');
        }
        for (let i = 0; i < obj_relatedLists.length; i++) {
            const obj_relatedLists_item = obj_relatedLists[i];
            const path_relatedLists_item = path_relatedLists + '[' + i + ']';
            const referencepath_relatedLists_itemValidationError = validate$T(obj_relatedLists_item, path_relatedLists_item);
            if (referencepath_relatedLists_itemValidationError !== null) {
                let message = 'Object doesn\'t match RelatedListSummaryInfoRepresentation (at "' + path_relatedLists_item + '")\n';
                message += referencepath_relatedLists_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$15(config) {
    return keyPrefix + 'RelatedListSummaryInfoCollectionRepresentation:' + config.parentObjectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$h(object) {
    const keyParams = {
        parentObjectApiName: object.parentObjectApiName,
        recordTypeId: object.parentRecordTypeId
    };
    return keyBuilder$15(keyParams);
}
function normalize$q(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$$ = function RelatedListSummaryInfoCollectionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'parentObjectApiName',
                kind: 'Scalar'
            },
            {
                name: 'parentRecordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'relatedLists',
                kind: 'Object',
                opaque: true
            }
        ]
    };
};
function equals$u(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$s(input) {
    const input_relatedLists = input.relatedLists;
    for (let i = 0; i < input_relatedLists.length; i++) {
        const input_relatedLists_item = input_relatedLists[i];
        deepFreeze$r(input_relatedLists_item);
    }
    ObjectFreeze$1(input_relatedLists);
    ObjectFreeze$1(input);
}
const ingest$q = function RelatedListSummaryInfoCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$U(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$h(input);
    let incomingRecord = normalize$q(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    deepFreeze$s(input);
    if (existingRecord === undefined || equals$u(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function select$10(luvio, params) {
    return select$$();
}
function keyBuilder$16(params) {
    return keyBuilder$15({
        parentObjectApiName: params.urlParams.parentObjectApiName,
        recordTypeId: params.queryParams.recordTypeId || null
    });
}
function ingestSuccess$o(luvio, resourceParams, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$16(resourceParams);
    luvio.storeIngest(key, ingest$q, body);
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$10(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$q(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$16(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$x(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRelatedListsInfo_ConfigPropertyNames = {
    displayName: 'getRelatedListsInfo',
    parameters: {
        required: ['parentObjectApiName'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$r(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function keyBuilder$17(luvio, config) {
    const resourceParams = createResourceParams$r(config);
    return keyBuilder$16(resourceParams);
}
function typeCheckConfig$s(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$s(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$s(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$o(luvio, config) {
    const resourceParams = createResourceParams$r(config);
    return select$10();
}
function buildInMemorySnapshot$t(luvio, config) {
    const selector = {
        recordId: keyBuilder$17(luvio, config),
        node: adapterFragment$o(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$o(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$o(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$p(luvio, config, resourceParams, response) {
    const snapshot = ingestError$q(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$r(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$r(luvio, config, override) {
    const resourceParams = createResourceParams$r(config);
    const request = createResourceRequest$x(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$o(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$p(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$r(luvio, config, snapshot) {
    const resourceParams = createResourceParams$r(config);
    const request = createResourceRequest$x(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$o(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$p(luvio, config, resourceParams, response);
    });
}
const getRelatedListsInfoAdapterFactory = (luvio) => function uiApi__getRelatedListsInfo(untrustedConfig) {
    const config = validateAdapterConfig$s(untrustedConfig, getRelatedListsInfo_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$t(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$r(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$r(luvio, config);
};

const getRelatedListInfo_ConfigPropertyNames = {
    displayName: 'getRelatedListInfo',
    parameters: {
        required: ['parentObjectApiName', 'relatedListId'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$s(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName, relatedListId: config.relatedListId
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function keyBuilder$18(luvio, config) {
    const resourceParams = createResourceParams$s(config);
    return keyBuilder$12(resourceParams);
}
function typeCheckConfig$t(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$t(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$t(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$p(luvio, config) {
    const resourceParams = createResourceParams$s(config);
    return select$Z();
}
function buildInMemorySnapshot$u(luvio, config) {
    const selector = {
        recordId: keyBuilder$18(luvio, config),
        node: adapterFragment$p(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$p(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$m(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$q(luvio, config, resourceParams, response) {
    const snapshot = ingestError$o(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$s(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$s(luvio, config, override) {
    const resourceParams = createResourceParams$s(config);
    const request = createResourceRequest$v(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$p(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$q(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$s(luvio, config, snapshot) {
    const resourceParams = createResourceParams$s(config);
    const request = createResourceRequest$v(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$p(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$q(luvio, config, resourceParams, response);
    });
}
const getRelatedListInfoAdapterFactory = (luvio) => function uiApi__getRelatedListInfo(untrustedConfig) {
    const config = validateAdapterConfig$t(untrustedConfig, getRelatedListInfo_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$u(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$s(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$s(luvio, config);
};

function validate$W(obj, path = 'RelatedListRecordCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        let obj_currentPageUrl_union0 = null;
        const obj_currentPageUrl_union0_error = (() => {
            if (typeof obj_currentPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
            }
        })();
        if (obj_currentPageUrl_union0_error != null) {
            obj_currentPageUrl_union0 = obj_currentPageUrl_union0_error.message;
        }
        let obj_currentPageUrl_union1 = null;
        const obj_currentPageUrl_union1_error = (() => {
            if (obj_currentPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
            }
        })();
        if (obj_currentPageUrl_union1_error != null) {
            obj_currentPageUrl_union1 = obj_currentPageUrl_union1_error.message;
        }
        if (obj_currentPageUrl_union0 && obj_currentPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_currentPageUrl + '")';
            message += '\n' + obj_currentPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_currentPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray$1(obj_fields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
            const obj_fields_item = obj_fields[i];
            const path_fields_item = path_fields + '[' + i + ']';
            if (typeof obj_fields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
            }
        }
        const obj_listInfoETag = obj.listInfoETag;
        const path_listInfoETag = path + '.listInfoETag';
        let obj_listInfoETag_union0 = null;
        const obj_listInfoETag_union0_error = (() => {
            if (typeof obj_listInfoETag !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
            }
        })();
        if (obj_listInfoETag_union0_error != null) {
            obj_listInfoETag_union0 = obj_listInfoETag_union0_error.message;
        }
        let obj_listInfoETag_union1 = null;
        const obj_listInfoETag_union1_error = (() => {
            if (obj_listInfoETag !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
            }
        })();
        if (obj_listInfoETag_union1_error != null) {
            obj_listInfoETag_union1 = obj_listInfoETag_union1_error.message;
        }
        if (obj_listInfoETag_union0 && obj_listInfoETag_union1) {
            let message = 'Object doesn\'t match union (at "' + path_listInfoETag + '")';
            message += '\n' + obj_listInfoETag_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_listInfoETag_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referencepath_listReferenceValidationError = validate$P(obj_listReference, path_listReference);
        if (referencepath_listReferenceValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
            message += referencepath_listReferenceValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray$1(obj_optionalFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
            const obj_optionalFields_item = obj_optionalFields[i];
            const path_optionalFields_item = path_optionalFields + '[' + i + ']';
            if (typeof obj_optionalFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
            }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        let obj_pageSize_union0 = null;
        const obj_pageSize_union0_error = (() => {
            if (typeof obj_pageSize !== 'number' || (typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
            }
        })();
        if (obj_pageSize_union0_error != null) {
            obj_pageSize_union0 = obj_pageSize_union0_error.message;
        }
        let obj_pageSize_union1 = null;
        const obj_pageSize_union1_error = (() => {
            if (obj_pageSize !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
            }
        })();
        if (obj_pageSize_union1_error != null) {
            obj_pageSize_union1 = obj_pageSize_union1_error.message;
        }
        if (obj_pageSize_union0 && obj_pageSize_union1) {
            let message = 'Object doesn\'t match union (at "' + path_pageSize + '")';
            message += '\n' + obj_pageSize_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_pageSize_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray$1(obj_records)) {
            return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
            const obj_records_item = obj_records[i];
            const path_records_item = path_records + '[' + i + ']';
            if (typeof obj_records_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
            }
        }
        const obj_sortBy = obj.sortBy;
        const path_sortBy = path + '.sortBy';
        if (!ArrayIsArray$1(obj_sortBy)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
        }
        for (let i = 0; i < obj_sortBy.length; i++) {
            const obj_sortBy_item = obj_sortBy[i];
            const path_sortBy_item = path_sortBy + '[' + i + ']';
            if (typeof obj_sortBy_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$19(config) {
    return keyPrefix + 'RelatedListRecordCollectionRepresentation:' + '[' + config.sortBy.join(',') + ']' + ':' + (config.parentRecordId === null ? '' : config.parentRecordId) + ':' + config.relatedListId;
}
function keyBuilderFromType$i(object) {
    const keyParams = {
        sortBy: object.sortBy,
        parentRecordId: object.listReference.inContextOfRecordId,
        relatedListId: object.listReference.relatedListId
    };
    return keyBuilder$19(keyParams);
}
function paginationKeyBuilder$2(config) {
    return keyBuilder$19(config) + '__pagination';
}
function normalize$r(input, existing, path, luvio, store, timestamp) {
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$4(input_records_item, {
            fullPath: input_records_item_id,
            propertyName: i,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
function equals$v(existing, incoming) {
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_items = equalsArray(existing_fields, incoming_fields, (existing_fields_item, incoming_fields_item) => {
        if (!(existing_fields_item === incoming_fields_item)) {
            return false;
        }
    });
    if (equals_fields_items === false) {
        return false;
    }
    const existing_listInfoETag = existing.listInfoETag;
    const incoming_listInfoETag = incoming.listInfoETag;
    if (!(existing_listInfoETag === incoming_listInfoETag)) {
        return false;
    }
    const existing_listReference = existing.listReference;
    const incoming_listReference = incoming.listReference;
    if (!(equals$r(existing_listReference, incoming_listReference))) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_optionalFields = existing.optionalFields;
    const incoming_optionalFields = incoming.optionalFields;
    const equals_optionalFields_items = equalsArray(existing_optionalFields, incoming_optionalFields, (existing_optionalFields_item, incoming_optionalFields_item) => {
        if (!(existing_optionalFields_item === incoming_optionalFields_item)) {
            return false;
        }
    });
    if (equals_optionalFields_items === false) {
        return false;
    }
    const existing_pageSize = existing.pageSize;
    const incoming_pageSize = incoming.pageSize;
    if (!(existing_pageSize === incoming_pageSize)) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
            return false;
        }
    });
    if (equals_records_items === false) {
        return false;
    }
    const existing_sortBy = existing.sortBy;
    const incoming_sortBy = incoming.sortBy;
    const equals_sortBy_items = equalsArray(existing_sortBy, incoming_sortBy, (existing_sortBy_item, incoming_sortBy_item) => {
        if (!(existing_sortBy_item === incoming_sortBy_item)) {
            return false;
        }
    });
    if (equals_sortBy_items === false) {
        return false;
    }
    return true;
}
const ingest$r = function RelatedListRecordCollectionRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$W(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$i(input);
    let incomingRecord = normalize$r(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    const paginationKey = paginationKeyBuilder$2({
        sortBy: input.sortBy,
        parentRecordId: input.listReference.inContextOfRecordId,
        relatedListId: input.listReference.relatedListId,
    });
    const { isPastEnd, offsetFor, save, setEnd, setToken } = luvio.pagination(paginationKey);
    const currentOffset = offsetFor(input.currentPageToken);
    if (process.env.NODE_ENV !== 'production') {
        if (currentOffset === undefined ||
            (existingRecord &&
                existingRecord.records.length < currentOffset)) {
            throw new RangeError("currentPageToken value " + input.currentPageToken + " not recognized");
        }
    }
    const nextOffset = currentOffset + input.count;
    if (input.nextPageToken) {
        setToken(input.nextPageToken, nextOffset);
        if (isPastEnd(nextOffset)) {
            setEnd(undefined);
        }
    }
    else {
        setEnd(nextOffset);
    }
    if (input.previousPageToken) {
        // TODO - need request's pageSize to ingest previousPageToken at end of list
        if (input.nextPageToken) {
            setToken(input.previousPageToken, currentOffset - input.count);
        }
    }
    save();
    if (existingRecord) {
        incomingRecord.currentPageUrl = existingRecord.currentPageUrl;
        // TODO: needs optimization
        incomingRecord.records = [
            ...existingRecord.records.slice(0, currentOffset),
            ...incomingRecord.records,
            ...(input.nextPageToken ?
                existingRecord.records.slice(nextOffset) :
                []),
        ];
    }
    if (existingRecord === undefined || equals$v(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function keyBuilder$1a(params) {
    return keyBuilder$19({
        sortBy: params.queryParams.sortBy || [],
        parentRecordId: params.urlParams.parentRecordId,
        relatedListId: params.urlParams.relatedListId
    });
}
function ingestError$r(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$1a(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$z(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-records/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function records(key, selection, record, data, variables, reader) {
    reader.readPluralLink(key, {
        kind: 'Link',
        name: selection.name,
        plural: true,
        fragment: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: selection.selections,
        },
        pageToken: selection.pageToken,
        pageSize: selection.pageSize,
        tokenDataKey: selection.tokenDataKey,
    }, record, data);
    const pagination = reader.pagination(selection.tokenDataKey);
    variables.__pageSize = selection.pageSize;
    const currentOffset = pagination.offsetFor(selection.pageToken);
    const nextOffset = currentOffset + selection.pageSize;
    const previousOffset = currentOffset - selection.pageSize;
    // count
    variables.count = data.records.length;
    // current/next/previousPageToken
    variables.currentPageToken = selection.pageToken || pagination.defaultToken();
    const nextPageToken = pagination.isPastEnd(nextOffset) ? null : pagination.tokenFor(nextOffset);
    if (nextPageToken !== undefined) {
        variables.nextPageToken = nextPageToken;
    }
    const previousPageToken = previousOffset < 0 ? null : pagination.tokenFor(previousOffset);
    if (previousPageToken !== undefined) {
        variables.previousPageToken = previousPageToken;
    }
    // current/next/previousPageUrls cannot be generated until we have a template url
}
function variables(key, selection, record, data, variables, reader) {
    reader.readScalar(selection.name, variables, data);
}
function url(key, selection, record, data, variables, reader) {
    let urlProp = selection.name;
    let tokenProp = `${urlProp.substring(0, urlProp.indexOf('Url'))}Token`;
    // TODO W-6741077 Remove this change when craig sets the currentPageUrl
    if (variables[tokenProp] && record.currentPageUrl) {
        // currentPageUrl should never be empty so use that as the template
        variables[urlProp] = record.currentPageUrl
            .replace(/pageToken=[^&]+/, `pageToken=${variables[tokenProp]}`)
            .replace(/pageSize=\d+/, `pageSize=${variables.__pageSize}`);
    }
    else if (variables[tokenProp] === null) {
        variables[urlProp] = null;
    }
    reader.readScalar(selection.name, variables, data);
}

const DEFAULT_PAGE_SIZE$3 = 50;
const RELATED_LIST_REFERENCE_SELECTIONS = select$U().selections;
const select$12 = (_luvio, params) => {
    const { queryParams, urlParams } = params;
    const { relatedListId, parentRecordId } = urlParams;
    let { fields = [], optionalFields = [], sortBy = [], pageToken, pageSize = DEFAULT_PAGE_SIZE$3, } = queryParams;
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                kind: 'Custom',
                name: 'records',
                plural: true,
                selections: buildSelectionFromFields(fields, optionalFields),
                tokenDataKey: paginationKeyBuilder$2({
                    sortBy,
                    parentRecordId,
                    relatedListId,
                }),
                pageToken,
                pageSize,
                reader: records,
            },
            {
                kind: 'Object',
                name: 'listReference',
                selections: RELATED_LIST_REFERENCE_SELECTIONS,
            },
            {
                kind: 'Custom',
                name: 'count',
                reader: variables,
            },
            {
                kind: 'Custom',
                name: 'currentPageToken',
                reader: variables,
            },
            {
                kind: 'Scalar',
                name: 'currentPageUrl',
            },
            {
                kind: 'Scalar',
                name: 'fields',
                plural: true,
            },
            {
                kind: 'Scalar',
                name: 'optionalFields',
                plural: true,
            },
            {
                kind: 'Scalar',
                name: 'listInfoETag',
            },
            {
                kind: 'Custom',
                name: 'nextPageToken',
                reader: variables,
            },
            {
                kind: 'Custom',
                name: 'nextPageUrl',
                reader: url,
            },
            {
                kind: 'Custom',
                name: 'previousPageToken',
                reader: variables,
            },
            {
                kind: 'Custom',
                name: 'previousPageUrl',
                reader: url,
            },
            staticValuePathSelection({
                name: 'pageSize',
                value: pageSize === undefined ? DEFAULT_PAGE_SIZE$3 : pageSize,
            }),
            {
                kind: 'Scalar',
                name: 'sortBy',
                plural: true,
            },
        ],
    };
};
const ingestSuccess$q = (luvio, resourceRequestConfig, resp, snapshotRefresh) => {
    const { body } = resp;
    // TODO: remove me after W-8673110 is sorted out.
    const returnedFieldsDebug = body.records.map((record, index) => `Returned fields for ${index}, apiName: ${record.apiName}: ` +
        Object.keys(record.fields || {}).join());
    const key = keyBuilder$1a(resourceRequestConfig);
    luvio.storeIngest(key, ingest$r, body);
    if (body.optionalFields && body.optionalFields.length > 0) {
        markMissingOptionalRecordFieldsMissing(body.records, body.optionalFields, luvio);
    }
    const snapshot = luvio.storeLookup({
        recordId: key,
        node: select$12(luvio, resourceRequestConfig),
        variables: {},
    }, snapshotRefresh);
    if (isUnfulfilledSnapshot(snapshot)) {
        // TODO: revert me after W-8673110 is sorted out.
        throw new Error(`${Object.keys(snapshot.missingPaths).join(', ')} missing immediately after get-related-list-records request.
            Requested fields: ${resourceRequestConfig.queryParams.fields === null ||
            resourceRequestConfig.queryParams.fields === undefined
            ? undefined
            : resourceRequestConfig.queryParams.fields.join()}
            Requested optionalFields: ${resourceRequestConfig.queryParams.optionalFields === null ||
            resourceRequestConfig.queryParams.optionalFields === undefined
            ? undefined
            : resourceRequestConfig.queryParams.optionalFields.join()}
            ${returnedFieldsDebug}`);
    }
    return snapshot;
};
function markMissingOptionalRecordFieldsMissing(returnedRecords, optionalFields, luvio) {
    for (let i = 0; i < returnedRecords.length; i++) {
        const record = returnedRecords[i];
        const recordKey = record.__ref;
        if (recordKey) {
            const node = luvio.getNode(recordKey);
            if (isGraphNode(node)) {
                markMissingOptionalFields(node, optionalFields);
            }
        }
    }
}

// Single Wire Imports
const createChildResourceParams$5 = (resourceParams) => {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListIds.length; index < len; index += 1) {
        const relatedListId = resourceParams.urlParams.relatedListIds[index];
        const fieldsString = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.fields);
        const fields = fieldsString === undefined ? undefined : fieldsString.split(',');
        const optionalFieldsString = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.optionalFields);
        const optionalFields = optionalFieldsString === undefined ? undefined : optionalFieldsString.split(',');
        const sortByString = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.sortBy);
        const sortBy = sortByString === undefined ? undefined : sortByString.split(',');
        const pageSize = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.pageSize);
        childConfigs.push({
            urlParams: {
                parentRecordId: resourceParams.urlParams.parentRecordId,
                relatedListId: relatedListId,
            },
            queryParams: {
                fields: fields,
                optionalFields: optionalFields,
                sortBy: sortBy,
                pageSize: pageSize ? Number(pageSize) : undefined,
            },
        });
    }
    return childConfigs;
};
function extractSingleResourceParamsFromBatchParamString(relatedListId, batchParamString) {
    if (batchParamString === undefined) {
        return undefined;
    }
    const match = batchParamString
        .split(';')
        .find((fieldString) => fieldString.split(':')[0] === relatedListId);
    return match === undefined ? undefined : match.slice(relatedListId.length + 1);
}
// HUGE BLOCK OF COPY PASTED CODE:
// WE NEED TO DO THIS SO THAT THE ADAPTER CAN USE ONLY OUR OVERRIDE FILE
// PLEASE DO NOT CHANGE ANYTHING HERE...
function select$13(luvio, resourceParams) {
    const childResources = createChildResourceParams$5(resourceParams);
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$1a(childResource);
                const childFragment = select$12(luvio, childResource);
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        // eslint-disable-next-line no-case-declarations
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        reader.markMissing();
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        },
    };
}
function keyBuilder$1b(params) {
    return (keyPrefix +
        'RelatedListRecordCollectionBatchRepresentation(' +
        'fields:' +
        params.queryParams.fields +
        ',' +
        'optionalFields:' +
        params.queryParams.optionalFields +
        ',' +
        'pageSize:' +
        params.queryParams.pageSize +
        ',' +
        'sortBy:' +
        params.queryParams.sortBy +
        ',' +
        'parentRecordId:' +
        params.urlParams.parentRecordId +
        ',' +
        'relatedListIds:' +
        params.urlParams.relatedListIds +
        ')');
}
function ingestSuccess$r(luvio, resourceParams, response, _snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$5(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' +
                childResourceParamsArray.length +
                ' items, received ' +
                childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$1b(resourceParams);
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childSnapshot = ingestSuccess$q(luvio, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$r(luvio, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$1a(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses,
    };
    ObjectFreeze(childSnapshotData);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$13(luvio, resourceParams),
            variables: {},
        },
        variables: {},
    };
}
function ingestError$s(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$1b(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot);
    return errorSnapshot;
}
function createResourceRequest$A(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/related-list-records/batch/' +
            config.urlParams.parentRecordId +
            '/' +
            config.urlParams.relatedListIds +
            '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function createResourceParams$u(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListIds: config.relatedListIds
        },
        queryParams: {
            fields: config.fields, optionalFields: config.optionalFields, pageSize: config.pageSize, sortBy: config.sortBy
        }
    };
}
function keyBuilder$1c(luvio, config) {
    const resourceParams = createResourceParams$u(config);
    return keyBuilder$1b(resourceParams);
}
function adapterFragment$q(luvio, config) {
    const resourceParams = createResourceParams$u(config);
    return select$13(luvio, resourceParams);
}
function buildInMemorySnapshot$v(luvio, config) {
    const selector = {
        recordId: keyBuilder$1c(luvio, config),
        node: adapterFragment$q(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$q(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$r(luvio, resourceParams, response);
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$r(luvio, config, resourceParams, response) {
    const snapshot = ingestError$s(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$u(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$u(luvio, config, override) {
    const resourceParams = createResourceParams$u(config);
    const request = createResourceRequest$A(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$q(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$r(luvio, config, resourceParams, response);
    });
}

const getRelatedListRecordsBatch_ConfigPropertyNames = {
    displayName: 'getRelatedListRecordsBatch',
    parameters: {
        required: ['parentRecordId', 'relatedLists'],
        optional: [],
    },
};
function coerceActualAdapterConfigToGeneratedRepresentation(config) {
    var relatedListIds = [];
    var fields = [];
    var optionalFields = [];
    var pageSize = [];
    var sortBy = [];
    config.relatedLists.forEach((relatedList) => {
        relatedListIds.push(relatedList.relatedListId);
        if (!!relatedList.fields && relatedList.fields.length) {
            fields.push(relatedList.relatedListId + ':' + relatedList.fields.join());
        }
        if (!!relatedList.optionalFields && relatedList.optionalFields.length) {
            optionalFields.push(relatedList.relatedListId + ':' + relatedList.optionalFields.join());
        }
        if (relatedList.pageSize) {
            pageSize.push(relatedList.relatedListId + ':' + relatedList.pageSize);
        }
        if (!!relatedList.sortBy && relatedList.sortBy.length) {
            sortBy.push(relatedList.relatedListId + ':' + relatedList.sortBy.join());
        }
    });
    const fieldsParam = fields.join(';');
    const optionalFieldsParam = optionalFields.join(';');
    const pageSizeParam = pageSize.join(';');
    const sortByParam = sortBy.join(';');
    return {
        parentRecordId: config.parentRecordId,
        relatedListIds: relatedListIds,
        fields: fieldsParam,
        optionalFields: optionalFieldsParam,
        pageSize: pageSizeParam,
        sortBy: sortByParam,
    };
}
function typeCheckConfig$v(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedLists = untrustedConfig.relatedLists;
    if (ArrayIsArray(untrustedConfig_relatedLists)) {
        const untrustedConfig_relatedLists_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedLists.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListIds_item = untrustedConfig_relatedLists[i];
            if (typeof untrustedConfig_relatedListIds_item === 'object') {
                // Not sure if this inner type checking is necessary?
                const untrustedConfig_fields = untrustedConfig_relatedListIds_item.fields;
                if (ArrayIsArray(untrustedConfig_fields)) {
                    const untrustedConfig_fields_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
                        const untrustedConfig_fields_item = untrustedConfig_fields[i];
                        if (typeof untrustedConfig_fields_item === 'string') {
                            untrustedConfig_fields_array.push(untrustedConfig_fields_item);
                        }
                    }
                    untrustedConfig_relatedListIds_item.fields = untrustedConfig_fields_array;
                }
                const untrustedConfig_optionalFields = untrustedConfig_relatedListIds_item.optionalFields;
                if (ArrayIsArray(untrustedConfig_optionalFields)) {
                    const untrustedConfig_optionalFields_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
                        const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
                        if (typeof untrustedConfig_optionalFields_item === 'string') {
                            untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
                        }
                    }
                    untrustedConfig_relatedListIds_item.optionalFields =
                        untrustedConfig_optionalFields_array;
                }
                const untrustedConfig_pageSize = untrustedConfig_relatedListIds_item.pageSize;
                if (untrustedConfig_pageSize) {
                    if (typeof untrustedConfig_pageSize === 'number') {
                        untrustedConfig_relatedListIds_item.pageSize = untrustedConfig_pageSize;
                    }
                    else {
                        //Not a number here, set pagesize to undefined
                        untrustedConfig_relatedListIds_item.pageSize = undefined;
                    }
                }
                const untrustedConfig_sortBy = untrustedConfig_relatedListIds_item.sortBy;
                if (ArrayIsArray(untrustedConfig_sortBy)) {
                    const untrustedConfig_sortBy_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
                        const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
                        if (typeof untrustedConfig_sortBy_item === 'string') {
                            untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
                        }
                    }
                    untrustedConfig_relatedListIds_item.sortBy = untrustedConfig_sortBy_array;
                }
                untrustedConfig_relatedLists_array.push(untrustedConfig_relatedListIds_item);
            }
        }
        config.relatedLists = untrustedConfig_relatedLists_array;
    }
    return config;
}
const getRelatedListRecordsBatchAdapterFactory = (luvio) => function getRelatedListRecordsBatch(untrustedConfig) {
    const config = validateAdapterConfig$v(untrustedConfig, getRelatedListRecordsBatch_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const coercedConfig = coerceActualAdapterConfigToGeneratedRepresentation(config);
    const cacheSnapshot = buildInMemorySnapshot$v(luvio, coercedConfig);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    return buildNetworkSnapshot$u(luvio, coercedConfig);
};
// HUGE BLOCK OF COPY PASTED CODE:
// WE NEED TO DO THIS SO THAT THE ADAPTER CAN USE OUR OVERWRITTEN FUNCTIONS
// PLEASE DO NOT CHANGE ANYTHING HERE...
function validateAdapterConfig$v(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$v(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const getRelatedListRecords_ConfigPropertyNames = {
    displayName: 'getRelatedListRecords',
    parameters: {
        required: ['parentRecordId', 'relatedListId'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function createResourceParams$v(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListId: config.relatedListId
        },
        queryParams: {
            fields: config.fields, optionalFields: config.optionalFields, pageSize: config.pageSize, pageToken: config.pageToken, sortBy: config.sortBy
        }
    };
}
function keyBuilder$1d(luvio, config) {
    const resourceParams = createResourceParams$v(config);
    return keyBuilder$1a(resourceParams);
}
function typeCheckConfig$w(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$w(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$w(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function adapterFragment$r(luvio, config) {
    const resourceParams = createResourceParams$v(config);
    return select$12(luvio, resourceParams);
}
function buildInMemorySnapshot$w(luvio, config) {
    const selector = {
        recordId: keyBuilder$1d(luvio, config),
        node: adapterFragment$r(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$r(luvio, config, resourceParams, response) {
    const snapshot = ingestSuccess$q(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$s(luvio, config, resourceParams, response) {
    const snapshot = ingestError$r(luvio, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$v(luvio, config, snapshotRefreshOptions)
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$v(luvio, config, override) {
    const resourceParams = createResourceParams$v(config);
    const request = createResourceRequest$z(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$r(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$s(luvio, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$t(luvio, config, snapshot) {
    const resourceParams = createResourceParams$v(config);
    const request = createResourceRequest$z(resourceParams);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$r(luvio, config, resourceParams, response);
    }, (response) => {
        return onResourceResponseError$s(luvio, config, resourceParams, response);
    });
}
const getRelatedListRecordsAdapterFactory = (luvio) => function uiApi__getRelatedListRecords(untrustedConfig) {
    const config = validateAdapterConfig$w(untrustedConfig, getRelatedListRecords_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$w(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$t(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$v(luvio, config);
};

function createResourceRequest$B(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

var LayoutType;
(function (LayoutType) {
    LayoutType["Full"] = "Full";
    LayoutType["Compact"] = "Compact";
})(LayoutType || (LayoutType = {}));

function coerceLayoutType(value) {
    if (value === LayoutType.Full || value === LayoutType.Compact) {
        return value;
    }
    return undefined;
}

function coerceLayoutMode(value) {
    if (value === LayoutMode.Create || value === LayoutMode.Edit || value === LayoutMode.View) {
        return value;
    }
    return undefined;
}

function coerceConfig$l(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const formFactor = config.formFactor;
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const layoutType = coerceLayoutType(config.layoutType);
    if (layoutType !== undefined) {
        coercedConfig.layoutType = layoutType;
    }
    const mode = coerceLayoutMode(config.mode);
    if (mode !== undefined) {
        coercedConfig.mode = mode;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$x(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_layoutType = untrustedConfig.layoutType;
    if (typeof untrustedConfig_layoutType === 'string') {
        config.layoutType = untrustedConfig_layoutType;
    }
    const untrustedConfig_mode = untrustedConfig.mode;
    if (typeof untrustedConfig_mode === 'string') {
        config.mode = untrustedConfig_mode;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$x(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$l(untrustedConfig);
    const config = typeCheckConfig$x(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const layoutSelections$2 = select$h();
// FYI stricter required set than RAML, matches lds222 behavior
const getLayout_ConfigPropertyNames = {
    displayName: 'getLayout',
    parameters: {
        required: ['objectApiName', 'layoutType', 'mode'],
        optional: ['recordTypeId'],
    },
};
function buildSnapshotRefresh$5(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$w(luvio, config, snapshotRefreshOptions),
    };
}
function buildRequestAndKey(config) {
    const recordTypeId = config.recordTypeId;
    const request = createResourceRequest$B({
        urlParams: {
            objectApiName: config.objectApiName,
        },
        queryParams: {
            layoutType: config.layoutType,
            mode: config.mode,
            recordTypeId,
        },
    });
    const key = keyBuilder$i({
        objectApiName: config.objectApiName,
        recordTypeId,
        layoutType: config.layoutType,
        mode: config.mode,
    });
    return { request, key };
}
function onResourceResponseSuccess$s(luvio, config, key, response) {
    const { body } = response;
    luvio.storeIngest(key, ingest$9, body);
    luvio.storeBroadcast();
    return luvio.storeLookup({
        recordId: key,
        node: layoutSelections$2,
        variables: {},
    }, buildSnapshotRefresh$5(luvio, config));
}
function onResourceResponseError$t(luvio, config, key, error) {
    const errorSnapshot = luvio.errorSnapshot(error, buildSnapshotRefresh$5(luvio, config));
    luvio.storeIngestError(key, errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function buildNetworkSnapshot$w(luvio, config, requestOverride) {
    const { request, key } = buildRequestAndKey(config);
    return luvio.dispatchResourceRequest(request, requestOverride).then((response) => {
        return onResourceResponseSuccess$s(luvio, config, key, response);
    }, (error) => {
        return onResourceResponseError$t(luvio, config, key, error);
    });
}
function resolveUnfulfilledSnapshot$u(luvio, config, snapshot) {
    const { request, key } = buildRequestAndKey(config);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot).then((response) => {
        return onResourceResponseSuccess$s(luvio, config, key, response);
    }, (error) => {
        return onResourceResponseError$t(luvio, config, key, error);
    });
}
function buildInMemorySnapshot$x(luvio, config) {
    const { recordTypeId, layoutType, mode } = config;
    const key = keyBuilder$i({
        objectApiName: config.objectApiName,
        recordTypeId,
        layoutType,
        mode,
    });
    return luvio.storeLookup({
        recordId: key,
        node: layoutSelections$2,
        variables: {},
    }, buildSnapshotRefresh$5(luvio, config));
}
function coerceConfigWithDefaults$1(untrusted) {
    const config = validateAdapterConfig$x(untrusted, getLayout_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    // recordTypeId coercion is nuts: if `null` (but not undefined) then use MASTER record type id
    let recordTypeId = config.recordTypeId;
    if (recordTypeId === undefined) {
        // must check untrusted bc config has been coerced
        if (untrusted.recordTypeId !== null) {
            return null;
        }
        recordTypeId = MASTER_RECORD_TYPE_ID;
    }
    // layoutType and mode are required during validation.
    // They will always be valid at this point.
    return {
        ...config,
        recordTypeId,
        layoutType: config.layoutType,
        mode: config.mode,
    };
}
const factory$5 = (luvio) => function getLayout(untrusted) {
    const config = coerceConfigWithDefaults$1(untrusted);
    if (config === null) {
        return null;
    }
    const snapshot = buildInMemorySnapshot$x(luvio, config);
    // Cache hit
    if (luvio.snapshotAvailable(snapshot)) {
        return snapshot;
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot$u(luvio, config, snapshot);
    }
    return buildNetworkSnapshot$w(luvio, config);
};

function createResourceRequest$C(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '/user-state',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function coerceConfig$m(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const formFactor = config.formFactor;
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const layoutType = coerceLayoutType(config.layoutType);
    if (layoutType !== undefined) {
        coercedConfig.layoutType = layoutType;
    }
    const mode = coerceLayoutMode(config.mode);
    if (mode !== undefined) {
        coercedConfig.mode = mode;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$y(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_layoutType = untrustedConfig.layoutType;
    if (typeof untrustedConfig_layoutType === 'string') {
        config.layoutType = untrustedConfig_layoutType;
    }
    const untrustedConfig_mode = untrustedConfig.mode;
    if (typeof untrustedConfig_mode === 'string') {
        config.mode = untrustedConfig_mode;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$y(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$m(untrustedConfig);
    const config = typeCheckConfig$y(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const recordLayoutSelect = select$i();
// FYI stricter required set than RAML defines, matches lds222 behavior
const getLayoutUserState_ConfigPropertyNames = {
    displayName: 'getLayoutUserState',
    parameters: {
        required: ['objectApiName', 'recordTypeId'],
        optional: ['formFactor', 'layoutType', 'mode'],
    },
};
function coerceConfigWithDefaults$2(untrustedConfig) {
    const config = validateAdapterConfig$y(untrustedConfig, getLayoutUserState_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    // recordTypeId is overridden to be required
    const recordTypeId = config.recordTypeId;
    const untrusted = untrustedConfig;
    let layoutType = config.layoutType;
    if (layoutType === undefined) {
        if (untrusted.layoutType === undefined) {
            layoutType = LayoutType.Full;
        }
        else {
            return null;
        }
    }
    let mode = config.mode;
    if (mode === undefined) {
        if (untrusted.mode === undefined) {
            mode = LayoutMode.View;
        }
        else {
            return null;
        }
    }
    return {
        ...config,
        recordTypeId,
        layoutType,
        mode,
    };
}
function buildSnapshotRefresh$6(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$x(luvio, config),
    };
}
function buildInMemorySnapshot$y(luvio, config) {
    const { objectApiName, recordTypeId, layoutType, mode } = config;
    const key = keyBuilder$j({
        apiName: objectApiName,
        recordTypeId,
        layoutType,
        mode,
    });
    return luvio.storeLookup({
        recordId: key,
        node: recordLayoutSelect,
        variables: {},
    }, buildSnapshotRefresh$6(luvio, config));
}
function buildNetworkSnapshot$x(luvio, config) {
    const { request, key } = prepareRequest$3(config);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResourceResponseSuccess$t(luvio, config, key, response);
    }, (error) => {
        return onResourceResponseError$u(luvio, config, key, error);
    });
}
function resolveUnfulfilledSnapshot$v(luvio, config, snapshot) {
    const { request, key } = prepareRequest$3(config);
    return luvio
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$t(luvio, config, key, response);
    }, (error) => {
        return onResourceResponseError$u(luvio, config, key, error);
    });
}
function onResourceResponseSuccess$t(luvio, config, key, response) {
    const { body } = response;
    const { recordTypeId, layoutType, mode } = config;
    // Hack- adding in this params so record-ui will be able to use normed values.
    body.apiName = config.objectApiName;
    body.recordTypeId = recordTypeId;
    body.layoutType = layoutType;
    body.mode = mode;
    luvio.storeIngest(key, ingest$a, body);
    luvio.storeBroadcast();
    return buildInMemorySnapshot$y(luvio, config);
}
function onResourceResponseError$u(luvio, config, key, error) {
    const errorSnapshot = luvio.errorSnapshot(error, buildSnapshotRefresh$6(luvio, config));
    luvio.storeIngestError(key, errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function prepareRequest$3(config) {
    const { recordTypeId, layoutType, mode, objectApiName } = config;
    const key = keyBuilder$j({
        apiName: objectApiName,
        recordTypeId,
        layoutType,
        mode,
    });
    const request = createResourceRequest$C({
        urlParams: { objectApiName: config.objectApiName },
        queryParams: {
            layoutType: config.layoutType,
            mode: config.mode,
            recordTypeId: config.recordTypeId,
        },
    });
    return { request, key };
}
const factory$6 = (luvio) => function getLayoutUserState(untrustedConfig) {
    const config = coerceConfigWithDefaults$2(untrustedConfig);
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$y(luvio, config);
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot)) {
        return cacheSnapshot;
    }
    if (isUnfulfilledSnapshot(cacheSnapshot)) {
        return resolveUnfulfilledSnapshot$v(luvio, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$x(luvio, config);
};

function deepFreeze$t(value) {
    // No need to freeze primitives
    if (typeof value !== 'object' || value === null) {
        return;
    }
    if (isArray(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
            deepFreeze$t(value[i]);
        }
    }
    else {
        const keys$1 = keys(value);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
            deepFreeze$t(value[keys$1[i]]);
        }
    }
    freeze(value);
}

function keyBuilder$1e(params) {
    return keyPrefix + 'RecordCollectionRepresentation(' + 'dependentFieldBindings:' + params.queryParams.dependentFieldBindings + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'q:' + params.queryParams.q + ',' + 'searchType:' + params.queryParams.searchType + ',' + 'sourceRecordId:' + params.queryParams.sourceRecordId + ',' + 'fieldApiName:' + params.urlParams.fieldApiName + ',' + 'objectApiName:' + params.urlParams.objectApiName + ',' + 'targetApiName:' + params.urlParams.targetApiName + ')';
}
function createResourceRequest$E(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/lookups/' + config.urlParams.objectApiName + '/' + config.urlParams.fieldApiName + '/' + config.urlParams.targetApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function coerceConfig$n(config) {
    const coercedConfig = {};
    const fieldApiName = getFieldApiName(config.fieldApiName);
    if (fieldApiName !== undefined) {
        coercedConfig.fieldApiName = fieldApiName;
    }
    const objectApiName = config.objectApiName;
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const targetApiName = getObjectApiName(config.targetApiName);
    if (targetApiName !== undefined) {
        coercedConfig.targetApiName = targetApiName;
    }
    const dependentFieldBindings = config.dependentFieldBindings;
    if (dependentFieldBindings !== undefined) {
        coercedConfig.dependentFieldBindings = dependentFieldBindings;
    }
    const page = config.page;
    if (page !== undefined) {
        coercedConfig.page = page;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const q = config.q;
    if (q !== undefined) {
        coercedConfig.q = q;
    }
    const searchType = config.searchType;
    if (searchType !== undefined) {
        coercedConfig.searchType = searchType;
    }
    const sourceRecordId = config.sourceRecordId;
    if (sourceRecordId !== undefined) {
        coercedConfig.sourceRecordId = sourceRecordId;
    }
    return coercedConfig;
}
function typeCheckConfig$z(untrustedConfig) {
    const config = {};
    const untrustedConfig_fieldApiName = untrustedConfig.fieldApiName;
    if (typeof untrustedConfig_fieldApiName === 'string') {
        config.fieldApiName = untrustedConfig_fieldApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_targetApiName = untrustedConfig.targetApiName;
    if (typeof untrustedConfig_targetApiName === 'string') {
        config.targetApiName = untrustedConfig_targetApiName;
    }
    const untrustedConfig_dependentFieldBindings = untrustedConfig.dependentFieldBindings;
    if (ArrayIsArray(untrustedConfig_dependentFieldBindings)) {
        const untrustedConfig_dependentFieldBindings_array = [];
        for (let i = 0, arrayLength = untrustedConfig_dependentFieldBindings.length; i < arrayLength; i++) {
            const untrustedConfig_dependentFieldBindings_item = untrustedConfig_dependentFieldBindings[i];
            if (typeof untrustedConfig_dependentFieldBindings_item === 'string') {
                untrustedConfig_dependentFieldBindings_array.push(untrustedConfig_dependentFieldBindings_item);
            }
        }
        config.dependentFieldBindings = untrustedConfig_dependentFieldBindings_array;
    }
    const untrustedConfig_page = untrustedConfig.page;
    if (typeof untrustedConfig_page === 'number' && Math.floor(untrustedConfig_page) === untrustedConfig_page) {
        config.page = untrustedConfig_page;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_q = untrustedConfig.q;
    if (typeof untrustedConfig_q === 'string') {
        config.q = untrustedConfig_q;
    }
    const untrustedConfig_searchType = untrustedConfig.searchType;
    if (typeof untrustedConfig_searchType === 'string') {
        config.searchType = untrustedConfig_searchType;
    }
    const untrustedConfig_sourceRecordId = untrustedConfig.sourceRecordId;
    if (typeof untrustedConfig_sourceRecordId === 'string') {
        config.sourceRecordId = untrustedConfig_sourceRecordId;
    }
    return config;
}
function validateAdapterConfig$z(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$n(untrustedConfig);
    const config = typeCheckConfig$z(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const paramNames = {
    displayName: 'getLookupRecords',
    parameters: {
        required: ['fieldApiName', 'targetApiName'],
        optional: ['requestParams'],
    },
};
function coerceRequestParams(untrusted) {
    if (!untrustedIsObject(untrusted)) {
        return {};
    }
    const coercedConfig = {};
    const requestParams = untrusted.requestParams || {};
    const dependentFieldBindings = requestParams.dependentFieldBindings;
    if (dependentFieldBindings !== undefined) {
        coercedConfig.dependentFieldBindings = dependentFieldBindings;
    }
    const page = requestParams.page;
    if (page !== undefined) {
        coercedConfig.page = page;
    }
    const pageSize = requestParams.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const q = requestParams.q;
    if (q !== undefined) {
        coercedConfig.q = q;
    }
    const searchType = requestParams.searchType;
    if (searchType !== undefined) {
        coercedConfig.searchType = searchType;
    }
    const sourceRecordId = requestParams.sourceRecordId;
    if (sourceRecordId !== undefined) {
        coercedConfig.sourceRecordId = sourceRecordId;
    }
    return coercedConfig;
}
function coerceConfigWithDefaults$4(untrusted) {
    const config = validateAdapterConfig$z(untrusted, paramNames);
    if (config === null) {
        return config;
    }
    const coercedRequestParams = coerceRequestParams(untrusted);
    const { objectApiName, fieldApiName } = getFieldId(config.fieldApiName);
    return {
        ...config,
        objectApiName,
        fieldApiName,
        ...coercedRequestParams,
    };
}
function removeEtags(recordRep) {
    const { fields } = recordRep;
    delete recordRep.eTag;
    delete recordRep.weakEtag;
    Object.keys(fields).forEach((fieldName) => {
        const { value: nestedValue } = fields[fieldName];
        if (isSpanningRecord(nestedValue)) {
            removeEtags(nestedValue);
        }
    });
}
function buildNetworkSnapshot$y(luvio, config) {
    const { objectApiName, fieldApiName, targetApiName } = config;
    const resourceParams = {
        urlParams: {
            objectApiName,
            fieldApiName,
            targetApiName,
        },
        queryParams: {
            page: config.page,
            pageSize: config.pageSize,
            q: config.q,
            searchType: config.searchType,
            dependentFieldBindings: config.dependentFieldBindings,
            sourceRecordId: config.sourceRecordId,
        },
    };
    const request = createResourceRequest$E(resourceParams);
    return luvio.dispatchResourceRequest(request).then((response) => {
        // TODO W-7235112 - remove this hack to never ingest lookup responses that
        // avoids issues caused by them not being real RecordRepresentations
        const key = keyBuilder$1e(resourceParams);
        const { body } = response;
        const { records } = body;
        for (let i = 0, len = records.length; i < len; i += 1) {
            removeEtags(records[i]);
        }
        deepFreeze$t(body);
        return {
            state: 'Fulfilled',
            recordId: key,
            variables: {},
            seenRecords: {},
            select: {
                recordId: key,
                node: {
                    kind: 'Fragment',
                },
                variables: {},
            },
            data: body,
        };
    }, (err) => {
        return luvio.errorSnapshot(err);
    });
}
const factory$8 = (luvio) => {
    return refreshable(function (untrusted) {
        const config = coerceConfigWithDefaults$4(untrusted);
        if (config === null) {
            return null;
        }
        return buildNetworkSnapshot$y(luvio, config);
    }, (untrusted) => {
        const config = coerceConfigWithDefaults$4(untrusted);
        if (config === null) {
            throw new Error('Refresh should not be called with partial configuration');
        }
        return buildNetworkSnapshot$y(luvio, config);
    });
};

function createResourceRequest$F(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '/picklist-values/' + config.urlParams.recordTypeId + '/' + config.urlParams.fieldApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const adapterName = 'getPicklistValues';
function coerceConfig$o(config) {
    const coercedConfig = {};
    const fieldApiName = getFieldApiName(config.fieldApiName);
    if (fieldApiName !== undefined) {
        coercedConfig.fieldApiName = fieldApiName;
    }
    const objectApiName = config.objectApiName;
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$A(untrustedConfig) {
    const config = {};
    const untrustedConfig_fieldApiName = untrustedConfig.fieldApiName;
    if (typeof untrustedConfig_fieldApiName === 'string') {
        config.fieldApiName = untrustedConfig_fieldApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$A(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$o(untrustedConfig);
    const config = typeCheckConfig$A(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const path = select$P().selections;
function buildSnapshotRefresh$7(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$z(luvio, config),
    };
}
function buildRequestAndKey$1(config) {
    const { recordTypeId, fieldApiName } = config;
    const fieldNames = getFieldId(fieldApiName);
    const request = createResourceRequest$F({
        urlParams: {
            objectApiName: fieldNames.objectApiName,
            fieldApiName: fieldNames.fieldApiName,
            recordTypeId,
        },
    });
    const key = keyBuilder$T({ id: `${request.baseUri}${request.basePath}` });
    return { request, key };
}
function onResponseSuccess(luvio, config, key, response) {
    const { body } = response;
    luvio.storeIngest(key, ingest$l, body);
    luvio.storeBroadcast();
    return buildInMemorySnapshot$z(luvio, config);
}
function onResponseError(luvio, config, key, err) {
    const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$7(luvio, config));
    luvio.storeIngestError(key, errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function buildNetworkSnapshot$z(luvio, config) {
    const { request, key } = buildRequestAndKey$1(config);
    return luvio.dispatchResourceRequest(request).then((response) => {
        return onResponseSuccess(luvio, config, key, response);
    }, (err) => {
        return onResponseError(luvio, config, key, err);
    });
}
function resolveUnfulfilledSnapshot$w(luvio, config, snapshot) {
    const { request, key } = buildRequestAndKey$1(config);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot).then((response) => {
        return onResponseSuccess(luvio, config, key, response);
    }, (err) => {
        return onResponseError(luvio, config, key, err);
    });
}
function buildInMemorySnapshot$z(luvio, config) {
    const fieldNames = getFieldId(config.fieldApiName);
    const request = createResourceRequest$F({
        urlParams: {
            objectApiName: fieldNames.objectApiName,
            fieldApiName: fieldNames.fieldApiName,
            recordTypeId: config.recordTypeId,
        },
    });
    const key = keyBuilder$T({ id: `${request.baseUri}${request.basePath}` });
    return luvio.storeLookup({
        recordId: key,
        node: {
            kind: 'Fragment',
            private: ['eTag'],
            selections: path,
        },
        variables: {},
    }, buildSnapshotRefresh$7(luvio, config));
}
const picklistValuesConfigPropertyNames = {
    displayName: adapterName,
    parameters: {
        required: ['recordTypeId', 'fieldApiName'],
        optional: [],
    },
};
const factory$9 = (luvio) => function getPicklistValues(untrusted) {
    const config = validateAdapterConfig$A(untrusted, picklistValuesConfigPropertyNames);
    if (config === null) {
        return null;
    }
    const snapshot = buildInMemorySnapshot$z(luvio, config);
    if (luvio.snapshotAvailable(snapshot)) {
        return snapshot;
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot$w(luvio, config, snapshot);
    }
    return buildNetworkSnapshot$z(luvio, config);
};

function validate$Y(obj, path = 'PhotoMetadataRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_companyBluemasterId = obj.companyBluemasterId;
        const path_companyBluemasterId = path + '.companyBluemasterId';
        let obj_companyBluemasterId_union0 = null;
        const obj_companyBluemasterId_union0_error = (() => {
            if (typeof obj_companyBluemasterId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_companyBluemasterId + '" (at "' + path_companyBluemasterId + '")');
            }
        })();
        if (obj_companyBluemasterId_union0_error != null) {
            obj_companyBluemasterId_union0 = obj_companyBluemasterId_union0_error.message;
        }
        let obj_companyBluemasterId_union1 = null;
        const obj_companyBluemasterId_union1_error = (() => {
            if (obj_companyBluemasterId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_companyBluemasterId + '" (at "' + path_companyBluemasterId + '")');
            }
        })();
        if (obj_companyBluemasterId_union1_error != null) {
            obj_companyBluemasterId_union1 = obj_companyBluemasterId_union1_error.message;
        }
        if (obj_companyBluemasterId_union0 && obj_companyBluemasterId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_companyBluemasterId + '")';
            message += '\n' + obj_companyBluemasterId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_companyBluemasterId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_responseId = obj.responseId;
        const path_responseId = path + '.responseId';
        let obj_responseId_union0 = null;
        const obj_responseId_union0_error = (() => {
            if (typeof obj_responseId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_responseId + '" (at "' + path_responseId + '")');
            }
        })();
        if (obj_responseId_union0_error != null) {
            obj_responseId_union0 = obj_responseId_union0_error.message;
        }
        let obj_responseId_union1 = null;
        const obj_responseId_union1_error = (() => {
            if (obj_responseId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_responseId + '" (at "' + path_responseId + '")');
            }
        })();
        if (obj_responseId_union1_error != null) {
            obj_responseId_union1 = obj_responseId_union1_error.message;
        }
        if (obj_responseId_union0 && obj_responseId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_responseId + '")';
            message += '\n' + obj_responseId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_responseId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$14 = function PhotoMetadataRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'companyBluemasterId',
                kind: 'Scalar'
            },
            {
                name: 'responseId',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$w(existing, incoming) {
    const existing_companyBluemasterId = existing.companyBluemasterId;
    const incoming_companyBluemasterId = incoming.companyBluemasterId;
    if (!(existing_companyBluemasterId === incoming_companyBluemasterId)) {
        return false;
    }
    const existing_responseId = existing.responseId;
    const incoming_responseId = incoming.responseId;
    if (!(existing_responseId === incoming_responseId)) {
        return false;
    }
    return true;
}

function validate$Z(obj, path = 'PhotoRecordAvatarRepresentation') {
    const validateAbstractRecordAvatarRepresentation_validateError = validate$$(obj, path);
    if (validateAbstractRecordAvatarRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_backgroundColor = obj.backgroundColor;
        const path_backgroundColor = path + '.backgroundColor';
        let obj_backgroundColor_union0 = null;
        const obj_backgroundColor_union0_error = (() => {
            if (typeof obj_backgroundColor !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union0_error != null) {
            obj_backgroundColor_union0 = obj_backgroundColor_union0_error.message;
        }
        let obj_backgroundColor_union1 = null;
        const obj_backgroundColor_union1_error = (() => {
            if (obj_backgroundColor !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union1_error != null) {
            obj_backgroundColor_union1 = obj_backgroundColor_union1_error.message;
        }
        if (obj_backgroundColor_union0 && obj_backgroundColor_union1) {
            let message = 'Object doesn\'t match union (at "' + path_backgroundColor + '")';
            message += '\n' + obj_backgroundColor_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_backgroundColor_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_height = obj.height;
        const path_height = path + '.height';
        let obj_height_union0 = null;
        const obj_height_union0_error = (() => {
            if (typeof obj_height !== 'number' || (typeof obj_height === 'number' && Math.floor(obj_height) !== obj_height)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_height + '" (at "' + path_height + '")');
            }
        })();
        if (obj_height_union0_error != null) {
            obj_height_union0 = obj_height_union0_error.message;
        }
        let obj_height_union1 = null;
        const obj_height_union1_error = (() => {
            if (obj_height !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_height + '" (at "' + path_height + '")');
            }
        })();
        if (obj_height_union1_error != null) {
            obj_height_union1 = obj_height_union1_error.message;
        }
        if (obj_height_union0 && obj_height_union1) {
            let message = 'Object doesn\'t match union (at "' + path_height + '")';
            message += '\n' + obj_height_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_height_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_photoMetadata = obj.photoMetadata;
        const path_photoMetadata = path + '.photoMetadata';
        const referencepath_photoMetadataValidationError = validate$Y(obj_photoMetadata, path_photoMetadata);
        if (referencepath_photoMetadataValidationError !== null) {
            let message = 'Object doesn\'t match PhotoMetadataRepresentation (at "' + path_photoMetadata + '")\n';
            message += referencepath_photoMetadataValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_photoUrl = obj.photoUrl;
        const path_photoUrl = path + '.photoUrl';
        if (typeof obj_photoUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_photoUrl + '" (at "' + path_photoUrl + '")');
        }
        const obj_provider = obj.provider;
        const path_provider = path + '.provider';
        let obj_provider_union0 = null;
        const obj_provider_union0_error = (() => {
            if (typeof obj_provider !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_provider + '" (at "' + path_provider + '")');
            }
        })();
        if (obj_provider_union0_error != null) {
            obj_provider_union0 = obj_provider_union0_error.message;
        }
        let obj_provider_union1 = null;
        const obj_provider_union1_error = (() => {
            if (obj_provider !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_provider + '" (at "' + path_provider + '")');
            }
        })();
        if (obj_provider_union1_error != null) {
            obj_provider_union1 = obj_provider_union1_error.message;
        }
        if (obj_provider_union0 && obj_provider_union1) {
            let message = 'Object doesn\'t match union (at "' + path_provider + '")';
            message += '\n' + obj_provider_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_provider_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_width = obj.width;
        const path_width = path + '.width';
        let obj_width_union0 = null;
        const obj_width_union0_error = (() => {
            if (typeof obj_width !== 'number' || (typeof obj_width === 'number' && Math.floor(obj_width) !== obj_width)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_width + '" (at "' + path_width + '")');
            }
        })();
        if (obj_width_union0_error != null) {
            obj_width_union0 = obj_width_union0_error.message;
        }
        let obj_width_union1 = null;
        const obj_width_union1_error = (() => {
            if (obj_width !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_width + '" (at "' + path_width + '")');
            }
        })();
        if (obj_width_union1_error != null) {
            obj_width_union1 = obj_width_union1_error.message;
        }
        if (obj_width_union0 && obj_width_union1) {
            let message = 'Object doesn\'t match union (at "' + path_width + '")';
            message += '\n' + obj_width_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_width_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilderFromType$j(object) {
    return keyBuilderFromType$l(object);
}
function normalize$s(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$15 = function PhotoRecordAvatarRepresentationSelect() {
    const { selections: AbstractRecordAvatarRepresentationSelections } = select$17();
    const { selections: PhotoMetadataRepresentation__selections, opaque: PhotoMetadataRepresentation__opaque, } = select$14();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            ...AbstractRecordAvatarRepresentationSelections,
            {
                name: 'backgroundColor',
                kind: 'Scalar'
            },
            {
                name: 'height',
                kind: 'Scalar'
            },
            {
                name: 'photoMetadata',
                kind: 'Object',
                selections: PhotoMetadataRepresentation__selections
            },
            {
                name: 'photoUrl',
                kind: 'Scalar'
            },
            {
                name: 'provider',
                kind: 'Scalar'
            },
            {
                name: 'width',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$x(existing, incoming) {
    if (equals$z(existing, incoming) === false) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_photoUrl = existing.photoUrl;
    const incoming_photoUrl = incoming.photoUrl;
    if (!(existing_photoUrl === incoming_photoUrl)) {
        return false;
    }
    const existing_backgroundColor = existing.backgroundColor;
    const incoming_backgroundColor = incoming.backgroundColor;
    if (!(existing_backgroundColor === incoming_backgroundColor)) {
        return false;
    }
    const existing_height = existing.height;
    const incoming_height = incoming.height;
    if (!(existing_height === incoming_height)) {
        return false;
    }
    const existing_photoMetadata = existing.photoMetadata;
    const incoming_photoMetadata = incoming.photoMetadata;
    if (!(equals$w(existing_photoMetadata, incoming_photoMetadata))) {
        return false;
    }
    const existing_provider = existing.provider;
    const incoming_provider = incoming.provider;
    if (!(existing_provider === incoming_provider)) {
        return false;
    }
    const existing_width = existing.width;
    const incoming_width = incoming.width;
    if (!(existing_width === incoming_width)) {
        return false;
    }
    return true;
}
const ingest$s = function PhotoRecordAvatarRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$Z(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$j(input);
    let incomingRecord = normalize$s(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$x(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$_(obj, path = 'ThemeRecordAvatarRepresentation') {
    const validateAbstractRecordAvatarRepresentation_validateError = validate$$(obj, path);
    if (validateAbstractRecordAvatarRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_backgroundColor = obj.backgroundColor;
        const path_backgroundColor = path + '.backgroundColor';
        let obj_backgroundColor_union0 = null;
        const obj_backgroundColor_union0_error = (() => {
            if (typeof obj_backgroundColor !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union0_error != null) {
            obj_backgroundColor_union0 = obj_backgroundColor_union0_error.message;
        }
        let obj_backgroundColor_union1 = null;
        const obj_backgroundColor_union1_error = (() => {
            if (obj_backgroundColor !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union1_error != null) {
            obj_backgroundColor_union1 = obj_backgroundColor_union1_error.message;
        }
        if (obj_backgroundColor_union0 && obj_backgroundColor_union1) {
            let message = 'Object doesn\'t match union (at "' + path_backgroundColor + '")';
            message += '\n' + obj_backgroundColor_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_backgroundColor_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
            if (typeof obj_iconUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union0_error != null) {
            obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
            if (obj_iconUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union1_error != null) {
            obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
            message += '\n' + obj_iconUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_iconUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilderFromType$k(object) {
    return keyBuilderFromType$l(object);
}
function normalize$t(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$16 = function ThemeRecordAvatarRepresentationSelect() {
    const { selections: AbstractRecordAvatarRepresentationSelections } = select$17();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            ...AbstractRecordAvatarRepresentationSelections,
            {
                name: 'backgroundColor',
                kind: 'Scalar'
            },
            {
                name: 'iconUrl',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$y(existing, incoming) {
    if (equals$z(existing, incoming) === false) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_backgroundColor = existing.backgroundColor;
    const incoming_backgroundColor = incoming.backgroundColor;
    if (!(existing_backgroundColor === incoming_backgroundColor)) {
        return false;
    }
    const existing_iconUrl = existing.iconUrl;
    const incoming_iconUrl = incoming.iconUrl;
    if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
    }
    return true;
}
const ingest$t = function ThemeRecordAvatarRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$_(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$k(input);
    let incomingRecord = normalize$t(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$y(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

var DiscriminatorValues$2;
(function (DiscriminatorValues) {
    DiscriminatorValues["Photo"] = "Photo";
    DiscriminatorValues["Theme"] = "Theme";
})(DiscriminatorValues$2 || (DiscriminatorValues$2 = {}));
function validate$$(obj, path = 'AbstractRecordAvatarRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_recordId = obj.recordId;
        const path_recordId = path + '.recordId';
        if (typeof obj_recordId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordId + '" (at "' + path_recordId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1f(config) {
    return keyPrefix + 'AbstractRecordAvatarRepresentation:' + config.recordId;
}
function keyBuilderFromType$l(object) {
    const keyParams = {
        recordId: object.recordId
    };
    return keyBuilder$1f(keyParams);
}
const selectChildren$1 = function AbstractRecordAvatarRepresentationSelectChildren() {
    const photoRecordAvatarRepresentationSelections = select$15();
    const themeRecordAvatarRepresentationSelections = select$16();
    return {
        kind: 'Fragment',
        union: true,
        discriminator: 'type',
        unionSelections: {
            [DiscriminatorValues$2.Photo]: photoRecordAvatarRepresentationSelections,
            [DiscriminatorValues$2.Theme]: themeRecordAvatarRepresentationSelections
        }
    };
};
const select$17 = function AbstractRecordAvatarRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'recordId',
                kind: 'Scalar'
            },
            {
                name: 'type',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$z(existing, incoming) {
    const existing_recordId = existing.recordId;
    const incoming_recordId = incoming.recordId;
    if (!(existing_recordId === incoming_recordId)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    return true;
}
const discriminatorIngest = function AbstractRecordAvatarRepresentationDiscriminatorIngest(input, path, luvio, store, timestamp) {
    const discriminatorValue = input.type;
    if (discriminatorValue === 'Photo') {
        return ingest$s(input, path, luvio, store);
    }
    if (discriminatorValue === 'Theme') {
        return ingest$t(input, path, luvio, store);
    }
    throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "Photo","Theme"`);
};

function validate$10(obj, path = 'RecordAvatarBatchRepresentation') {
    const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$14(obj, path);
    if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (typeof obj_result !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$u(input, existing, path, luvio, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = discriminatorIngest(input_result, {
        fullPath: input_result_id,
        propertyName: 'result',
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, luvio, store);
    return input;
}
const select$18 = function RecordAvatarBatchRepresentationSelect() {
    const { selections: AbstractRecordAvatarBatchRepresentationSelections } = select$1c();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractRecordAvatarBatchRepresentationSelections,
            {
                kind: 'Link',
                name: 'result',
                fragment: selectChildren$1()
            }
        ]
    };
};
function equals$A(existing, incoming) {
    if (equals$E(existing, incoming) === false) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$u = function RecordAvatarBatchRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$10(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$u(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$A(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function validate$11(obj, path = 'ErrorSingleRecordAvatarRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_errorCode = obj.errorCode;
        const path_errorCode = path + '.errorCode';
        if (typeof obj_errorCode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_errorCode + '" (at "' + path_errorCode + '")');
        }
        const obj_message = obj.message;
        const path_message = path + '.message';
        if (typeof obj_message !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_message + '" (at "' + path_message + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$19 = function ErrorSingleRecordAvatarRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'errorCode',
                kind: 'Scalar'
            },
            {
                name: 'message',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$B(existing, incoming) {
    const existing_errorCode = existing.errorCode;
    const incoming_errorCode = incoming.errorCode;
    if (!(existing_errorCode === incoming_errorCode)) {
        return false;
    }
    const existing_message = existing.message;
    const incoming_message = incoming.message;
    if (!(existing_message === incoming_message)) {
        return false;
    }
    return true;
}

function validate$12(obj, path = 'ErrorBadRequestRecordAvatarBatchRepresentation') {
    const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$14(obj, path);
    if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (!ArrayIsArray$1(obj_result)) {
            return new TypeError('Expected "array" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
        for (let i = 0; i < obj_result.length; i++) {
            const obj_result_item = obj_result[i];
            const path_result_item = path_result + '[' + i + ']';
            const referencepath_result_itemValidationError = validate$11(obj_result_item, path_result_item);
            if (referencepath_result_itemValidationError !== null) {
                let message = 'Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "' + path_result_item + '")\n';
                message += referencepath_result_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$v(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$1a = function ErrorBadRequestRecordAvatarBatchRepresentationSelect() {
    const { selections: AbstractRecordAvatarBatchRepresentationSelections } = select$1c();
    const { selections: ErrorSingleRecordAvatarRepresentation__selections, opaque: ErrorSingleRecordAvatarRepresentation__opaque, } = select$19();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractRecordAvatarBatchRepresentationSelections,
            {
                name: 'result',
                kind: 'Object',
                plural: true,
                selections: ErrorSingleRecordAvatarRepresentation__selections
            }
        ]
    };
};
function equals$C(existing, incoming) {
    if (equals$E(existing, incoming) === false) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    const equals_result_items = equalsArray(existing_result, incoming_result, (existing_result_item, incoming_result_item) => {
        if (!(equals$B(existing_result_item, incoming_result_item))) {
            return false;
        }
    });
    if (equals_result_items === false) {
        return false;
    }
    return true;
}
const ingest$v = function ErrorBadRequestRecordAvatarBatchRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$12(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$v(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$C(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function validate$13(obj, path = 'ErrorRecordAvatarBatchRepresentation') {
    const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$14(obj, path);
    if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (!ArrayIsArray$1(obj_result)) {
            return new TypeError('Expected "array" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
        for (let i = 0; i < obj_result.length; i++) {
            const obj_result_item = obj_result[i];
            const path_result_item = path_result + '[' + i + ']';
            const referencepath_result_itemValidationError = validate$11(obj_result_item, path_result_item);
            if (referencepath_result_itemValidationError !== null) {
                let message = 'Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "' + path_result_item + '")\n';
                message += referencepath_result_itemValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$w(input, existing, path, luvio, store, timestamp) {
    return input;
}
const select$1b = function ErrorRecordAvatarBatchRepresentationSelect() {
    const { selections: AbstractRecordAvatarBatchRepresentationSelections } = select$1c();
    const { selections: ErrorSingleRecordAvatarRepresentation__selections, opaque: ErrorSingleRecordAvatarRepresentation__opaque, } = select$19();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractRecordAvatarBatchRepresentationSelections,
            {
                name: 'result',
                kind: 'Object',
                plural: true,
                selections: ErrorSingleRecordAvatarRepresentation__selections
            }
        ]
    };
};
function equals$D(existing, incoming) {
    if (equals$E(existing, incoming) === false) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    const equals_result_items = equalsArray(existing_result, incoming_result, (existing_result_item, incoming_result_item) => {
        if (!(equals$B(existing_result_item, incoming_result_item))) {
            return false;
        }
    });
    if (equals_result_items === false) {
        return false;
    }
    return true;
}
const ingest$w = function ErrorRecordAvatarBatchRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$13(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$w(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$D(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

const DiscriminatorValues$3 = {
    '200': 200,
    '400': 400,
    '404': 404
};
function validate$14(obj, path = 'AbstractRecordAvatarBatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_statusCode = obj.statusCode;
        const path_statusCode = path + '.statusCode';
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const selectChildren$2 = function AbstractRecordAvatarBatchRepresentationSelectChildren() {
    const recordAvatarBatchRepresentationSelections = select$18();
    const errorBadRequestRecordAvatarBatchRepresentationSelections = select$1a();
    const errorRecordAvatarBatchRepresentationSelections = select$1b();
    return {
        kind: 'Fragment',
        union: true,
        discriminator: 'statusCode',
        unionSelections: {
            [DiscriminatorValues$3['200']]: recordAvatarBatchRepresentationSelections,
            [DiscriminatorValues$3['400']]: errorBadRequestRecordAvatarBatchRepresentationSelections,
            [DiscriminatorValues$3['404']]: errorRecordAvatarBatchRepresentationSelections
        }
    };
};
const select$1c = function AbstractRecordAvatarBatchRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'statusCode',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$E(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    return true;
}
const discriminatorIngest$1 = function AbstractRecordAvatarBatchRepresentationDiscriminatorIngest(input, path, luvio, store, timestamp) {
    const discriminatorValue = input.statusCode;
    if (discriminatorValue === 200) {
        return ingest$u(input, path, luvio, store, timestamp);
    }
    if (discriminatorValue === 400) {
        return ingest$v(input, path, luvio, store, timestamp);
    }
    if (discriminatorValue === 404) {
        return ingest$w(input, path, luvio, store, timestamp);
    }
    throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "200","400","404"`);
};

function validate$15(obj, path = 'RecordAvatarBulkMapRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_keys = ObjectKeys$1(obj);
        for (let i = 0; i < obj_keys.length; i++) {
            const key = obj_keys[i];
            const obj_prop = obj[key];
            const path_prop = path + '["' + key + '"]';
            if (typeof obj_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_prop + '" (at "' + path_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$x(input, existing, path, luvio, store, timestamp) {
    const input_keys = Object.keys(input);
    const input_length = input_keys.length;
    for (let i = 0; i < input_length; i++) {
        const key = input_keys[i];
        const input_prop = input[key];
        const input_prop_id = path.fullPath + '__' + key;
        input[key] = discriminatorIngest$1(input_prop, {
            fullPath: input_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
function equals$F(existing, incoming) {
    const equals_props = equalsObject(existing, incoming, (existing_prop, incoming_prop) => {
        if (!(existing_prop.__ref === incoming_prop.__ref)) {
            return false;
        }
    });
    if (equals_props === false) {
        return false;
    }
    return true;
}

function merge$3(existing, incoming, _luvio, _path) {
    if (existing === undefined) {
        return incoming;
    }
    // Merge RecordRepresentation field values together
    return {
        ...existing,
        ...incoming,
    };
}

const ingest$x = function RecordAvatarBulkMapRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$15(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$x(input, store.records[key], {
        fullPath: key,
        propertyName: path.propertyName,
        parent: path.parent,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    incomingRecord = merge$3(existingRecord, incomingRecord);
    if (existingRecord === undefined || equals$F(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createResourceRequest$G(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/record-avatars/batch/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRecordAvatars_ConfigPropertyNames = {
    displayName: 'getRecordAvatars',
    parameters: {
        required: ['recordIds'],
        optional: ['formFactor']
    }
};
function coerceConfig$p(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    return coercedConfig;
}
function typeCheckConfig$B(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    return config;
}
function validateAdapterConfig$B(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$p(untrustedConfig);
    const config = typeCheckConfig$B(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function selectAvatars(recordIds) {
    return recordIds.map((recordId) => {
        return {
            kind: 'Link',
            name: recordId,
            fragment: selectChildren$2(),
        };
    });
}
// All of the avatars are ingested into
// the same top level object
const KEY = `${keyPrefix}RecordAvatarsBulk`;
// Track in-flight requests so we known when to send out our fake response
const IN_FLIGHT_REQUESTS = new Set();
function buildInMemorySnapshot$A(luvio, config) {
    const { recordIds } = config;
    const sel = selectAvatars(recordIds);
    return luvio.storeLookup({
        recordId: KEY,
        node: {
            kind: 'Fragment',
            private: [],
            selections: sel,
        },
        variables: {},
    }, buildSnapshotRefresh$8(luvio, config, recordIds));
}
function buildSnapshotRefresh$8(luvio, config, recordIds) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$A(luvio, config, recordIds),
    };
}
function buildRequest(recordIds) {
    const resourceRequest = createResourceRequest$G({
        urlParams: {
            recordIds,
        },
        queryParams: {},
    });
    return resourceRequest;
}
/**
 * For 230/232 this is a workaround to not having inflight deduping for record avatars
 * The way it works is we ingest a fake response while the real response is pending.
 * So for example a component wires record avatars for ABC, while that request is in flight
 * another component wires record avatars AB. The wire for ABC will send off a request for data
 * Then AB comes in and will resolve the fake response instead of sending off a request.
 * Then once the real response comes back it will be ingested and it will notify both AB and ABC.
 * We will resolve this in 234 using real inflight deduping W-8318817
 */
function ingestFakeResponse(luvio, recordIds) {
    const formatted = reduce.call(recordIds, (accum, recordId) => {
        accum[recordId] = {
            statusCode: 200,
            result: {
                backgroundColor: null,
                eTag: '',
                height: null,
                photoMetadata: { companyBluemasterId: null, responseId: null },
                photoUrl: '',
                provider: null,
                recordId: '',
                type: 'Photo',
                width: null,
            },
        };
        return accum;
    }, {});
    luvio.storeIngest(KEY, ingest$x, formatted);
}
function isRecordAvatarBulkMapRepresentation(response) {
    return response.body.hasErrors === undefined;
}
function onResponseSuccess$1(luvio, config, recordIds, response) {
    let formatted;
    // Remove ids from in flight list
    recordIds.forEach((id) => IN_FLIGHT_REQUESTS.delete(id));
    // the selector passed to resolveUnfulfilledSnapshot requests the data already formatted so the response
    // can either be a RecordAvatarBulkRepresentation or a RecordAvatarBulkMapRepresentation
    if (isRecordAvatarBulkMapRepresentation(response)) {
        formatted = response.body;
    }
    else {
        formatted = response.body.results.reduce((seed, avatar, index) => {
            const recordId = recordIds[index];
            seed[recordId] = avatar;
            return seed;
        }, {});
    }
    luvio.storeIngest(KEY, ingest$x, formatted);
    luvio.storeBroadcast();
    return buildInMemorySnapshot$A(luvio, config);
}
function onResponseError$1(luvio, config, recordIds, err) {
    // Remove ids from in flight list
    recordIds.forEach((id) => IN_FLIGHT_REQUESTS.delete(id));
    const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$8(luvio, config, recordIds));
    luvio.storeIngestError(KEY, errorSnapshot);
    luvio.storeBroadcast();
    return errorSnapshot;
}
function resolveUnfulfilledSnapshot$x(luvio, config, recordIds, snapshot) {
    const recordIdsNotInFlight = [], recordIdsInFlight = [];
    let luvioResponse;
    // Split up the given record ids into in flight ids and not in flight ids
    recordIds.forEach((id) => {
        if (IN_FLIGHT_REQUESTS.has(id)) {
            recordIdsInFlight.push(id);
        }
        else {
            recordIdsNotInFlight.push(id);
        }
    });
    // For any remaining record ids send off the real request and add it to the in flight request list
    if (recordIdsNotInFlight.length > 0) {
        recordIdsNotInFlight.forEach((id) => IN_FLIGHT_REQUESTS.add(id));
        const resourceRequest = buildRequest(recordIdsNotInFlight);
        luvioResponse = luvio.resolveUnfulfilledSnapshot(resourceRequest, snapshot).then((response) => {
            return onResponseSuccess$1(luvio, config, recordIdsNotInFlight, response);
        }, (err) => {
            return onResponseError$1(luvio, config, recordIdsNotInFlight, err);
        });
    }
    // For any currently in flight record ids lets emit a fake response
    if (recordIdsInFlight.length > 0) {
        ingestFakeResponse(luvio, recordIdsInFlight);
    }
    return luvioResponse ? luvioResponse : buildInMemorySnapshot$A(luvio, config);
}
/**
 *
 * The third argument, "recordIds", is here because
 * We only want to fetch avatars that are actually missing
 * This list will be a subset of the recordIds that are on the adapter config.
 *
 */
function buildNetworkSnapshot$A(luvio, config, recordIds) {
    const resourceRequest = buildRequest(recordIds);
    return luvio.dispatchResourceRequest(resourceRequest).then((response) => {
        return onResponseSuccess$1(luvio, config, recordIds, response);
    }, (err) => {
        return onResponseError$1(luvio, config, recordIds, err);
    });
}
// We have to type guard against pending snapshots
// We should only ever get UnfulfilledSnapshot here
function getRecordIds(config, snapshot) {
    if (process.env.NODE_ENV !== 'production') {
        if (isUnfulfilledSnapshot(snapshot) === false) {
            throw new Error('Unexpected snapshot state in "getRecordIds" in "getRecordAvatars"');
        }
    }
    // Missing all avatars
    if (snapshot.data === undefined) {
        return config.recordIds;
    }
    return keys(snapshot.missingPaths).sort();
}
const factory$a = (luvio) => function getRecordAvatars(unknown) {
    const config = validateAdapterConfig$B(unknown, getRecordAvatars_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    const cacheLookup = buildInMemorySnapshot$A(luvio, config);
    // CACHE HIT
    if (luvio.snapshotAvailable(cacheLookup)) {
        return cacheLookup;
    }
    // CACHE MISS
    // Only fetch avatars that are missing
    const recordIds = getRecordIds(config, cacheLookup);
    if (isUnfulfilledSnapshot(cacheLookup)) {
        return resolveUnfulfilledSnapshot$x(luvio, config, recordIds, cacheLookup);
    }
    return buildNetworkSnapshot$A(luvio, config, recordIds);
};

function createResourceRequest$H(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/record-avatars/' + config.urlParams.recordId + '/association',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const updateRecordAvatar_ConfigPropertyNames = {
    displayName: 'updateRecordAvatar',
    parameters: {
        required: ['recordId', 'actionType'],
        optional: ['blueMasterId', 'externalId', 'photoUrl', 'profileName']
    }
};
function typeCheckConfig$C(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_actionType = untrustedConfig.actionType;
    if (typeof untrustedConfig_actionType === 'string') {
        config.actionType = untrustedConfig_actionType;
    }
    const untrustedConfig_blueMasterId = untrustedConfig.blueMasterId;
    if (typeof untrustedConfig_blueMasterId === 'string') {
        config.blueMasterId = untrustedConfig_blueMasterId;
    }
    const untrustedConfig_externalId = untrustedConfig.externalId;
    if (typeof untrustedConfig_externalId === 'string') {
        config.externalId = untrustedConfig_externalId;
    }
    const untrustedConfig_photoUrl = untrustedConfig.photoUrl;
    if (typeof untrustedConfig_photoUrl === 'string') {
        config.photoUrl = untrustedConfig_photoUrl;
    }
    const untrustedConfig_profileName = untrustedConfig.profileName;
    if (typeof untrustedConfig_profileName === 'string') {
        config.profileName = untrustedConfig_profileName;
    }
    return config;
}
function validateAdapterConfig$C(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$C(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const factory$b = (luvio) => {
    return (untrustedConfig) => {
        const config = validateAdapterConfig$C(untrustedConfig, updateRecordAvatar_ConfigPropertyNames);
        if (config === null) {
            throw new Error('updateRecordAvatar invalid configuration');
        }
        const resourceParams = {
            urlParams: {
                recordId: config.recordId,
            },
            body: {
                externalId: config.externalId,
                blueMasterId: config.blueMasterId,
                profileName: config.profileName,
                photoUrl: config.photoUrl,
                actionType: config.actionType,
            },
        };
        const request = createResourceRequest$H(resourceParams);
        return luvio.dispatchResourceRequest(request).then((response) => {
            const { body } = response;
            const key = keyBuilderFromType$l(body);
            let selectors;
            if (body.type === 'Theme') {
                selectors = select$16;
                luvio.storeIngest(key, ingest$t, body);
            }
            else if (body.type === 'Photo') {
                selectors = select$15;
                luvio.storeIngest(key, ingest$s, body);
            }
            else {
                throw new Error('Unsupported avatar type');
            }
            // TODO W-6804405 - support unions on fragments (only supported on links today)
            const snapshot = luvio.storeLookup({
                recordId: key,
                node: selectors(),
                variables: {},
            });
            luvio.storeBroadcast();
            return snapshot;
        }, (err) => {
            deepFreeze$t(err);
            throw err;
        });
    };
};

function validate$16(obj, path = 'RecordCreateDefaultRecordRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (typeof obj_childRelationships !== 'object' || ArrayIsArray$1(obj_childRelationships) || obj_childRelationships === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        const obj_childRelationships_keys = ObjectKeys$1(obj_childRelationships);
        for (let i = 0; i < obj_childRelationships_keys.length; i++) {
            const key = obj_childRelationships_keys[i];
            const obj_childRelationships_prop = obj_childRelationships[key];
            const path_childRelationships_prop = path_childRelationships + '["' + key + '"]';
            if (typeof obj_childRelationships_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_childRelationships_prop + '" (at "' + path_childRelationships_prop + '")');
            }
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedById = obj.lastModifiedById;
        const path_lastModifiedById = path + '.lastModifiedById';
        let obj_lastModifiedById_union0 = null;
        const obj_lastModifiedById_union0_error = (() => {
            if (typeof obj_lastModifiedById !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union0_error != null) {
            obj_lastModifiedById_union0 = obj_lastModifiedById_union0_error.message;
        }
        let obj_lastModifiedById_union1 = null;
        const obj_lastModifiedById_union1_error = (() => {
            if (obj_lastModifiedById !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union1_error != null) {
            obj_lastModifiedById_union1 = obj_lastModifiedById_union1_error.message;
        }
        if (obj_lastModifiedById_union0 && obj_lastModifiedById_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedById + '")';
            message += '\n' + obj_lastModifiedById_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedById_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
            if (typeof obj_lastModifiedDate !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
            obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
            if (obj_lastModifiedDate !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
            obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
            message += '\n' + obj_lastModifiedDate_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedDate_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeInfo = obj.recordTypeInfo;
        const path_recordTypeInfo = path + '.recordTypeInfo';
        let obj_recordTypeInfo_union0 = null;
        const obj_recordTypeInfo_union0_error = (() => {
            const referencepath_recordTypeInfoValidationError = validate$6(obj_recordTypeInfo, path_recordTypeInfo);
            if (referencepath_recordTypeInfoValidationError !== null) {
                let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfo + '")\n';
                message += referencepath_recordTypeInfoValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_recordTypeInfo_union0_error != null) {
            obj_recordTypeInfo_union0 = obj_recordTypeInfo_union0_error.message;
        }
        let obj_recordTypeInfo_union1 = null;
        const obj_recordTypeInfo_union1_error = (() => {
            if (obj_recordTypeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeInfo + '" (at "' + path_recordTypeInfo + '")');
            }
        })();
        if (obj_recordTypeInfo_union1_error != null) {
            obj_recordTypeInfo_union1 = obj_recordTypeInfo_union1_error.message;
        }
        if (obj_recordTypeInfo_union0 && obj_recordTypeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeInfo + '")';
            message += '\n' + obj_recordTypeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_systemModstamp = obj.systemModstamp;
        const path_systemModstamp = path + '.systemModstamp';
        let obj_systemModstamp_union0 = null;
        const obj_systemModstamp_union0_error = (() => {
            if (typeof obj_systemModstamp !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union0_error != null) {
            obj_systemModstamp_union0 = obj_systemModstamp_union0_error.message;
        }
        let obj_systemModstamp_union1 = null;
        const obj_systemModstamp_union1_error = (() => {
            if (obj_systemModstamp !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union1_error != null) {
            obj_systemModstamp_union1 = obj_systemModstamp_union1_error.message;
        }
        if (obj_systemModstamp_union0 && obj_systemModstamp_union1) {
            let message = 'Object doesn\'t match union (at "' + path_systemModstamp + '")';
            message += '\n' + obj_systemModstamp_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_systemModstamp_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_weakEtag = obj.weakEtag;
        const path_weakEtag = path + '.weakEtag';
        if (typeof obj_weakEtag !== 'number' || (typeof obj_weakEtag === 'number' && Math.floor(obj_weakEtag) !== obj_weakEtag)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_weakEtag + '" (at "' + path_weakEtag + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$y(input, existing, path, luvio, store, timestamp) {
    const input_childRelationships = input.childRelationships;
    const input_childRelationships_id = path.fullPath + '__childRelationships';
    const input_childRelationships_keys = Object.keys(input_childRelationships);
    const input_childRelationships_length = input_childRelationships_keys.length;
    for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        const input_childRelationships_prop = input_childRelationships[key];
        const input_childRelationships_prop_id = input_childRelationships_id + '__' + key;
        input_childRelationships[key] = ingest$2(input_childRelationships_prop, {
            fullPath: input_childRelationships_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    const input_fields = input.fields;
    const input_fields_id = path.fullPath + '__fields';
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        const input_fields_prop_id = input_fields_id + '__' + key;
        input_fields[key] = ingest$3(input_fields_prop, {
            fullPath: input_fields_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    return input;
}
function equals$G(existing, incoming) {
    const existing_weakEtag = existing.weakEtag;
    const incoming_weakEtag = incoming.weakEtag;
    if (!(existing_weakEtag === incoming_weakEtag)) {
        return false;
    }
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_childRelationships = existing.childRelationships;
    const incoming_childRelationships = incoming.childRelationships;
    const equals_childRelationships_props = equalsObject(existing_childRelationships, incoming_childRelationships, (existing_childRelationships_prop, incoming_childRelationships_prop) => {
        if (!(existing_childRelationships_prop.__ref === incoming_childRelationships_prop.__ref)) {
            return false;
        }
    });
    if (equals_childRelationships_props === false) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_lastModifiedById = existing.lastModifiedById;
    const incoming_lastModifiedById = incoming.lastModifiedById;
    if (!(existing_lastModifiedById === incoming_lastModifiedById)) {
        return false;
    }
    const existing_lastModifiedDate = existing.lastModifiedDate;
    const incoming_lastModifiedDate = incoming.lastModifiedDate;
    if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    const existing_recordTypeInfo = existing.recordTypeInfo;
    const incoming_recordTypeInfo = incoming.recordTypeInfo;
    if (!(existing_recordTypeInfo === incoming_recordTypeInfo
        || (existing_recordTypeInfo != null &&
            incoming_recordTypeInfo != null &&
            equals$2(existing_recordTypeInfo, incoming_recordTypeInfo)))) {
        return false;
    }
    const existing_systemModstamp = existing.systemModstamp;
    const incoming_systemModstamp = incoming.systemModstamp;
    if (!(existing_systemModstamp === incoming_systemModstamp)) {
        return false;
    }
    return true;
}
const ingest$y = function RecordCreateDefaultRecordRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$16(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$y(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$G(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$17(obj, path = 'RecordDefaultsRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_layout = obj.layout;
        const path_layout = path + '.layout';
        let obj_layout_union0 = null;
        const obj_layout_union0_error = (() => {
            if (typeof obj_layout !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_layout + '" (at "' + path_layout + '")');
            }
        })();
        if (obj_layout_union0_error != null) {
            obj_layout_union0 = obj_layout_union0_error.message;
        }
        let obj_layout_union1 = null;
        const obj_layout_union1_error = (() => {
            if (obj_layout !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_layout + '" (at "' + path_layout + '")');
            }
        })();
        if (obj_layout_union1_error != null) {
            obj_layout_union1 = obj_layout_union1_error.message;
        }
        if (obj_layout_union0 && obj_layout_union1) {
            let message = 'Object doesn\'t match union (at "' + path_layout + '")';
            message += '\n' + obj_layout_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_layout_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$z(input, existing, path, luvio, store, timestamp) {
    const input_layout = input.layout;
    const input_layout_id = path.fullPath + '__layout';
    if (input_layout !== null && typeof input_layout === 'object') {
        input.layout = ingest$9(input_layout, {
            fullPath: input_layout_id,
            propertyName: 'layout',
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    const input_objectInfos = input.objectInfos;
    const input_objectInfos_id = path.fullPath + '__objectInfos';
    const input_objectInfos_keys = Object.keys(input_objectInfos);
    const input_objectInfos_length = input_objectInfos_keys.length;
    for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$8(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            propertyName: key,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
    }
    const input_record = input.record;
    const input_record_id = path.fullPath + '__record';
    input.record = ingest$y(input_record, {
        fullPath: input_record_id,
        propertyName: 'record',
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, luvio, store, timestamp);
    return input;
}
function equals$H(existing, incoming) {
    const existing_layout = existing.layout;
    const incoming_layout = incoming.layout;
    if (!(existing_layout === incoming_layout
        || (existing_layout != null &&
            incoming_layout != null &&
            existing_layout.__ref != null &&
            incoming_layout.__ref != null &&
            existing_layout.__ref === incoming_layout.__ref))) {
        return false;
    }
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_record = existing.record;
    const incoming_record = incoming.record;
    if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
    }
    return true;
}
const ingest$z = function RecordDefaultsRepresentationIngest(input, path, luvio, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$17(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$z(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
        propertyName: path.propertyName,
    }, luvio, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$H(existingRecord, incomingRecord) === false) {
        luvio.storePublish(key, incomingRecord);
    }
    luvio.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function keyBuilder$1g(params) {
    return keyPrefix + 'RecordDefaultsRepresentation(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'optionalFields:' + params.queryParams.optionalFields + ',' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
}
function createResourceRequest$I(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/record-defaults/create/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRecordCreateDefaults_ConfigPropertyNames = {
    displayName: 'getRecordCreateDefaults',
    parameters: {
        required: ['objectApiName'],
        optional: ['formFactor', 'optionalFields', 'recordTypeId']
    }
};
function createResourceParams$w(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            formFactor: config.formFactor, optionalFields: config.optionalFields, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$q(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$D(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$D(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$q(untrustedConfig);
    const config = typeCheckConfig$D(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const layoutSelections$3 = select$h();
const objectInfoSelections = select$f();
function buildSelector(resp) {
    const recordSelections = buildSelectionFromRecord(resp.record);
    return [
        {
            kind: 'Link',
            name: 'layout',
            nullable: true,
            fragment: layoutSelections$3,
        },
        {
            kind: 'Link',
            name: 'objectInfos',
            map: true,
            fragment: objectInfoSelections,
        },
        {
            kind: 'Link',
            name: 'record',
            fragment: {
                kind: 'Fragment',
                private: [],
                selections: recordSelections,
            },
        },
    ];
}
function buildSnapshotRefresh$9(luvio, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$B(luvio, config),
    };
}
function buildNetworkSnapshot$B(luvio, config) {
    const params = createResourceParams$w(config);
    const request = createResourceRequest$I(params);
    const key = keyBuilder$1g(params);
    const selectorKey = `${key}__selector`;
    return luvio.dispatchResourceRequest(request).then((response) => {
        const { body } = response;
        const cacheSelector = {
            recordId: key,
            node: {
                kind: 'Fragment',
                private: [],
                selections: buildSelector(body),
            },
            variables: {},
        };
        luvio.storePublish(selectorKey, cacheSelector);
        luvio.storeIngest(key, ingest$z, body);
        luvio.storeBroadcast();
        return luvio.storeLookup(cacheSelector, buildSnapshotRefresh$9(luvio, config));
    }, (err) => {
        const errorSnapshot = luvio.errorSnapshot(err, buildSnapshotRefresh$9(luvio, config));
        luvio.storeIngestError(key, errorSnapshot);
        luvio.storeBroadcast();
        return errorSnapshot;
    });
}
function coerceConfigWithDefaults$5(untrusted) {
    const config = validateAdapterConfig$D(untrusted, getRecordCreateDefaults_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    let formFactor = config.formFactor;
    if (formFactor === undefined) {
        if (untrusted.formFactor === undefined) {
            formFactor = FormFactor.Large;
        }
        else {
            return null;
        }
    }
    const recordTypeId = config.recordTypeId === undefined ? MASTER_RECORD_TYPE_ID : config.recordTypeId;
    const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
    return {
        ...config,
        formFactor,
        recordTypeId,
        optionalFields,
    };
}
function buildInMemorySnapshot$B(luvio, config) {
    const params = createResourceParams$w(config);
    const key = keyBuilder$1g(params);
    const selectorKey = `${key}__selector`;
    /**
     * getRecordCreateDefaults returns a value that includes a map of ObjectInfos,
     * a layout and a record. The returned record includes fields that are not
     * known to the client. Because we don't know what the return shape will be,
     * we have to store a selector from a previous response and see if we can
     * extract those values back out.
     *
     * cacheSnapshot is the cached selector from a previous request. It is just
     * a stashed selector
     */
    const cacheSnapshot = luvio.storeLookup({
        recordId: selectorKey,
        node: {
            kind: 'Fragment',
            private: [],
            opaque: true,
        },
        variables: {},
    });
    // We've seen this request before
    if (isFulfilledSnapshot(cacheSnapshot)) {
        const snapshot = luvio.storeLookup(cacheSnapshot.data, buildSnapshotRefresh$9(luvio, config));
        // Cache hit
        if (luvio.snapshotAvailable(snapshot)) {
            return snapshot;
        }
    }
    return null;
}
const factory$c = (luvio) => function getRecordCreateDefaults(untrusted) {
    const config = coerceConfigWithDefaults$5(untrusted);
    if (config === null) {
        return null;
    }
    const snapshot = buildInMemorySnapshot$B(luvio, config);
    if (snapshot !== null) {
        return snapshot;
    }
    return buildNetworkSnapshot$B(luvio, config);
};

function validate$18(obj, path = 'RecordTemplateCloneRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_cloneSourceId = obj.cloneSourceId;
        const path_cloneSourceId = path + '.cloneSourceId';
        if (typeof obj_cloneSourceId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_cloneSourceId + '" (at "' + path_cloneSourceId + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1h(config) {
    return keyPrefix + 'RecordTemplateCloneRepresentation:' + config.cloneSourceId + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$m(object) {
    const keyParams = {
        cloneSourceId: object.cloneSourceId,
        recordTypeId: object.recordTypeId
    };
    return keyBuilder$1h(keyParams);
}
function dynamicNormalize$2(ingestParams) {
    return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
            const key = input_fields_keys[i];
            const input_fields_prop = input_fields[key];
            const input_fields_prop_id = input_fields_id + '__' + key;
            input_fields[key] = ingestParams.fields(input_fields_prop, {
                fullPath: input_fields_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        return input;
    };
}
const select$1d = function RecordTemplateCloneRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'cloneSourceId',
                kind: 'Scalar'
            },
            {
                name: 'fields',
                kind: 'Link',
                map: true,
                fragment: select$8()
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            }
        ]
    };
};
const dynamicSelect$2 = function dynamicRecordTemplateCloneRepresentationSelect(params) {
    const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$8()
    } : params.fields;
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'cloneSourceId',
                kind: 'Scalar'
            },
            fieldsPathSelection,
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$I(existing, incoming) {
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_cloneSourceId = existing.cloneSourceId;
    const incoming_cloneSourceId = incoming.cloneSourceId;
    if (!(existing_cloneSourceId === incoming_cloneSourceId)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
function dynamicIngest$1(ingestParams) {
    return function RecordTemplateCloneRepresentationIngest(input, path, luvio, store, timestamp) {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$18(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = keyBuilderFromType$m(input);
        let incomingRecord = dynamicNormalize$2(ingestParams)(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        }, luvio, store, timestamp);
        const existingRecord = store.records[key];
        if (existingRecord === undefined || equals$I(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        luvio.storeSetExpiration(key, timestamp + 1000);
        return createLink(key);
    };
}

const TTL$b = 1000;
function validate$19(obj, path = 'RecordDefaultsTemplateCloneRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1i(config) {
    return keyPrefix + 'RecordDefaultsTemplateCloneRepresentation:' + config.cloneSourceId + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$n(object) {
    const keyParams = {
        cloneSourceId: object.record.cloneSourceId,
        recordTypeId: object.record.recordTypeId
    };
    return keyBuilder$1i(keyParams);
}
function dynamicNormalize$3(ingestParams) {
    return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_objectInfos = input.objectInfos;
        const input_objectInfos_id = path.fullPath + '__objectInfos';
        const input_objectInfos_keys = Object.keys(input_objectInfos);
        const input_objectInfos_length = input_objectInfos_keys.length;
        for (let i = 0; i < input_objectInfos_length; i++) {
            const key = input_objectInfos_keys[i];
            const input_objectInfos_prop = input_objectInfos[key];
            const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
            input_objectInfos[key] = ingestParams.objectInfos(input_objectInfos_prop, {
                fullPath: input_objectInfos_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        const input_record = input.record;
        const input_record_id = path.fullPath + '__record';
        input.record = ingestParams.record(input_record, {
            fullPath: input_record_id,
            propertyName: 'record',
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
        return input;
    };
}
const dynamicSelect$3 = function dynamicRecordDefaultsTemplateCloneRepresentationSelect(params) {
    const objectInfosPathSelection = params.objectInfos === undefined ? {
        name: 'objectInfos',
        kind: 'Link',
        map: true,
        fragment: select$f()
    } : params.objectInfos;
    const recordPathSelection = params.record === undefined ? {
        name: 'record',
        kind: 'Link',
        fragment: select$1d()
    } : params.record;
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            objectInfosPathSelection,
            recordPathSelection
        ]
    };
};
function equals$J(existing, incoming) {
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_record = existing.record;
    const incoming_record = incoming.record;
    if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
    }
    return true;
}
function dynamicIngest$2(ingestParams) {
    return function RecordDefaultsTemplateCloneRepresentationIngest(input, path, luvio, store, timestamp) {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$19(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = keyBuilderFromType$n(input);
        let incomingRecord = dynamicNormalize$3(ingestParams)(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        }, luvio, store, timestamp);
        const existingRecord = store.records[key];
        if (existingRecord === undefined || equals$J(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        luvio.storeSetExpiration(key, timestamp + 1000);
        return createLink(key);
    };
}

function createFieldsIngest$1(params) {
    const { fields, optionalFields, trackedFields, recordConflictMap } = params;
    const ingest = dynamicIngest$1({
        fields: createFieldsIngestion(fields, optionalFields, recordConflictMap)
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$2(fields) {
    return dynamicSelect$2({
        fields: createPathSelection('fields', fields)
    });
}

function createFieldsIngest$2(params) {
    const { fields, optionalFields, trackedFields, recordConflictMap } = params;
    const ingest = dynamicIngest$2({
        objectInfos: ingest$8,
        record: createFieldsIngest$1(params)
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$3(fields) {
    return dynamicSelect$3({
        record: {
            kind: 'Link',
            name: 'record',
            fragment: selectFields$2(fields),
        }
    });
}

function createFieldsIngestSuccess$2(params) {
    const { trackedFields } = params;
    const recordConflictMap = {};
    const ingest = createFieldsIngest$2({
        ...params,
        recordConflictMap,
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$4(luvio, params) {
    const optionalFields = params.queryParams.optionalFields || [];
    const fields = [];
    const trie = convertRecordFieldsArrayToTrie(fields, optionalFields);
    return selectFields$3(trie);
}

const select$1e = (luvio, params) => {
    let { optionalFields } = params.queryParams;
    optionalFields =
        optionalFields === undefined ? ['.CloneSourceId'] : [...optionalFields, '.CloneSourceId'];
    return selectFields$4(luvio, {
        ...params,
        queryParams: {
            ...params.queryParams,
            optionalFields,
        },
    });
};

function createResourceRequest$J(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/record-defaults/template/clone/' + config.urlParams.recordId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const getRecordTemplateClone_ConfigPropertyNames = {
    displayName: 'getRecordTemplateClone',
    parameters: {
        required: ['recordId'],
        optional: ['optionalFields', 'recordTypeId']
    }
};
function createResourceParams$x(config) {
    return {
        urlParams: {
            recordId: config.recordId
        },
        queryParams: {
            optionalFields: config.optionalFields, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$r(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const recordTypeId = config.recordTypeId;
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$E(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$E(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$r(untrustedConfig);
    const config = typeCheckConfig$E(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const DEFAULT_RECORD_TYPE_ID_KEY = 'defaultRecordTypeId';
function saveDefaultRecordTypeId(context, objectInfo) {
    context.set(DEFAULT_RECORD_TYPE_ID_KEY, objectInfo.defaultRecordTypeId);
}
function getRecordTypeId$1(adapterConfig, context) {
    const { recordTypeId } = adapterConfig;
    if (recordTypeId !== undefined && recordTypeId !== null) {
        return recordTypeId;
    }
    const contextValue = context.get(DEFAULT_RECORD_TYPE_ID_KEY);
    if (contextValue === null || contextValue === undefined) {
        return undefined;
    }
    return contextValue;
}
const buildNetworkSnapshot$C = (luvio, context, config, override) => {
    const resourceParams = createResourceParams$x(config);
    const recordTypeId = getRecordTypeId$1(config, context);
    const { recordId } = config;
    const resourceRequest = createResourceRequest$J(resourceParams);
    const coercedRecordTypeId = recordTypeId === undefined ? null : recordTypeId;
    const templateRecordKey = keyBuilder$1h({
        cloneSourceId: recordId,
        recordTypeId: coercedRecordTypeId,
    });
    const request = recordTypeId === undefined
        ? resourceRequest
        : createResourceRequest$J({
            ...resourceParams,
            queryParams: {
                ...resourceRequest.queryParams,
                optionalFields: getTrackedFields(templateRecordKey, luvio.getNode(templateRecordKey), config.optionalFields),
            },
        });
    return luvio
        .dispatchResourceRequest(request, override)
        .then((response) => {
        const { body } = response;
        const key = keyBuilderFromType$n(body);
        const responseRecordTypeId = body.record.recordTypeId;
        const objectApiName = body.record.apiName;
        // publish metadata for recordTypeId
        saveDefaultRecordTypeId(context, body.objectInfos[objectApiName]);
        const optionalFieldsTrie = convertFieldsToTrie(resourceParams.queryParams.optionalFields);
        luvio.storeIngest(key, createFieldsIngestSuccess$2({
            fields: BLANK_RECORD_FIELDS_TRIE,
            optionalFields: optionalFieldsTrie,
            trackedFields: optionalFieldsTrie,
        }), body);
        luvio.storeBroadcast();
        const snapshot = buildInMemorySnapshot$C(luvio, context, {
            ...config,
            recordTypeId: responseRecordTypeId,
        });
        if (process.env.NODE_ENV !== 'production') {
            if (snapshot.state !== 'Fulfilled') {
                throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
        }
        return snapshot;
    }, (response) => {
        const key = keyBuilder$1i({
            cloneSourceId: config.recordId,
            recordTypeId: config.recordTypeId || null,
        });
        const errorSnapshot = luvio.errorSnapshot(response, {
            config,
            resolve: () => buildNetworkSnapshot$C(luvio, context, config, snapshotRefreshOptions),
        });
        luvio.storeIngestError(key, errorSnapshot, TTL$b);
        return errorSnapshot;
    });
};
const buildInMemorySnapshot$C = (luvio, context, config) => {
    const resourceParams = createResourceParams$x(config);
    const key = keyBuilder$1i({
        cloneSourceId: config.recordId,
        recordTypeId: config.recordTypeId || null,
    });
    const selector = {
        recordId: key,
        node: select$1e(luvio, resourceParams),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$C(luvio, context, config, snapshotRefreshOptions),
    });
};
const factory$d = (luvio) => luvio.withContext(function getRecordTemplateClone_ContextWrapper(untrustedConfig, context) {
    const config = validateAdapterConfig$E(untrustedConfig, getRecordTemplateClone_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const recordTypeId = getRecordTypeId$1(config, context);
    const cacheSnapshot = buildInMemorySnapshot$C(luvio, context, {
        ...config,
        recordTypeId,
    });
    // Cache Hit
    if (luvio.snapshotAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    return buildNetworkSnapshot$C(luvio, context, config);
});

function validate$1a(obj, path = 'RecordTemplateCreateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1j(config) {
    return keyPrefix + 'RecordTemplateCreateRepresentation:' + config.apiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$o(object) {
    const keyParams = {
        apiName: object.apiName,
        recordTypeId: object.recordTypeId
    };
    return keyBuilder$1j(keyParams);
}
function dynamicNormalize$4(ingestParams) {
    return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_fields = input.fields;
        const input_fields_id = path.fullPath + '__fields';
        const input_fields_keys = Object.keys(input_fields);
        const input_fields_length = input_fields_keys.length;
        for (let i = 0; i < input_fields_length; i++) {
            const key = input_fields_keys[i];
            const input_fields_prop = input_fields[key];
            const input_fields_prop_id = input_fields_id + '__' + key;
            input_fields[key] = ingestParams.fields(input_fields_prop, {
                fullPath: input_fields_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        return input;
    };
}
const select$1f = function RecordTemplateCreateRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'fields',
                kind: 'Link',
                map: true,
                fragment: select$8()
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            }
        ]
    };
};
const dynamicSelect$4 = function dynamicRecordTemplateCreateRepresentationSelect(params) {
    const fieldsPathSelection = params.fields === undefined ? {
        name: 'fields',
        kind: 'Link',
        map: true,
        fragment: select$8()
    } : params.fields;
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            fieldsPathSelection,
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$K(existing, incoming) {
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
function dynamicIngest$3(ingestParams) {
    return function RecordTemplateCreateRepresentationIngest(input, path, luvio, store, timestamp) {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$1a(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = keyBuilderFromType$o(input);
        let incomingRecord = dynamicNormalize$4(ingestParams)(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        }, luvio, store, timestamp);
        const existingRecord = store.records[key];
        if (existingRecord === undefined || equals$K(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        luvio.storeSetExpiration(key, timestamp + 30000);
        return createLink(key);
    };
}

const TTL$c = 900000;
function validate$1b(obj, path = 'RecordDefaultsTemplateCreateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1k(config) {
    return keyPrefix + 'RecordDefaultsTemplateCreateRepresentation:' + config.objectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$p(object) {
    const keyParams = {
        objectApiName: object.record.apiName,
        recordTypeId: object.record.recordTypeId
    };
    return keyBuilder$1k(keyParams);
}
function dynamicNormalize$5(ingestParams) {
    return function normalize_dynamic(input, existing, path, luvio, store, timestamp) {
        const input_objectInfos = input.objectInfos;
        const input_objectInfos_id = path.fullPath + '__objectInfos';
        const input_objectInfos_keys = Object.keys(input_objectInfos);
        const input_objectInfos_length = input_objectInfos_keys.length;
        for (let i = 0; i < input_objectInfos_length; i++) {
            const key = input_objectInfos_keys[i];
            const input_objectInfos_prop = input_objectInfos[key];
            const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
            input_objectInfos[key] = ingestParams.objectInfos(input_objectInfos_prop, {
                fullPath: input_objectInfos_prop_id,
                propertyName: key,
                parent: {
                    data: input,
                    key: path.fullPath,
                    existing: existing,
                }
            }, luvio, store, timestamp);
        }
        const input_record = input.record;
        const input_record_id = path.fullPath + '__record';
        input.record = ingestParams.record(input_record, {
            fullPath: input_record_id,
            propertyName: 'record',
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, luvio, store, timestamp);
        return input;
    };
}
const dynamicSelect$5 = function dynamicRecordDefaultsTemplateCreateRepresentationSelect(params) {
    const objectInfosPathSelection = params.objectInfos === undefined ? {
        name: 'objectInfos',
        kind: 'Link',
        map: true,
        fragment: select$f()
    } : params.objectInfos;
    const recordPathSelection = params.record === undefined ? {
        name: 'record',
        kind: 'Link',
        fragment: select$1f()
    } : params.record;
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            objectInfosPathSelection,
            recordPathSelection
        ]
    };
};
function equals$L(existing, incoming) {
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_record = existing.record;
    const incoming_record = incoming.record;
    if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
    }
    return true;
}
function dynamicIngest$4(ingestParams) {
    return function RecordDefaultsTemplateCreateRepresentationIngest(input, path, luvio, store, timestamp) {
        if (process.env.NODE_ENV !== 'production') {
            const validateError = validate$1b(input);
            if (validateError !== null) {
                throw validateError;
            }
        }
        const key = keyBuilderFromType$p(input);
        let incomingRecord = dynamicNormalize$5(ingestParams)(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
            propertyName: path.propertyName,
        }, luvio, store, timestamp);
        const existingRecord = store.records[key];
        if (existingRecord === undefined || equals$L(existingRecord, incomingRecord) === false) {
            luvio.storePublish(key, incomingRecord);
        }
        luvio.storeSetExpiration(key, timestamp + 900000);
        return createLink(key);
    };
}

function createFieldsIngest$3(params) {
    const { fields, optionalFields, trackedFields, recordConflictMap } = params;
    const ingest = dynamicIngest$3({
        fields: createFieldsIngestion(fields, optionalFields, recordConflictMap)
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$5(fields) {
    return dynamicSelect$4({
        fields: createPathSelection('fields', fields)
    });
}

function createFieldsIngest$4(params) {
    const { fields, optionalFields, trackedFields, recordConflictMap } = params;
    const ingest = dynamicIngest$4({
        objectInfos: ingest$8,
        record: createFieldsIngest$3(params)
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$6(fields) {
    return dynamicSelect$5({
        record: {
            kind: 'Link',
            name: 'record',
            fragment: selectFields$5(fields),
        }
    });
}

function createFieldsIngestSuccess$3(params) {
    const { trackedFields } = params;
    const recordConflictMap = {};
    const ingest = createFieldsIngest$4({
        ...params,
        recordConflictMap,
    });
    return (data, path, luvio, store, timestamp) => {
        const link = ingest(data, path, luvio, store, timestamp);
        resolveConflict(luvio, recordConflictMap);
        const recordNode = luvio.getNode(link.__ref);
        markMissingOptionalFields(recordNode, convertTrieToFields(trackedFields));
        return link;
    };
}
function selectFields$7(luvio, params) {
    const optionalFields = params.queryParams.optionalFields || [];
    const fields = [];
    const trie = convertRecordFieldsArrayToTrie(fields, optionalFields);
    return selectFields$6(trie);
}

function keyBuilder$1l(params) {
    return keyBuilder$1k({
        objectApiName: params.urlParams.objectApiName,
        recordTypeId: params.queryParams.recordTypeId || null
    });
}
function ingestError$t(luvio, params, error, snapshotRefresh) {
    const key = keyBuilder$1l(params);
    const errorSnapshot = luvio.errorSnapshot(error, snapshotRefresh);
    luvio.storeIngestError(key, errorSnapshot, TTL$c);
    return errorSnapshot;
}
function createResourceRequest$K(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/record-defaults/template/create/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

function adapterFragment$s(luvio, config) {
    const resourceParams = createResourceParams$y(config);
    return selectFields$7(luvio, resourceParams);
}

const getRecordTemplateCreate_ConfigPropertyNames = {
    displayName: 'getRecordTemplateCreate',
    parameters: {
        required: ['objectApiName'],
        optional: ['optionalFields', 'recordTypeId']
    }
};
function createResourceParams$y(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            optionalFields: config.optionalFields, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$s(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const recordTypeId = config.recordTypeId;
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$F(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$F(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$s(untrustedConfig);
    const config = typeCheckConfig$F(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function buildRecordTypeIdContextKey(objectApiName) {
    return `DEFAULTS::recordTypeId:${objectApiName}`;
}
function getRecordTypeId$2(context, adapterConfig) {
    const config = createResourceParams$y(adapterConfig);
    const { recordTypeId } = config.queryParams;
    if (recordTypeId !== undefined && recordTypeId !== null) {
        return recordTypeId;
    }
    const saved = context.get(buildRecordTypeIdContextKey(config.urlParams.objectApiName));
    if (saved === null || saved === undefined) {
        return undefined;
    }
    return saved;
}
function prepareRequest$4(luvio, context, config) {
    const resourceParams = createResourceParams$y(config);
    const recordTypeId = getRecordTypeId$2(context, config);
    const { objectApiName } = config;
    const resourceRequest = createResourceRequest$K(resourceParams);
    if (recordTypeId === undefined) {
        return resourceRequest;
    }
    const recordTemplateKey = keyBuilder$1j({
        apiName: objectApiName,
        recordTypeId: recordTypeId,
    });
    return createResourceRequest$K({
        ...resourceParams,
        queryParams: {
            ...resourceRequest.queryParams,
            optionalFields: getTrackedFields(recordTemplateKey, luvio.getNode(recordTemplateKey), config.optionalFields),
        },
    });
}
function onResourceResponseSuccess$u(luvio, context, config, request, response, resourceParams) {
    const { urlParams: { objectApiName }, queryParams: { optionalFields }, } = resourceParams;
    const { body } = response;
    const key = keyBuilderFromType$p(body);
    const responseRecordTypeId = body.record.recordTypeId;
    // publish metadata for recordTypeId
    const recordTypeId = body.objectInfos[objectApiName].defaultRecordTypeId;
    context.set(buildRecordTypeIdContextKey(objectApiName), recordTypeId);
    // mark missing optionalFields
    const templateRecordKey = keyBuilder$1j({
        apiName: objectApiName,
        recordTypeId: responseRecordTypeId,
    });
    const allTrackedFields = getTrackedFields(templateRecordKey, luvio.getNode(templateRecordKey), optionalFields);
    const allTrackedFieldsTrie = convertFieldsToTrie(allTrackedFields, true);
    const ingest = createFieldsIngestSuccess$3({
        fields: BLANK_RECORD_FIELDS_TRIE,
        optionalFields: allTrackedFieldsTrie,
        trackedFields: allTrackedFieldsTrie,
    });
    luvio.storeIngest(key, ingest, body);
    const snapshot = buildInMemorySnapshot$D(luvio, context, {
        ...config,
        recordTypeId: responseRecordTypeId,
    });
    if (process.env.NODE_ENV !== 'production') {
        if (snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
        }
    }
    luvio.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$v(luvio, context, config, resourceParams, error) {
    const snapshot = ingestError$t(luvio, resourceParams, error, {
        config,
        resolve: () => buildNetworkSnapshot$D(luvio, context, config, snapshotRefreshOptions),
    });
    luvio.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$D(luvio, context, config, override) {
    const resourceParams = createResourceParams$y(config);
    const request = prepareRequest$4(luvio, context, config);
    return luvio
        .dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$u(luvio, context, config, request, response, resourceParams);
    }, (response) => {
        return onResourceResponseError$v(luvio, context, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$y(luvio, context, config, snapshot) {
    const resourceParams = createResourceParams$y(config);
    const request = prepareRequest$4(luvio, context, config);
    return luvio.resolveUnfulfilledSnapshot(request, snapshot).then((response) => {
        return onResourceResponseSuccess$u(luvio, context, config, request, response, resourceParams);
    }, (response) => {
        return onResourceResponseError$v(luvio, context, config, resourceParams, response);
    });
}
function buildInMemorySnapshot$D(luvio, context, config) {
    const resourceParams = createResourceParams$y(config);
    const selector = {
        recordId: keyBuilder$1l(resourceParams),
        node: adapterFragment$s(luvio, config),
        variables: {},
    };
    return luvio.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$D(luvio, context, config, snapshotRefreshOptions),
    });
}
const factory$e = (luvio) => {
    return luvio.withContext(function UiApi__getRecordDefaultsTemplateForCreate(untrustedConfig, context) {
        const config = validateAdapterConfig$F(untrustedConfig, getRecordTemplateCreate_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
            return null;
        }
        const recordTypeId = getRecordTypeId$2(context, config);
        const cacheSnapshot = buildInMemorySnapshot$D(luvio, context, {
            ...config,
            recordTypeId,
        });
        // Cache Hit
        if (luvio.snapshotAvailable(cacheSnapshot) === true) {
            return cacheSnapshot;
        }
        if (isUnfulfilledSnapshot(cacheSnapshot)) {
            return resolveUnfulfilledSnapshot$y(luvio, context, config, cacheSnapshot);
        }
        return buildNetworkSnapshot$D(luvio, context, config);
    });
};

function createResourceRequest$L(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/records',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: config.queryParams,
        headers,
    };
}

function createResourceParams$z(config) {
    return {
        queryParams: {
            triggerOtherEmail: config.triggerOtherEmail, triggerUserEmail: config.triggerUserEmail, useDefaultRule: config.useDefaultRule
        },
        body: {
            allowSaveOnDuplicate: config.allowSaveOnDuplicate, apiName: config.apiName, fields: config.fields
        }
    };
}

const factory$f = (luvio) => {
    return function (untrustedConfig) {
        const resourceParams = createResourceParams$z(untrustedConfig);
        const request = createResourceRequest$L(resourceParams);
        const fieldTrie = BLANK_RECORD_FIELDS_TRIE;
        const optionalFieldTrie = BLANK_RECORD_FIELDS_TRIE;
        const recordIngest = createRecordIngest(fieldTrie, optionalFieldTrie);
        return luvio.dispatchResourceRequest(request).then((response) => {
            const { body } = response;
            const selections = buildSelectionFromRecord(body);
            const key = keyBuilder$2({
                recordId: body.id,
            });
            luvio.storeIngest(key, recordIngest, body);
            const snapshot = luvio.storeLookup({
                recordId: key,
                node: {
                    kind: 'Fragment',
                    private: [],
                    selections,
                },
                variables: {},
            });
            luvio.storeBroadcast();
            return snapshot;
        }, (err) => {
            deepFreeze$t(err);
            throw err;
        });
    };
};

function keyBuilder$1m(params) {
    return keyBuilder$2({
        recordId: params.urlParams.recordId
    });
}
function evictSuccess(luvio, resourceParams) {
    const key = keyBuilder$1m(resourceParams);
    luvio.storeEvict(key);
}
function createResourceRequest$M(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'delete',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        headers,
    };
}

const adapterName$1 = 'deleteRecord';
const deleteRecord_ConfigPropertyNames = {
    displayName: 'deleteRecord',
    parameters: {
        required: ['recordId'],
        optional: []
    }
};
function createResourceParams$A(config) {
    return {
        urlParams: {
            recordId: config.recordId
        }
    };
}
function coerceConfig$t(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    return coercedConfig;
}
function typeCheckConfig$G(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    return config;
}
function validateAdapterConfig$G(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$t(untrustedConfig);
    const config = typeCheckConfig$G(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildNetworkSnapshot$E(luvio, config, override) {
    const resourceParams = createResourceParams$A(config);
    const request = createResourceRequest$M(resourceParams);
    return luvio.dispatchResourceRequest(request, override)
        .then(() => {
        evictSuccess(luvio, resourceParams);
        luvio.storeBroadcast();
    }, (response) => {
        deepFreeze(response);
        throw response;
    });
}
const deleteRecordAdapterFactory = (luvio) => {
    return function uiApi__deleteRecord(untrustedConfig) {
        const config = validateAdapterConfig$G(untrustedConfig, deleteRecord_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
            throw new Error(`Invalid config for "${adapterName$1}"`);
        }
        return buildNetworkSnapshot$E(luvio, config);
    };
};

const factory$g = (luvio) => {
    const deleteRecordAdapterInstance = deleteRecordAdapterFactory(luvio);
    return (recordId) => deleteRecordAdapterInstance({ recordId: recordId });
};

function createResourceRequest$N(config) {
    const headers = {};
    const header_ifUnmodifiedSince = config.headers.ifUnmodifiedSince;
    if (header_ifUnmodifiedSince !== undefined) {
        headers['If-Unmodified-Since'] = header_ifUnmodifiedSince;
    }
    return {
        baseUri: '/services/data/v53.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        headers,
    };
}

const updateRecord_ConfigPropertyNames = {
    displayName: 'updateRecord',
    parameters: {
        required: ['recordId', 'fields'],
        optional: ['triggerOtherEmail', 'triggerUserEmail', 'useDefaultRule', 'allowSaveOnDuplicate', 'apiName', 'ifUnmodifiedSince']
    }
};
function createResourceParams$B(config) {
    return {
        urlParams: {
            recordId: config.recordId
        },
        queryParams: {
            triggerOtherEmail: config.triggerOtherEmail, triggerUserEmail: config.triggerUserEmail, useDefaultRule: config.useDefaultRule
        },
        body: {
            allowSaveOnDuplicate: config.allowSaveOnDuplicate, apiName: config.apiName, fields: config.fields
        },
        headers: {
            ifUnmodifiedSince: config.ifUnmodifiedSince
        }
    };
}
function coerceConfig$u(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    const triggerOtherEmail = config.triggerOtherEmail;
    if (triggerOtherEmail !== undefined) {
        coercedConfig.triggerOtherEmail = triggerOtherEmail;
    }
    const triggerUserEmail = config.triggerUserEmail;
    if (triggerUserEmail !== undefined) {
        coercedConfig.triggerUserEmail = triggerUserEmail;
    }
    const useDefaultRule = config.useDefaultRule;
    if (useDefaultRule !== undefined) {
        coercedConfig.useDefaultRule = useDefaultRule;
    }
    const allowSaveOnDuplicate = config.allowSaveOnDuplicate;
    if (allowSaveOnDuplicate !== undefined) {
        coercedConfig.allowSaveOnDuplicate = allowSaveOnDuplicate;
    }
    const apiName = config.apiName;
    if (apiName !== undefined) {
        coercedConfig.apiName = apiName;
    }
    const fields = config.fields;
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const ifUnmodifiedSince = config.ifUnmodifiedSince;
    if (ifUnmodifiedSince !== undefined) {
        coercedConfig.ifUnmodifiedSince = ifUnmodifiedSince;
    }
    return coercedConfig;
}
function typeCheckConfig$H(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_triggerOtherEmail = untrustedConfig.triggerOtherEmail;
    if (typeof untrustedConfig_triggerOtherEmail === 'boolean') {
        config.triggerOtherEmail = untrustedConfig_triggerOtherEmail;
    }
    const untrustedConfig_triggerUserEmail = untrustedConfig.triggerUserEmail;
    if (typeof untrustedConfig_triggerUserEmail === 'boolean') {
        config.triggerUserEmail = untrustedConfig_triggerUserEmail;
    }
    const untrustedConfig_useDefaultRule = untrustedConfig.useDefaultRule;
    if (typeof untrustedConfig_useDefaultRule === 'boolean') {
        config.useDefaultRule = untrustedConfig_useDefaultRule;
    }
    const untrustedConfig_allowSaveOnDuplicate = untrustedConfig.allowSaveOnDuplicate;
    if (typeof untrustedConfig_allowSaveOnDuplicate === 'boolean') {
        config.allowSaveOnDuplicate = untrustedConfig_allowSaveOnDuplicate;
    }
    const untrustedConfig_apiName = untrustedConfig.apiName;
    if (typeof untrustedConfig_apiName === 'string') {
        config.apiName = untrustedConfig_apiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
            const key = untrustedConfig_fields_keys[i];
            const untrustedConfig_fields_prop = untrustedConfig_fields[key];
            if (typeof untrustedConfig_fields_prop === 'string') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'number') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (untrustedConfig_fields_prop === null) {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'boolean') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
        }
        if (Object.keys(untrustedConfig_fields_object).length >= 0) {
            config.fields = untrustedConfig_fields_object;
        }
    }
    const untrustedConfig_ifUnmodifiedSince = untrustedConfig.ifUnmodifiedSince;
    if (typeof untrustedConfig_ifUnmodifiedSince === 'string') {
        config.ifUnmodifiedSince = untrustedConfig_ifUnmodifiedSince;
    }
    return config;
}
function validateAdapterConfig$H(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$u(untrustedConfig);
    const config = typeCheckConfig$H(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function getHeaders(clientOptions) {
    const headers = {};
    if (untrustedIsObject(clientOptions)) {
        if (typeof clientOptions.ifUnmodifiedSince === 'string') {
            headers.ifUnmodifiedSince = clientOptions.ifUnmodifiedSince;
        }
    }
    return headers;
}
const factory$h = (luvio) => {
    return (untrusted, clientOptions) => {
        let config = null;
        if (untrustedIsObject(untrusted) &&
            untrustedIsObject(untrusted.fields)) {
            config = validateAdapterConfig$H({ recordId: untrusted.fields.Id, ...untrusted }, updateRecord_ConfigPropertyNames);
        }
        // Invalid or incomplete config
        if (config === null) {
            throw new Error('Invalid recordInput');
        }
        const { recordId } = config;
        const headers = getHeaders(clientOptions);
        const resourceParams = createResourceParams$B({ ...config, ...headers });
        const request = createResourceRequest$N(resourceParams);
        const fieldTrie = BLANK_RECORD_FIELDS_TRIE;
        const optionalFieldTrie = BLANK_RECORD_FIELDS_TRIE;
        const recordIngest = createRecordIngest(fieldTrie, optionalFieldTrie);
        return luvio.dispatchResourceRequest(request).then((response) => {
            const { body } = response;
            const sel = buildSelectionFromRecord(body);
            const key = keyBuilder$2({
                recordId,
            });
            luvio.storeIngest(key, recordIngest, body);
            const snapshot = luvio.storeLookup({
                recordId: key,
                node: {
                    kind: 'Fragment',
                    private: [],
                    selections: sel,
                },
                variables: {},
            });
            luvio.storeBroadcast();
            return snapshot;
        }, (err) => {
            deepFreeze$t(err);
            throw err;
        });
    };
};

let createRecord;
let deleteRecord;
let getDuplicateConfiguration;
let getDuplicates;
let getGlobalActions;
let getLayout;
let getLayoutUserState;
let getListInfoByName;
let getListUi;
let getLookupActions;
let getLookupRecords;
let getNavItems;
let getObjectCreateActions;
let getObjectInfo;
let getObjectInfos;
let getPicklistValues;
let getPicklistValuesByRecordType;
let getQuickActionDefaults;
let getRecord$1;
let getRecordActions;
let getRecordAvatars;
let getRecordCreateDefaults;
let getRecordEditActions;
let getRecordTemplateClone;
let getRecordTemplateCreate;
let getRecordUi;
let getRecords;
let getRelatedListActions;
let getRelatedListCount;
let getRelatedListInfo;
let getRelatedListInfoBatch;
let getRelatedListRecordActions;
let getRelatedListRecords;
let getRelatedListRecordsBatch;
let getRelatedListsActions;
let getRelatedListsCount;
let getRelatedListsInfo;
let updateRecord;
let updateRecordAvatar;
function bindExportsTo(luvio) {
    function unwrapSnapshotData(factory) {
        const adapter = factory(luvio);
        return (...config) => adapter(...config).then(snapshot => snapshot.data);
    }
    return {
        createRecord: unwrapSnapshotData(factory$f),
        deleteRecord: factory$g(luvio),
        getDuplicateConfiguration: createWireAdapterConstructor(getDuplicateConfigurationAdapterFactory(luvio), "getDuplicateConfiguration", luvio),
        getDuplicates: createWireAdapterConstructor(getDuplicatesAdapterFactory(luvio), "getDuplicates", luvio),
        getGlobalActions: createWireAdapterConstructor(getGlobalActionsAdapterFactory(luvio), "getGlobalActions", luvio),
        getLayout: createWireAdapterConstructor(factory$5(luvio), "getLayout", luvio),
        getLayoutUserState: createWireAdapterConstructor(factory$6(luvio), "getLayoutUserState", luvio),
        getListInfoByName: createWireAdapterConstructor(getListInfoByNameAdapterFactory(luvio), "getListInfoByName", luvio),
        getListUi: createWireAdapterConstructor(factory$2(luvio), "getListUi", luvio),
        getLookupActions: createWireAdapterConstructor(getLookupActionsAdapterFactory(luvio), "getLookupActions", luvio),
        getLookupRecords: createWireAdapterConstructor(factory$8(luvio), "getLookupRecords", luvio),
        getNavItems: createWireAdapterConstructor(getNavItemsAdapterFactory(luvio), "getNavItems", luvio),
        getObjectCreateActions: createWireAdapterConstructor(getObjectCreateActionsAdapterFactory(luvio), "getObjectCreateActions", luvio),
        getObjectInfo: createWireAdapterConstructor(getObjectInfoAdapterFactory(luvio), "getObjectInfo", luvio),
        getObjectInfos: createWireAdapterConstructor(getObjectInfosAdapterFactory(luvio), "getObjectInfos", luvio),
        getPicklistValues: createWireAdapterConstructor(factory$9(luvio), "getPicklistValues", luvio),
        getPicklistValuesByRecordType: createWireAdapterConstructor(getPicklistValuesByRecordTypeAdapterFactory(luvio), "getPicklistValuesByRecordType", luvio),
        getQuickActionDefaults: createWireAdapterConstructor(getQuickActionDefaultsAdapterFactory(luvio), "getQuickActionDefaults", luvio),
        getRecord: createWireAdapterConstructor(factory$4(luvio), "getRecord", luvio),
        getRecordActions: createWireAdapterConstructor(getRecordActionsAdapterFactory(luvio), "getRecordActions", luvio),
        getRecordAvatars: createWireAdapterConstructor(factory$a(luvio), "getRecordAvatars", luvio),
        getRecordCreateDefaults: createWireAdapterConstructor(factory$c(luvio), "getRecordCreateDefaults", luvio),
        getRecordEditActions: createWireAdapterConstructor(getRecordEditActionsAdapterFactory(luvio), "getRecordEditActions", luvio),
        getRecordTemplateClone: createWireAdapterConstructor(factory$d(luvio), "getRecordTemplateClone", luvio),
        getRecordTemplateCreate: createWireAdapterConstructor(factory$e(luvio), "getRecordTemplateCreate", luvio),
        getRecordUi: createWireAdapterConstructor(factory$3(luvio), "getRecordUi", luvio),
        getRecords: createWireAdapterConstructor(getRecordsAdapterFactory(luvio), "getRecords", luvio),
        getRelatedListActions: createWireAdapterConstructor(getRelatedListActionsAdapterFactory(luvio), "getRelatedListActions", luvio),
        getRelatedListCount: createWireAdapterConstructor(getRelatedListCountAdapterFactory(luvio), "getRelatedListCount", luvio),
        getRelatedListInfo: createWireAdapterConstructor(getRelatedListInfoAdapterFactory(luvio), "getRelatedListInfo", luvio),
        getRelatedListInfoBatch: createWireAdapterConstructor(getRelatedListInfoBatchAdapterFactory(luvio), "getRelatedListInfoBatch", luvio),
        getRelatedListRecordActions: createWireAdapterConstructor(getRelatedListRecordActionsAdapterFactory(luvio), "getRelatedListRecordActions", luvio),
        getRelatedListRecords: createWireAdapterConstructor(getRelatedListRecordsAdapterFactory(luvio), "getRelatedListRecords", luvio),
        getRelatedListRecordsBatch: createWireAdapterConstructor(getRelatedListRecordsBatchAdapterFactory(luvio), "getRelatedListRecordsBatch", luvio),
        getRelatedListsActions: createWireAdapterConstructor(getRelatedListsActionsAdapterFactory(luvio), "getRelatedListsActions", luvio),
        getRelatedListsCount: createWireAdapterConstructor(getRelatedListsCountAdapterFactory(luvio), "getRelatedListsCount", luvio),
        getRelatedListsInfo: createWireAdapterConstructor(getRelatedListsInfoAdapterFactory(luvio), "getRelatedListsInfo", luvio),
        updateRecord: unwrapSnapshotData(factory$h),
        updateRecordAvatar: unwrapSnapshotData(factory$b)
    };
}
withDefaultLuvio((luvio) => {
    ({
        createRecord,
        deleteRecord,
        getDuplicateConfiguration,
        getDuplicates,
        getGlobalActions,
        getLayout,
        getLayoutUserState,
        getListInfoByName,
        getListUi,
        getLookupActions,
        getLookupRecords,
        getNavItems,
        getObjectCreateActions,
        getObjectInfo,
        getObjectInfos,
        getPicklistValues,
        getPicklistValuesByRecordType,
        getQuickActionDefaults,
        getRecord: getRecord$1,
        getRecordActions,
        getRecordAvatars,
        getRecordCreateDefaults,
        getRecordEditActions,
        getRecordTemplateClone,
        getRecordTemplateCreate,
        getRecordUi,
        getRecords,
        getRelatedListActions,
        getRelatedListCount,
        getRelatedListInfo,
        getRelatedListInfoBatch,
        getRelatedListRecordActions,
        getRelatedListRecords,
        getRelatedListRecordsBatch,
        getRelatedListsActions,
        getRelatedListsCount,
        getRelatedListsInfo,
        updateRecord,
        updateRecordAvatar
    } = bindExportsTo(luvio));
});

let getRecordNotifyChange, refresh$1;
withDefaultLuvio((luvio) => {
    getRecordNotifyChange = notifyChangeFactory(luvio);
    refresh$1 = bindWireRefresh(luvio);
});

export { MRU, createRecord, createRecordInputFilteredByEditedFields, deleteRecord, generateRecordInputForCreate, generateRecordInputForUpdate, getDuplicateConfiguration, getDuplicates, getFieldDisplayValue, getFieldValue, getGlobalActions, getLayout, getLayoutUserState, getListInfoByName, getListUi, getLookupActions, getLookupRecords, getNavItems, getObjectCreateActions, getObjectInfo, getObjectInfos, getPicklistValues, getPicklistValuesByRecordType, getQuickActionDefaults, getRecord$1 as getRecord, getRecordActions, getRecordAvatars, getRecordCreateDefaults, getRecordEditActions, getRecordInput, getRecordNotifyChange, getRecordTemplateClone, getRecordTemplateCreate, getRecordUi, getRecords, getRelatedListActions, getRelatedListCount, getRelatedListInfo, getRelatedListInfoBatch, getRelatedListRecordActions, getRelatedListRecords, getRelatedListRecordsBatch, getRelatedListsActions, getRelatedListsCount, getRelatedListsInfo, refresh$1 as refresh, updateRecord, updateRecordAvatar };
